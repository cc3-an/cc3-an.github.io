{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenidos a CC-3 En cursos anteriores han aprendido a programar en un nivel bastante alto de abstracci\u00f3n. Ac\u00e1 nos concentraremos en la m\u00e1quina y c\u00f3mo esta ejecuta los programas que ustedes escriben. En este curso nos preocuparemos no tanto por el proceso de escribir un programa de computadora, sino m\u00e1s bien en c\u00f3mo la computadora ejecuta los programas. Es decir, el tema principal de este curso es la estructura de la m\u00e1quina: los circuitos electr\u00f3nicos, y las operaciones computacionales que estos circuitos llevan a cabo. Para concretizar estas ideas, vamos a estudiar con cierto detalle el ISA RISC-V. Usamos este ISA pues es m\u00e1s sencillo que otras familias, mientras que posee caracter\u00edsticas deseables como paralelismo.","title":"Inicio"},{"location":"#bienvenidos-a-cc-3","text":"En cursos anteriores han aprendido a programar en un nivel bastante alto de abstracci\u00f3n. Ac\u00e1 nos concentraremos en la m\u00e1quina y c\u00f3mo esta ejecuta los programas que ustedes escriben. En este curso nos preocuparemos no tanto por el proceso de escribir un programa de computadora, sino m\u00e1s bien en c\u00f3mo la computadora ejecuta los programas. Es decir, el tema principal de este curso es la estructura de la m\u00e1quina: los circuitos electr\u00f3nicos, y las operaciones computacionales que estos circuitos llevan a cabo. Para concretizar estas ideas, vamos a estudiar con cierto detalle el ISA RISC-V. Usamos este ISA pues es m\u00e1s sencillo que otras familias, mientras que posee caracter\u00edsticas deseables como paralelismo.","title":"Bienvenidos a CC-3"},{"location":"labs/lab00/","text":"Lab 0 - Git y Representaci\u00f3n de N\u00fameros Objetivos Aprender git y crear cuenta de GitHub. Ganar m\u00e1s intuici\u00f3n para trabajar con n\u00fameros binarios. Lecturas P&H: 2.4 Ejercicio 1: Cuenta de GitHub Por favor lean las siguientes instrucciones cuidadosamente antes de seguir con el laboratorio. La mayor parte de los problemas que tienen los estudiantes durante este laboratorio se pueden prevenir siguiendo atentamente los pasos que se indican. Para este curso necesitaremos que utilicen git , un sistema de control de versiones distribuido . Los sistemas de control de versiones son las mejores herramientas para compartir y almacenar c\u00f3digo a comparaci\u00f3n de mandar correos con archivos adjuntos, utilizar memorias flash, o incluso compartir documentos mediante DropBox o Google Docs. Vamos a estar usando GitHub para tener repositorios privados en donde van a almacenar su c\u00f3digo remotamente. Si la oraci\u00f3n anterior no les dijo nada, no se preocupen, vamos a guiarlos en el proceso m\u00e1s adelante. Pero primero, necesitan crear una cuenta de GitHub . \u00bfPor qu\u00e9 GitHub? GitHub ahora le permite a todas las cuentas gratuitas tener repositorios privados ilimitados con algunas limitaciones que no van a ser ning\u00fan problema para nosotros. GitHub Onboarding Naveguen a la siguiente p\u00e1gina: github.com . Si no tienen una cuenta de GitHub todav\u00eda, creen una en el siguiente link . Preparaci\u00f3n Visiten este link . Aqu\u00ed encontrar\u00e1n todos los archivos necesarios para completar este laboratorio. En esta p\u00e1gina, encontrar\u00e1n un bot\u00f3n que dice \"Accept this assignment\". Al presionar este bot\u00f3n, se crear\u00e1 autom\u00e1ticamente un repositorio en Github llamado https://www.github.com/cc3-an/2022-lab00-git-<USUARIO> . Noten que el \"due\u00f1o\" de este repositorio es un usuario llamado cc3-an , y el usuario de ustedes es \u00fanicamente el sufijo del nombre del repo. De esta forma, nos encargamos de tener acceso siempre a su c\u00f3digo, en caso existan copias o cualquier otro tipo de trampa. Sepan de una vez que, si encontramos plagio en sus laboratorios, su nota ser\u00e1 AUTOM\u00c1TICAMENTE 0, sin posibilidad de cambiarla. De repetirse nuevamente este acontecimiento, el staff del curso organizar\u00e1 una reuni\u00f3n con ustedes y sus directores de carrera para contarles lo ocurrido y sancionarlos conforme al reglamento de la universidad. Despu\u00e9s de realizar esto, en la m\u00e1quina virtual (o sus propias computadoras) abran una terminal en el directorio que prefieran, y ejecuten el siguiente comando: 1 git clone https://github.com/cc3-an/2022-lab00-git-<SU USUARIO DE GITHUB> esto descargar\u00e1 en el directorio que escogieron todos los archivos base para este laboratorio. Configurando git Ahora que ya hemos creado nuestro repositorio, vamos a configurar git para que sepa qui\u00e9nes son. Abran una terminal Ctrl + Alt + T y ejecuten los siguientes comandos listados abajo, reemplazando NOMBRE con su nombre y apellido (entre comillas) y CORREO con la direcci\u00f3n de correo que utilizar\u00f3n para registrarse en GitHub. 1 git config --global user.name \"NOMBRE\" 1 git config --global user.email \"CORREO\" Ejercicio 2: git y Remotes Primero, algunas definiciones r\u00e1pidas: Un remote es la p\u00e1gina web host o servidor que va a almacenar su c\u00f3digo remotamente en vez de tener \u00fanicamente el c\u00f3digo de forma local en su propia computadora. Pueden pensar en esto de igual manera a como se almacena un archivo en DropBox o Google Drive pero con el poder que nos da git. Un branch es una secuencia (por aparte) de diferentes cambios a su c\u00f3digo. Pueden pensar en los branches como diferentes versiones de su c\u00f3digo, que en alg\u00fan punto fueron lo mismo. La siguiente figura muestra a que nos referimos como branches. A lo largo de este curso, estar\u00e1n trabajando en dos diferentes \" computadoras \" que generalmente tendran diferentes versiones de su c\u00f3digo en alg\u00fan tiempo. Estas dos son: su computadora personal y su remote de GitHub (sus repositorios privados de GitHub). Es esencial que entiendan la diferencia entre estas dos y como pueden compartir c\u00f3digo entre ellas. Su computadora personal es la que les servir\u00e1 para hacer todo el trabajo (laboratorios y proyectos) que necesiten hacer durante el curso, nada nuevo aqu\u00ed. Su cuenta de GitHub y los remotes les servir\u00e1n para muchos prop\u00f3sitos, pero la principal raz\u00f3n es para tener un backup o copia de respaldo, de tal manera que si algo malo le sucede a sus computadoras (esperamos no ), puedan recuperar su c\u00f3digo en vez de empezar de cero nuevamente. Conceptualmente, pueden pensar en los remotes de GitHub como otra computadora que \u00fanicamente almacena su c\u00f3digo y nada m\u00e1s. Siempre deben subir sus cambios a GitHub haciendo push al remote (es decir actualizando los archivos en GitHub) y tambi\u00e9n pueden descargar los cambios de GitHub haciendo pull (actualizando los archivos en su computadora personal). Haciendo push hacia GitHub Vamos a crear un archivo llamado hello.sh en la carpeta del laboratorio ejecutando el siguiente commando en la terminal: 1 echo 'echo \"Hola Mundo\"' > hello.sh Luego pueden correr el archivo en la terminal con bash hello.sh . En la terminal se imprimir\u00e1 Hola Mundo . Ahora utilicemos git para ver los archivos que todav\u00eda no han sido rastreados utilizando status : 1 git status Lo que producir\u00e1 lo siguiente: 1 2 3 4 5 6 7 8 9 10 On branch main No commits yet Untracked files: ( use \"git add <file>...\" to include in what will be committed ) hello.sh nothing added to commit but untracked files present ( use \"git add\" to track ) Esto es porque hemos creado un archivo nuevo llamado hello.sh y no lo hemos agregado. Podemos agregarlo y hacer commit: 1 2 3 4 git add hello.sh # agrega el archivo hello.sh para hacer commit git commit -m \"Mensaje del Commit\" # ingresa cualquier mensaje que quieras git branch # deberias de ver que solo existe el branch main y que estas en ella (*) git push -u origin main # Esto hace push de tu codigo hacia GitHub (lo puedes ver en GitHub ahora) El control de versiones git esta construido alrededor de commits , o checkpoints en el desarrollo de diferentes versiones/etapas de su c\u00f3digo. Para explicar los pasos de arriba un poco m\u00e1s: git add [archivo] le dir\u00e1 a git que han hecho cambios a ese archivo y que quieren que esos cambios se guarden en el siguiente commit (staging). git commit -m \"mensaje\" oficialmente guarda esos cambios que acaban de agregar, y crea un snapshot del contenido actual de todos los archivos en el repositorio. Ahora siempre van a tener la opci\u00f3n de revertir su c\u00f3digo hacia este commit. git push -u origin main manda todo el contenido del repositorio que est\u00e1 en el branch \"main\" al repositorio remoto \"origin\" (recuerden que agregamos el repositorio de GitHub \"lab0_git\" como remote y lo llamamos \"origin\"). Cuando estamos trabajando con git, si alguna vez no est\u00e1n seguros de algo, pero quieren asegurarse de que tienen una copia guardada del contenido actual de su c\u00f3digo, solo tienen que correr git add . y despu\u00e9s git commit en la terminal. Un \u00faltimo comando de git que pueden encontrar bastante util es git log . Pueden ejectuar este comando en la terminal y van a ver un historial o log de todos los commits que se han hecho (en el branch actual), incluyendo el tiempo y quien hizo el commit.","title":"00: Git"},{"location":"labs/lab00/#lab-0-git-y-representacion-de-numeros","text":"","title":"Lab 0 - Git y Representaci\u00f3n de N\u00fameros"},{"location":"labs/lab00/#objetivos","text":"Aprender git y crear cuenta de GitHub. Ganar m\u00e1s intuici\u00f3n para trabajar con n\u00fameros binarios.","title":"Objetivos"},{"location":"labs/lab00/#lecturas","text":"P&H: 2.4","title":"Lecturas"},{"location":"labs/lab00/#ejercicio-1-cuenta-de-github","text":"Por favor lean las siguientes instrucciones cuidadosamente antes de seguir con el laboratorio. La mayor parte de los problemas que tienen los estudiantes durante este laboratorio se pueden prevenir siguiendo atentamente los pasos que se indican. Para este curso necesitaremos que utilicen git , un sistema de control de versiones distribuido . Los sistemas de control de versiones son las mejores herramientas para compartir y almacenar c\u00f3digo a comparaci\u00f3n de mandar correos con archivos adjuntos, utilizar memorias flash, o incluso compartir documentos mediante DropBox o Google Docs. Vamos a estar usando GitHub para tener repositorios privados en donde van a almacenar su c\u00f3digo remotamente. Si la oraci\u00f3n anterior no les dijo nada, no se preocupen, vamos a guiarlos en el proceso m\u00e1s adelante. Pero primero, necesitan crear una cuenta de GitHub . \u00bfPor qu\u00e9 GitHub? GitHub ahora le permite a todas las cuentas gratuitas tener repositorios privados ilimitados con algunas limitaciones que no van a ser ning\u00fan problema para nosotros.","title":"Ejercicio 1: Cuenta de GitHub"},{"location":"labs/lab00/#github-onboarding","text":"Naveguen a la siguiente p\u00e1gina: github.com . Si no tienen una cuenta de GitHub todav\u00eda, creen una en el siguiente link .","title":"GitHub Onboarding"},{"location":"labs/lab00/#preparacion","text":"Visiten este link . Aqu\u00ed encontrar\u00e1n todos los archivos necesarios para completar este laboratorio. En esta p\u00e1gina, encontrar\u00e1n un bot\u00f3n que dice \"Accept this assignment\". Al presionar este bot\u00f3n, se crear\u00e1 autom\u00e1ticamente un repositorio en Github llamado https://www.github.com/cc3-an/2022-lab00-git-<USUARIO> . Noten que el \"due\u00f1o\" de este repositorio es un usuario llamado cc3-an , y el usuario de ustedes es \u00fanicamente el sufijo del nombre del repo. De esta forma, nos encargamos de tener acceso siempre a su c\u00f3digo, en caso existan copias o cualquier otro tipo de trampa. Sepan de una vez que, si encontramos plagio en sus laboratorios, su nota ser\u00e1 AUTOM\u00c1TICAMENTE 0, sin posibilidad de cambiarla. De repetirse nuevamente este acontecimiento, el staff del curso organizar\u00e1 una reuni\u00f3n con ustedes y sus directores de carrera para contarles lo ocurrido y sancionarlos conforme al reglamento de la universidad. Despu\u00e9s de realizar esto, en la m\u00e1quina virtual (o sus propias computadoras) abran una terminal en el directorio que prefieran, y ejecuten el siguiente comando: 1 git clone https://github.com/cc3-an/2022-lab00-git-<SU USUARIO DE GITHUB> esto descargar\u00e1 en el directorio que escogieron todos los archivos base para este laboratorio.","title":"Preparaci\u00f3n"},{"location":"labs/lab00/#configurando-git","text":"Ahora que ya hemos creado nuestro repositorio, vamos a configurar git para que sepa qui\u00e9nes son. Abran una terminal Ctrl + Alt + T y ejecuten los siguientes comandos listados abajo, reemplazando NOMBRE con su nombre y apellido (entre comillas) y CORREO con la direcci\u00f3n de correo que utilizar\u00f3n para registrarse en GitHub. 1 git config --global user.name \"NOMBRE\" 1 git config --global user.email \"CORREO\"","title":"Configurando git"},{"location":"labs/lab00/#ejercicio-2-git-y-remotes","text":"Primero, algunas definiciones r\u00e1pidas: Un remote es la p\u00e1gina web host o servidor que va a almacenar su c\u00f3digo remotamente en vez de tener \u00fanicamente el c\u00f3digo de forma local en su propia computadora. Pueden pensar en esto de igual manera a como se almacena un archivo en DropBox o Google Drive pero con el poder que nos da git. Un branch es una secuencia (por aparte) de diferentes cambios a su c\u00f3digo. Pueden pensar en los branches como diferentes versiones de su c\u00f3digo, que en alg\u00fan punto fueron lo mismo. La siguiente figura muestra a que nos referimos como branches. A lo largo de este curso, estar\u00e1n trabajando en dos diferentes \" computadoras \" que generalmente tendran diferentes versiones de su c\u00f3digo en alg\u00fan tiempo. Estas dos son: su computadora personal y su remote de GitHub (sus repositorios privados de GitHub). Es esencial que entiendan la diferencia entre estas dos y como pueden compartir c\u00f3digo entre ellas. Su computadora personal es la que les servir\u00e1 para hacer todo el trabajo (laboratorios y proyectos) que necesiten hacer durante el curso, nada nuevo aqu\u00ed. Su cuenta de GitHub y los remotes les servir\u00e1n para muchos prop\u00f3sitos, pero la principal raz\u00f3n es para tener un backup o copia de respaldo, de tal manera que si algo malo le sucede a sus computadoras (esperamos no ), puedan recuperar su c\u00f3digo en vez de empezar de cero nuevamente. Conceptualmente, pueden pensar en los remotes de GitHub como otra computadora que \u00fanicamente almacena su c\u00f3digo y nada m\u00e1s. Siempre deben subir sus cambios a GitHub haciendo push al remote (es decir actualizando los archivos en GitHub) y tambi\u00e9n pueden descargar los cambios de GitHub haciendo pull (actualizando los archivos en su computadora personal).","title":"Ejercicio 2: git y Remotes"},{"location":"labs/lab00/#haciendo-push-hacia-github","text":"Vamos a crear un archivo llamado hello.sh en la carpeta del laboratorio ejecutando el siguiente commando en la terminal: 1 echo 'echo \"Hola Mundo\"' > hello.sh Luego pueden correr el archivo en la terminal con bash hello.sh . En la terminal se imprimir\u00e1 Hola Mundo . Ahora utilicemos git para ver los archivos que todav\u00eda no han sido rastreados utilizando status : 1 git status Lo que producir\u00e1 lo siguiente: 1 2 3 4 5 6 7 8 9 10 On branch main No commits yet Untracked files: ( use \"git add <file>...\" to include in what will be committed ) hello.sh nothing added to commit but untracked files present ( use \"git add\" to track ) Esto es porque hemos creado un archivo nuevo llamado hello.sh y no lo hemos agregado. Podemos agregarlo y hacer commit: 1 2 3 4 git add hello.sh # agrega el archivo hello.sh para hacer commit git commit -m \"Mensaje del Commit\" # ingresa cualquier mensaje que quieras git branch # deberias de ver que solo existe el branch main y que estas en ella (*) git push -u origin main # Esto hace push de tu codigo hacia GitHub (lo puedes ver en GitHub ahora) El control de versiones git esta construido alrededor de commits , o checkpoints en el desarrollo de diferentes versiones/etapas de su c\u00f3digo. Para explicar los pasos de arriba un poco m\u00e1s: git add [archivo] le dir\u00e1 a git que han hecho cambios a ese archivo y que quieren que esos cambios se guarden en el siguiente commit (staging). git commit -m \"mensaje\" oficialmente guarda esos cambios que acaban de agregar, y crea un snapshot del contenido actual de todos los archivos en el repositorio. Ahora siempre van a tener la opci\u00f3n de revertir su c\u00f3digo hacia este commit. git push -u origin main manda todo el contenido del repositorio que est\u00e1 en el branch \"main\" al repositorio remoto \"origin\" (recuerden que agregamos el repositorio de GitHub \"lab0_git\" como remote y lo llamamos \"origin\"). Cuando estamos trabajando con git, si alguna vez no est\u00e1n seguros de algo, pero quieren asegurarse de que tienen una copia guardada del contenido actual de su c\u00f3digo, solo tienen que correr git add . y despu\u00e9s git commit en la terminal. Un \u00faltimo comando de git que pueden encontrar bastante util es git log . Pueden ejectuar este comando en la terminal y van a ver un historial o log de todos los commits que se han hecho (en el branch actual), incluyendo el tiempo y quien hizo el commit.","title":"Haciendo push hacia GitHub"},{"location":"labs/lab01/","text":"Lab 1 - Punteros en C y GDB Objetivos Aprender c\u00f3mo compilar y ejecutar un programa en C. Examinar diferentes tipos de control de flujo en C. Introducirlos al debugger (depurador) de C Conseguir experiencia pr\u00e1ctica utilizando GBD para depurar programas en C. Ganar m\u00e1s confianza al trabajar con punteros. Preparaci\u00f3n Visiten este link . Aqu\u00ed encontrar\u00e1n todos los archivos necesarios para completar este lab. En esta p\u00e1gina, encontrar\u00e1n un bot\u00f3n que dice \"Accept assignment\". Al presionar este bot\u00f3n, se crear\u00e1 autom\u00e1ticamente un repositorio en Github llamado www.github.com/cc3-an/lab01-2021-USUARIO . Noten que el \"due\u00f1o\" de este repositorio es un usuario llamado cc3-an , y el usuario de ustedes es \u00fanicamente el sufijo del nombre del repo. De esta forma, nos encargamos de tener acceso siempre a su c\u00f3digo, en caso existan copias o cualquier otro tipo de trampa. Sepan de una vez que, si encontramos plagio o cualquier otro tipo de trampa en sus laboratorios, su nota ser\u00e1 AUTOM\u00c1TICAMENTE 0, sin posibilidad de cambiarla. De repetirse nuevamente este acontecimiento, el staff del curso organizar\u00e1 una reuni\u00f3n con ustedes y sus directores de carrera para contarles lo ocurrido y sancionarlos conforme al reglamento de la universidad. Despu\u00e9s de realizar esto, en la m\u00e1quina virtual (o sus propias computadoras) abran una terminal en el directorio que prefieran, y ejecuten el siguiente comando: 1 git clone https://github.com/cc3-an/lab1-2021-<SU USUARIO DE GITHUB> Esto descargar\u00e1 en el directorio que escogieron todos los archivos base para este laboratorio. Para futuro, un clone solo lo hacemos la primera vez que vamos a bajar el codigo de un repositorio a nuestra maquina. Nunca bajen el zip que Github les ofrece, por favor, eso solo nos va a causar problemas. Compilando y ejecutando un programa de C En este laboratorio, estaremos usando el programa gcc para compilar programas en c. La manera m\u00e1s sencilla de ejecutar gcc es la siguiente: 1 gcc program.c Esto compila el archivo program.c y crea un archivo ejecutable llamado a.out . Si tienen experiencia en Java, pueden m\u00e1s o menos considerar a gcc como el equivalente en C de javac . Este archivo se puede ejecutar con el siguiente comando: 1 ./a.out El archivo ejecutable es a.out , as\u00ed que, \u00bfqu\u00e9 rayos es eso de punto y diagonal? La respuesta: cuando quieren ejecutar un ejecutable, es necesario preponer una ruta de archivo para distinguirlo de un comando como python (no se utiliza ./python ). El punto se refiere al \"directorio actual\". De paso, dos puntos (..) se referir\u00edan al directorio que est\u00e1 un nivel arriba. gcc tiene varias opciones (o argumentos) de l\u00ednea de comandos, los cuales les recomendamos explorar. En este laboratorio, vamos a estar usando solamente -o, que se usa para especificar el nombre del ejecutable que gcc genera. Usando -o, se utilizar\u00edan estos comandos para compilar program.c en un archivo llamado program , y ejecutarlo. Eso nos sirve si no queremos que todos nuestros archivos ejecutables se llamen a.out . 1 2 gcc -o program program.c ./program Ejercicio 1: Programa simple de C En este ejercicio, veremos un ejemplo de definiciones macro de preprocesador. Las macros pueden ser un tema complicado, pero en general, la forma en que funcionan es que, antes de que un archivo en C es compilado, las constantes macro son reemplazadas exactamente por el valor al que se refieren. En este ejercicio, estaremos usando macros exclusivamente como constantes globales. Aqu\u00ed definimos CONSTANT_NAME como un literal_value (una literal entera). Noten que solo hay 1 espacio separando el nombre del valor. 1 #define CONSTANT_NAME LITERAL_VALUE Ahora, vean el c\u00f3digo en eccentric.c (en el repo). Noten los cuatro diferentes ejemplos de control b\u00e1sico de flujo. (\u00bfCu\u00e1les son?) Compilen y ejecuten el programa para ver lo que hace. Jueguen con las constantes de las cuatro macros: v0 a v3 . Vean c\u00f3mo cambiar cada uno de estos cambia el output del programa. Su tarea: Modificando s\u00f3lo estos cuatro valores, hagan que el programa produzca el siguiente mensaje: 1 2 3 4 5 6 7 8 $ gcc -o eccentric eccentric.c $ ./eccentric Berkeley eccentrics: ==================== Happy Happy Happy Yoshua Go BEARS! Hay m\u00faltiples combinaciones de valores en las macros que consiguen este resultado, El reto para ustedes en este ejercicio es: Consideren el m\u00ednimo n\u00famero de distintos valores que las constantes v0 a v3 puedan tener que a\u00fan den el mismo resultado correcto. Como ejemplo, el m\u00e1ximo te\u00f3rico es cuatro (cuando todos son diferentes uno de otro). Cuando ya hayan logrado esto, pueden actualizar el archivo en su repositorio en Github, de esta manera: 1 2 3 $ git add eccentric.c $ git commit -m \"Ejercicio 1 terminado\" $ git push -u origin main Ejercicio 2: Debugger (depurador) \u00bfQu\u00e9 es un debugger ? Este p\u00e1rrafo es para los estudiantes que no est\u00e1n familiarizados con los debuggers . Un debugger , como sugiere el nombre, es un programa espec\u00edficamente dise\u00f1ado para ayudarlos a encontrar bugs , o errores l\u00f3gicos, u otros errores en el c\u00f3digo (nota: si quieren saber por qu\u00e9 se les llama bugs a los errores, vean aqu\u00ed ). Distintos debuggers tienen distintas caracter\u00edsticas, pero es normal que todos los debuggers sean capaces de hacer las siguientes cosas: Poner un breakpoint en el programa. Un Breakpoint es una l\u00ednea espec\u00edfica en su c\u00f3digo en donde quisieran que se detenga la ejecuci\u00f3n del programa, para que puedan ver lo que est\u00e1 pasando alrededor. Ejecuci\u00f3n por Steps (l\u00ednea a l\u00ednea) por el programa. El c\u00f3digo siempre se ejecuta l\u00ednea a l\u00ednea, pero pasa muy r\u00e1pido como para que sepamos qu\u00e9 l\u00ednea produce alg\u00fan error. Ser capaces de ejecutar l\u00ednea a l\u00ednea el programa les permite observar exactamente qu\u00e9 esta causando un bug en el programa. Para este ejercicio, necesitar\u00e1n la GDB reference card . GDB quiere decir \"GNU De-Bugger\". Compilen hello.c con la bandera \"-g\": 1 gcc -g -o hello hello.c Esto har\u00e1 que gcc guarde informaci\u00f3n en el archivo ejecutable para que gdb lo interprete. Ahora ejecuten el debugger, (c)gdb: 1 cgdb hello Vean lo que hace este comando. Est\u00e1n ejecutando el programa cgdb en el ejecutable hello generado por gcc . No intenten ejecutar cgdb en el archivo fuente en hello.c ! Eso no va a funcionar. Si cgdb no funciona, gdb se puede usar para completar los ejercicios (utilicen gdb hello ). Su tarea: ejecuten el programa varias veces haciendo esto: Poniendo un breakpoint en el main. Usando el comando run de gdb. Utilizando el comando single-step de gdb. Escriban help adentro de gdb para averiguar c\u00f3mo hacer estas cosas, o usen la reference card. Si encuentran un mensaje de error que dice: printf.c: No such file or directory . Probablemente entraron a una funci\u00f3n printf . Si siguen ejecutando paso a paso, pareciera que nunca avanzaran en el c\u00f3digo. CGDB est\u00e1 dando el error porque no tienen el archivo en el que se define la funci\u00f3n printf . Esto es algo molesto, y para librarse de esto, usen el comando finish para ejecutar el programa hasta que termine la funci\u00f3n printf. Y la pr\u00f3xima vez , utilicen el comando next para saltar sobre la linea que usa printf . Nota: CGDB vs GDB . En este ejercicio, usamos cgdb para depurar nuestros programas. cgdb es id\u00e9ntico a gdb, excepto que tiene unas caracter\u00edsticas extra que hacen m\u00e1s c\u00f3modo el trabajo. Todos los comandos de la hoja de referencia funcionan tambi\u00e9n en gdb. En cgdb, pueden presionar ESC para ir a la ventana del c\u00f3digo (arriba), y usar i para regresar a la ventana de comandos (abajo), similar a vim . La ventana de comandos es donde se introducen los comandos de gdb. Para este ejercicio, encontrar\u00e1n un archivo de texto llamado ex2.txt, con el siguiente formato: 1 2 3 4 5 6 7 8 9 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : Aqu\u00ed tendr\u00e1n que responder las siguientes preguntas de opci\u00f3n m\u00faltiple (no tengan miedo de probar las opciones en CGDB antes de responder, \u00a1lo recomendamos!) con el siguiente formato (tienen que cambiar la letra en el ejemplo por la letra de la respuesta que ustedes consideren correcta): 1 2 3 4 5 6 7 8 9 1 :e 2 :f 3 :g 4 :h 5 :i 6 :j 7 :k 8 :l 9 :m Preguntas 1. \u00bfC\u00f3mo se le dan argumentos desde la l\u00ednea de comandos a un programa al utilizar gdb? a. args arglist b. run arglist c. gdb args d. Ninguna de las anteriores 2. \u00bfC\u00f3mo se a\u00f1ade un breakpoint que s\u00f3lo ocurre cuando se cumplen ciertas condiciones (por ejemplo, ciertas variables alcanzan cierto valor)? a. expr cond b. cond break expr c. break ... if expr d. Ninguna de las anteriores 3. \u00bfCon qu\u00e9 comando se ejecuta la siguiente l\u00ednea del c\u00f3digo en C despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 4. Si la siguiente l\u00ednea de c\u00f3digo es una llamada a funci\u00f3n, \u00bfse ejecutar\u00eda toda la funci\u00f3n si se utiliza el comando de la pregunta #3? (si no, es momento de cambiarla!). \u00bfC\u00f3mo se le indica a gdb, que quieren debuggear el c\u00f3digo adentro de la funci\u00f3n ? (Si tuvieron que cambiar la respuesta #3, esa respuesta muy probablemente aplica aqu\u00ed) a. run b. s c. c d. n 5. \u00bfC\u00f3mo se reanuda la ejecuci\u00f3n del programa despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 6. \u00bfC\u00f3mo podemos ver el valor de una variable (o expresi\u00f3n) en gdb? a. display expr b. signal expr c. print expr d. next expr 7. \u00bfQu\u00e9 comando de gdb se usa para desplegar el valor de una variable despu\u00e9s de cada paso ? a. display expr b. signal expr c. print expr d. next expr 8. \u00bfC\u00f3mo se imprime una lista de todas las variables y su valor en la funci\u00f3n actual? a. display all b. display c. print all d. print 9. \u00bfC\u00f3mo salimos de gdb? a. end b. quit c. exit d. finish Despu\u00e9s de responder estas preguntas, no olviden hacer el commit y push de este archivo hacia Github: 1 2 3 $ git add ex2.txt $ git commit -m \"Ejercicio 2 terminado\" $ git push -u origin main Ejercicio 3: Depurando un problema con fallas usando GDB Ahora, usar\u00e1n su nuevo conocimiento para depurar un peque\u00f1o programa. Vean el programa ll_equal.c . Compilen y ejecuten el programa, y analicen un poco lo que hace. As\u00ed como est\u00e1, producir\u00e1 un resultado como el siguiente: 1 2 3 4 $ gcc -g -o ll_equal ll_equal.c $ ./ll_equal equal test 1 result = 1 Segmentation fault Averig\u00fcen qu\u00e9 produce el segmentation fault (falla de segmentaci\u00f3n) . Ejecuten gdb en el programa, siguiendo las instrucciones aprendidas en los ejercicios anteriores. Les recomendamos a\u00f1adir un breakpoint en la funci\u00f3n ll_equal() . Cuando el debugger pare en el breakpoint, ejecuten paso a paso el programa, para que puedan descifrar qu\u00e9 es lo que provoca el error. Pista: Analicen el valor de los punteros a y b en la funci\u00f3n (\u00a1despli\u00e9guenlos!). \u00bfEst\u00e1n siempre apuntando a la direcci\u00f3n correcta? Pista 2: Vean el c\u00f3digo fuente en main para ver la estructura de los nodos y ver exactamente qu\u00e9 est\u00e1 pasando como argumento a ll_equal . Despu\u00e9s de corregir el problema, compilen nuevamente y ejecuten el c\u00f3digo. \u00bfNotan la diferencia? Al finalizar, no olviden subir el archivo modificado a su repositorio remoto: 1 2 3 $ git add ll_equal.c $ git commit -m \"Ejercicio 2 terminado\" $ git push -u origin main Ejercicio 4: \"Debuggeando\" un programa en C que requiere interacci\u00f3n del usuario Veamos qu\u00e9 pasa cuando, a un programa que requiere interacci\u00f3n del usuario, lo ejecutamos con gdb. Primero, ejecuten el programa en interactive_hello.c para hablar con un programa muy amigable :). 1 2 $ gcc -g -o int_hello interactive_hello.c $ ./int_hello Ahora, traten de depurarlo (aunque no haya ning\u00fan problema realmente): 1 $ cgdb int_hello \u00bfQu\u00e9 pasa cuando intentar ejecutar el programa hasta el final? Vamos a aprender acerca de una herramienta que nos ayudar\u00e1 a evitar este problema. El prop\u00f3sito de este ejercicio es que no tengan miedo de usar un debugger incluso cuando el programa requiera de interacci\u00f3n con el usuario. Resulta que es posible enviar texto a stdin , el flujo de datos que es le\u00eddo por la funci\u00f3n fgets en este programa, con unos caracteres especiales desde la l\u00ednea de comandos. Echen un vistazo a la \"redirecci\u00f3n\" en esta p\u00e1gina , y vean si pueden descifrar c\u00f3mo enviar texto al programa sin escribirlo textualmente mientras el programa est\u00e1 en ejecuci\u00f3n (lo cual, como ya saben, no funciona bien en CGDB). Pueden ver esta discusi\u00f3n de stackoverflow para m\u00e1s inspiraci\u00f3n. (Pista 1: \u00a1Si est\u00e1n creando un archivo de texto que contiene su input, van bien!) (pista 2: Recuerden que es posible ejecutar programas con argumentos (incluyendo s\u00edmbolos de redirecci\u00f3n) desde CGDB! Esperamos que hayan comprendido c\u00f3mo utilizar redirecci\u00f3n y c\u00f3mo es que esto les ayuda a evitar varios problemas al usar CGDB. \u00a1Nunca tengan miedo de usar un debugger ! Tal vez no es muy agradable visualmente, pero siempre estar\u00e1 para ayudarlos. Este ejercicio no vale puntos :-) pero es importante conocer sobre estas cosas para que puedan utilizarlo en el futuro (los siguientes laboratorios y proyectos podr\u00edan necesitar de este conocimiento) Ejercicio 5: Punteros y estructuras en C En ll cycle.c, completen la funci\u00f3n ll_has_cycle(), de modo que implemente el siguiente algoritmo para comprobar si una _linked list simple tiene un ciclo: Comiencen con dos punteros apuntando al principio de la lista. Llamaremos al primero tortoise (tortuga) y al segundo hare (liebre). Avancen el puntero hare dos nodos hacia adelante. Si no se puede debido a punteros null , hemos llegado al final de la lista. Por lo tanto, la lista no tiene un ciclo. Ahora, avancen tortoise un nodo. (Revisar si llega a ser un puntero nulo es innecesario. \u00bfPor qu\u00e9?) Si la tortuga y la liebre apuntan al mismo nodo, la lista es c\u00edclica. Si no, regresen al paso 2. Despu\u00e9s de implementar correctamente la funci\u00f3n ll_has_cycle() , el programa que se obtiene despu\u00e9s de compilar ll_cycle.c mostrar\u00e1 si el resultado de su funci\u00f3n est\u00e1 correcto, conforme a lo que esperaba como salida. Pista: Hay dos formas comunes en que los estudiantes resuelven esta funci\u00f3n, y la diferencia principal est\u00e1 en la forma en que deciden codificar el criterio de c\u00f3mo finalizar. Si lo hacen de una forma, tendr\u00edan que tomar en cuenta un caso especial en el principio. Si lo hacen de otra forma, tendr\u00edan que tener unas pruebas extra de NULL, lo cual esta bien tambi\u00e9n. Les decimos esto para que no se preocupen de la \"limpieza\" de su c\u00f3digo, si no les ayuda, simplemente ignoren esta pista. El punto de este ejercicio es asegurarse de que entiendan como usar punteros. Aqu\u00ed hay un Art\u00edculo del algoritmo y por qu\u00e9 funciona. No se preocupen de entender completamente todo (no hay examen de esto). A prop\u00f3sito, los punteros se llaman tortoise y hare porque el puntero \"tortoise (tortuga)\" se incrementa lentamente (como una tortuga, que se mueve muy lento) y el puntero \"hare (liebre)\" se incrementa r\u00e1pidamente (m\u00e1s r\u00e1pido que una tortuga, como una liebre, o conejo, que se mueve muy r\u00e1pido). Al finalizar, compilen y ejecuten el archivo, y verifiquen que el resultado de su c\u00f3digo, el cual deber\u00eda ser m\u00e1s o menos igual a este: 1 2 3 4 5 6 7 8 $ gcc -g -o ll_cycle ll_cycle.c $ ./ll_cycle Checking first list for cycles. There should be none, ll_has_cycle says it has no cycle Checking second list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking third list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fourth list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fifth list for cycles. There should be none, ll_has_cycle says it has no cycle Checking length-zero list for cycles. There should be none, ll_has_cycle says it has no cycle Si su c\u00f3digo presenta errores, entonces ya son capaces de utilizar CGDB para poder encontrarlos y corregirlos. Finalmente, pueden subir el archivo a github: 1 2 3 $ git add ll_cycle.c $ git commit -m \"LAB01 terminado\" $ git push -u origin main Para finalizar, la f\u00e1bula de la tortuga y la liebre es relevante siempre, especialmente en este curso. Escribir sus programas en C a paso lento pero seguro (ayud\u00e1ndose de programas como CGDB) es lo que les har\u00e1 ganar la carrera. Entrega de laboratorio A partir de este laboratorio contaremos con autograders, por lo que podr\u00e1 conocer su nota de inmediato. Para poder utilizarlo debemos realizar una pequena instalaci\u00f3n (todos, incluyendo a quienes bajaron nuestra m\u00e1quina virtual, los autograders est\u00e1n reci\u00e9n salidos del horno). Para instalar necesitamos tener Python 3.6 o superior, nuestra m\u00e1quina virtual ya lo cumple. Comenzamos con... 1 pip3 install autograders-cli Esto instala el modulo a traves del cual entregar\u00e1 su asignaci\u00f3n. Luego tenemos que registrarnos. Por favor sea MUY CUIDADOSO al ingresar sus datos. Como es usual en Linux no se vera su contrasena mientras la escribe, de momento NO EXISTE RECUPERACION DE CONTRASENA por si se equivoca o se le olvida. SEA MUY CUIDADOSO . 1 autograder --register Tras llenar su nombre completo, correo y crear su contrase\u00f1a se le enviar\u00e1 un correo. Haga click en el link que va en el correo (es posible que al hacer click se quede \"trabado\" en redirecting/redirigiendo, esto es normal, no se preocupe). Luego de hacer click en ese link, esta listo para entregar. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json ; si aparecio, est\u00e1 en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aproximadamente y luego puede ver sus resultados con... 1 autograder --stats Vera desplegado sus resultados de esta manera (excepto que usted tendra 100 en lugar de 0 :P). Si dice Queued: True significa que el autograder esta un poquito ocupado y no le ha calificado, revise de nuevo en unos cinco minutos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ___ __ __ / _ | __ __/ /____ ___ ________ ____/ /__ _______ / __ / // / __/ _ \\/ _ ` / __/ _ ` / _ / -_ ) __ ( _- /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ /___/ Command Line Interface Autograders.org Get Task Stats - Queued: False - Grade: 0 .00/100 - Created At: 2021 -01-29T12:57:05.454Z - Updated At: 2021 -01-29T12:57:12.131Z Details: \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555 \u2502 Name \u2502 Grade \u2502 Message \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 1 . Eccentric \u2502 0 \u2502 incomplete: some answers are wrong... \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 2 . CGDB \u2502 0 \u2502 incomplete: q1,q2,q3,q4,q5,q6,q7,q8,q9 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 . ll_equal \u2502 0 \u2502 failed: runtime error \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 4 . ll_cycle \u2502 0 \u2502 failed: Failed some tests... \u2502 \u2558\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255b Felicidades! Termino su lab 1. Envie el link de su repo en el GES (el GES le permite enviar links, no pegue su link en un TXT u otro documento, es inc\u00f3modo).","title":"Lab 1 - Punteros en C y GDB"},{"location":"labs/lab01/#lab-1-punteros-en-c-y-gdb","text":"","title":"Lab 1 - Punteros en C y GDB"},{"location":"labs/lab01/#objetivos","text":"Aprender c\u00f3mo compilar y ejecutar un programa en C. Examinar diferentes tipos de control de flujo en C. Introducirlos al debugger (depurador) de C Conseguir experiencia pr\u00e1ctica utilizando GBD para depurar programas en C. Ganar m\u00e1s confianza al trabajar con punteros.","title":"Objetivos"},{"location":"labs/lab01/#preparacion","text":"Visiten este link . Aqu\u00ed encontrar\u00e1n todos los archivos necesarios para completar este lab. En esta p\u00e1gina, encontrar\u00e1n un bot\u00f3n que dice \"Accept assignment\". Al presionar este bot\u00f3n, se crear\u00e1 autom\u00e1ticamente un repositorio en Github llamado www.github.com/cc3-an/lab01-2021-USUARIO . Noten que el \"due\u00f1o\" de este repositorio es un usuario llamado cc3-an , y el usuario de ustedes es \u00fanicamente el sufijo del nombre del repo. De esta forma, nos encargamos de tener acceso siempre a su c\u00f3digo, en caso existan copias o cualquier otro tipo de trampa. Sepan de una vez que, si encontramos plagio o cualquier otro tipo de trampa en sus laboratorios, su nota ser\u00e1 AUTOM\u00c1TICAMENTE 0, sin posibilidad de cambiarla. De repetirse nuevamente este acontecimiento, el staff del curso organizar\u00e1 una reuni\u00f3n con ustedes y sus directores de carrera para contarles lo ocurrido y sancionarlos conforme al reglamento de la universidad. Despu\u00e9s de realizar esto, en la m\u00e1quina virtual (o sus propias computadoras) abran una terminal en el directorio que prefieran, y ejecuten el siguiente comando: 1 git clone https://github.com/cc3-an/lab1-2021-<SU USUARIO DE GITHUB> Esto descargar\u00e1 en el directorio que escogieron todos los archivos base para este laboratorio. Para futuro, un clone solo lo hacemos la primera vez que vamos a bajar el codigo de un repositorio a nuestra maquina. Nunca bajen el zip que Github les ofrece, por favor, eso solo nos va a causar problemas.","title":"Preparaci\u00f3n"},{"location":"labs/lab01/#compilando-y-ejecutando-un-programa-de-c","text":"En este laboratorio, estaremos usando el programa gcc para compilar programas en c. La manera m\u00e1s sencilla de ejecutar gcc es la siguiente: 1 gcc program.c Esto compila el archivo program.c y crea un archivo ejecutable llamado a.out . Si tienen experiencia en Java, pueden m\u00e1s o menos considerar a gcc como el equivalente en C de javac . Este archivo se puede ejecutar con el siguiente comando: 1 ./a.out El archivo ejecutable es a.out , as\u00ed que, \u00bfqu\u00e9 rayos es eso de punto y diagonal? La respuesta: cuando quieren ejecutar un ejecutable, es necesario preponer una ruta de archivo para distinguirlo de un comando como python (no se utiliza ./python ). El punto se refiere al \"directorio actual\". De paso, dos puntos (..) se referir\u00edan al directorio que est\u00e1 un nivel arriba. gcc tiene varias opciones (o argumentos) de l\u00ednea de comandos, los cuales les recomendamos explorar. En este laboratorio, vamos a estar usando solamente -o, que se usa para especificar el nombre del ejecutable que gcc genera. Usando -o, se utilizar\u00edan estos comandos para compilar program.c en un archivo llamado program , y ejecutarlo. Eso nos sirve si no queremos que todos nuestros archivos ejecutables se llamen a.out . 1 2 gcc -o program program.c ./program","title":"Compilando y ejecutando un programa de C"},{"location":"labs/lab01/#ejercicio-1-programa-simple-de-c","text":"En este ejercicio, veremos un ejemplo de definiciones macro de preprocesador. Las macros pueden ser un tema complicado, pero en general, la forma en que funcionan es que, antes de que un archivo en C es compilado, las constantes macro son reemplazadas exactamente por el valor al que se refieren. En este ejercicio, estaremos usando macros exclusivamente como constantes globales. Aqu\u00ed definimos CONSTANT_NAME como un literal_value (una literal entera). Noten que solo hay 1 espacio separando el nombre del valor. 1 #define CONSTANT_NAME LITERAL_VALUE Ahora, vean el c\u00f3digo en eccentric.c (en el repo). Noten los cuatro diferentes ejemplos de control b\u00e1sico de flujo. (\u00bfCu\u00e1les son?) Compilen y ejecuten el programa para ver lo que hace. Jueguen con las constantes de las cuatro macros: v0 a v3 . Vean c\u00f3mo cambiar cada uno de estos cambia el output del programa. Su tarea: Modificando s\u00f3lo estos cuatro valores, hagan que el programa produzca el siguiente mensaje: 1 2 3 4 5 6 7 8 $ gcc -o eccentric eccentric.c $ ./eccentric Berkeley eccentrics: ==================== Happy Happy Happy Yoshua Go BEARS! Hay m\u00faltiples combinaciones de valores en las macros que consiguen este resultado, El reto para ustedes en este ejercicio es: Consideren el m\u00ednimo n\u00famero de distintos valores que las constantes v0 a v3 puedan tener que a\u00fan den el mismo resultado correcto. Como ejemplo, el m\u00e1ximo te\u00f3rico es cuatro (cuando todos son diferentes uno de otro). Cuando ya hayan logrado esto, pueden actualizar el archivo en su repositorio en Github, de esta manera: 1 2 3 $ git add eccentric.c $ git commit -m \"Ejercicio 1 terminado\" $ git push -u origin main","title":"Ejercicio 1: Programa simple de C"},{"location":"labs/lab01/#ejercicio-2-debugger-depurador","text":"","title":"Ejercicio 2: Debugger (depurador)"},{"location":"labs/lab01/#que-es-un-debugger","text":"Este p\u00e1rrafo es para los estudiantes que no est\u00e1n familiarizados con los debuggers . Un debugger , como sugiere el nombre, es un programa espec\u00edficamente dise\u00f1ado para ayudarlos a encontrar bugs , o errores l\u00f3gicos, u otros errores en el c\u00f3digo (nota: si quieren saber por qu\u00e9 se les llama bugs a los errores, vean aqu\u00ed ). Distintos debuggers tienen distintas caracter\u00edsticas, pero es normal que todos los debuggers sean capaces de hacer las siguientes cosas: Poner un breakpoint en el programa. Un Breakpoint es una l\u00ednea espec\u00edfica en su c\u00f3digo en donde quisieran que se detenga la ejecuci\u00f3n del programa, para que puedan ver lo que est\u00e1 pasando alrededor. Ejecuci\u00f3n por Steps (l\u00ednea a l\u00ednea) por el programa. El c\u00f3digo siempre se ejecuta l\u00ednea a l\u00ednea, pero pasa muy r\u00e1pido como para que sepamos qu\u00e9 l\u00ednea produce alg\u00fan error. Ser capaces de ejecutar l\u00ednea a l\u00ednea el programa les permite observar exactamente qu\u00e9 esta causando un bug en el programa. Para este ejercicio, necesitar\u00e1n la GDB reference card . GDB quiere decir \"GNU De-Bugger\". Compilen hello.c con la bandera \"-g\": 1 gcc -g -o hello hello.c Esto har\u00e1 que gcc guarde informaci\u00f3n en el archivo ejecutable para que gdb lo interprete. Ahora ejecuten el debugger, (c)gdb: 1 cgdb hello Vean lo que hace este comando. Est\u00e1n ejecutando el programa cgdb en el ejecutable hello generado por gcc . No intenten ejecutar cgdb en el archivo fuente en hello.c ! Eso no va a funcionar. Si cgdb no funciona, gdb se puede usar para completar los ejercicios (utilicen gdb hello ). Su tarea: ejecuten el programa varias veces haciendo esto: Poniendo un breakpoint en el main. Usando el comando run de gdb. Utilizando el comando single-step de gdb. Escriban help adentro de gdb para averiguar c\u00f3mo hacer estas cosas, o usen la reference card. Si encuentran un mensaje de error que dice: printf.c: No such file or directory . Probablemente entraron a una funci\u00f3n printf . Si siguen ejecutando paso a paso, pareciera que nunca avanzaran en el c\u00f3digo. CGDB est\u00e1 dando el error porque no tienen el archivo en el que se define la funci\u00f3n printf . Esto es algo molesto, y para librarse de esto, usen el comando finish para ejecutar el programa hasta que termine la funci\u00f3n printf. Y la pr\u00f3xima vez , utilicen el comando next para saltar sobre la linea que usa printf . Nota: CGDB vs GDB . En este ejercicio, usamos cgdb para depurar nuestros programas. cgdb es id\u00e9ntico a gdb, excepto que tiene unas caracter\u00edsticas extra que hacen m\u00e1s c\u00f3modo el trabajo. Todos los comandos de la hoja de referencia funcionan tambi\u00e9n en gdb. En cgdb, pueden presionar ESC para ir a la ventana del c\u00f3digo (arriba), y usar i para regresar a la ventana de comandos (abajo), similar a vim . La ventana de comandos es donde se introducen los comandos de gdb. Para este ejercicio, encontrar\u00e1n un archivo de texto llamado ex2.txt, con el siguiente formato: 1 2 3 4 5 6 7 8 9 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : Aqu\u00ed tendr\u00e1n que responder las siguientes preguntas de opci\u00f3n m\u00faltiple (no tengan miedo de probar las opciones en CGDB antes de responder, \u00a1lo recomendamos!) con el siguiente formato (tienen que cambiar la letra en el ejemplo por la letra de la respuesta que ustedes consideren correcta): 1 2 3 4 5 6 7 8 9 1 :e 2 :f 3 :g 4 :h 5 :i 6 :j 7 :k 8 :l 9 :m Preguntas 1. \u00bfC\u00f3mo se le dan argumentos desde la l\u00ednea de comandos a un programa al utilizar gdb? a. args arglist b. run arglist c. gdb args d. Ninguna de las anteriores 2. \u00bfC\u00f3mo se a\u00f1ade un breakpoint que s\u00f3lo ocurre cuando se cumplen ciertas condiciones (por ejemplo, ciertas variables alcanzan cierto valor)? a. expr cond b. cond break expr c. break ... if expr d. Ninguna de las anteriores 3. \u00bfCon qu\u00e9 comando se ejecuta la siguiente l\u00ednea del c\u00f3digo en C despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 4. Si la siguiente l\u00ednea de c\u00f3digo es una llamada a funci\u00f3n, \u00bfse ejecutar\u00eda toda la funci\u00f3n si se utiliza el comando de la pregunta #3? (si no, es momento de cambiarla!). \u00bfC\u00f3mo se le indica a gdb, que quieren debuggear el c\u00f3digo adentro de la funci\u00f3n ? (Si tuvieron que cambiar la respuesta #3, esa respuesta muy probablemente aplica aqu\u00ed) a. run b. s c. c d. n 5. \u00bfC\u00f3mo se reanuda la ejecuci\u00f3n del programa despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 6. \u00bfC\u00f3mo podemos ver el valor de una variable (o expresi\u00f3n) en gdb? a. display expr b. signal expr c. print expr d. next expr 7. \u00bfQu\u00e9 comando de gdb se usa para desplegar el valor de una variable despu\u00e9s de cada paso ? a. display expr b. signal expr c. print expr d. next expr 8. \u00bfC\u00f3mo se imprime una lista de todas las variables y su valor en la funci\u00f3n actual? a. display all b. display c. print all d. print 9. \u00bfC\u00f3mo salimos de gdb? a. end b. quit c. exit d. finish Despu\u00e9s de responder estas preguntas, no olviden hacer el commit y push de este archivo hacia Github: 1 2 3 $ git add ex2.txt $ git commit -m \"Ejercicio 2 terminado\" $ git push -u origin main","title":"\u00bfQu\u00e9 es un debugger?"},{"location":"labs/lab01/#ejercicio-3-depurando-un-problema-con-fallas-usando-gdb","text":"Ahora, usar\u00e1n su nuevo conocimiento para depurar un peque\u00f1o programa. Vean el programa ll_equal.c . Compilen y ejecuten el programa, y analicen un poco lo que hace. As\u00ed como est\u00e1, producir\u00e1 un resultado como el siguiente: 1 2 3 4 $ gcc -g -o ll_equal ll_equal.c $ ./ll_equal equal test 1 result = 1 Segmentation fault Averig\u00fcen qu\u00e9 produce el segmentation fault (falla de segmentaci\u00f3n) . Ejecuten gdb en el programa, siguiendo las instrucciones aprendidas en los ejercicios anteriores. Les recomendamos a\u00f1adir un breakpoint en la funci\u00f3n ll_equal() . Cuando el debugger pare en el breakpoint, ejecuten paso a paso el programa, para que puedan descifrar qu\u00e9 es lo que provoca el error. Pista: Analicen el valor de los punteros a y b en la funci\u00f3n (\u00a1despli\u00e9guenlos!). \u00bfEst\u00e1n siempre apuntando a la direcci\u00f3n correcta? Pista 2: Vean el c\u00f3digo fuente en main para ver la estructura de los nodos y ver exactamente qu\u00e9 est\u00e1 pasando como argumento a ll_equal . Despu\u00e9s de corregir el problema, compilen nuevamente y ejecuten el c\u00f3digo. \u00bfNotan la diferencia? Al finalizar, no olviden subir el archivo modificado a su repositorio remoto: 1 2 3 $ git add ll_equal.c $ git commit -m \"Ejercicio 2 terminado\" $ git push -u origin main","title":"Ejercicio 3: Depurando un problema con fallas usando GDB"},{"location":"labs/lab01/#ejercicio-4-debuggeando-un-programa-en-c-que-requiere-interaccion-del-usuario","text":"Veamos qu\u00e9 pasa cuando, a un programa que requiere interacci\u00f3n del usuario, lo ejecutamos con gdb. Primero, ejecuten el programa en interactive_hello.c para hablar con un programa muy amigable :). 1 2 $ gcc -g -o int_hello interactive_hello.c $ ./int_hello Ahora, traten de depurarlo (aunque no haya ning\u00fan problema realmente): 1 $ cgdb int_hello \u00bfQu\u00e9 pasa cuando intentar ejecutar el programa hasta el final? Vamos a aprender acerca de una herramienta que nos ayudar\u00e1 a evitar este problema. El prop\u00f3sito de este ejercicio es que no tengan miedo de usar un debugger incluso cuando el programa requiera de interacci\u00f3n con el usuario. Resulta que es posible enviar texto a stdin , el flujo de datos que es le\u00eddo por la funci\u00f3n fgets en este programa, con unos caracteres especiales desde la l\u00ednea de comandos. Echen un vistazo a la \"redirecci\u00f3n\" en esta p\u00e1gina , y vean si pueden descifrar c\u00f3mo enviar texto al programa sin escribirlo textualmente mientras el programa est\u00e1 en ejecuci\u00f3n (lo cual, como ya saben, no funciona bien en CGDB). Pueden ver esta discusi\u00f3n de stackoverflow para m\u00e1s inspiraci\u00f3n. (Pista 1: \u00a1Si est\u00e1n creando un archivo de texto que contiene su input, van bien!) (pista 2: Recuerden que es posible ejecutar programas con argumentos (incluyendo s\u00edmbolos de redirecci\u00f3n) desde CGDB! Esperamos que hayan comprendido c\u00f3mo utilizar redirecci\u00f3n y c\u00f3mo es que esto les ayuda a evitar varios problemas al usar CGDB. \u00a1Nunca tengan miedo de usar un debugger ! Tal vez no es muy agradable visualmente, pero siempre estar\u00e1 para ayudarlos. Este ejercicio no vale puntos :-) pero es importante conocer sobre estas cosas para que puedan utilizarlo en el futuro (los siguientes laboratorios y proyectos podr\u00edan necesitar de este conocimiento)","title":"Ejercicio 4: \"Debuggeando\" un programa en C que requiere interacci\u00f3n del usuario"},{"location":"labs/lab01/#ejercicio-5-punteros-y-estructuras-en-c","text":"En ll cycle.c, completen la funci\u00f3n ll_has_cycle(), de modo que implemente el siguiente algoritmo para comprobar si una _linked list simple tiene un ciclo: Comiencen con dos punteros apuntando al principio de la lista. Llamaremos al primero tortoise (tortuga) y al segundo hare (liebre). Avancen el puntero hare dos nodos hacia adelante. Si no se puede debido a punteros null , hemos llegado al final de la lista. Por lo tanto, la lista no tiene un ciclo. Ahora, avancen tortoise un nodo. (Revisar si llega a ser un puntero nulo es innecesario. \u00bfPor qu\u00e9?) Si la tortuga y la liebre apuntan al mismo nodo, la lista es c\u00edclica. Si no, regresen al paso 2. Despu\u00e9s de implementar correctamente la funci\u00f3n ll_has_cycle() , el programa que se obtiene despu\u00e9s de compilar ll_cycle.c mostrar\u00e1 si el resultado de su funci\u00f3n est\u00e1 correcto, conforme a lo que esperaba como salida. Pista: Hay dos formas comunes en que los estudiantes resuelven esta funci\u00f3n, y la diferencia principal est\u00e1 en la forma en que deciden codificar el criterio de c\u00f3mo finalizar. Si lo hacen de una forma, tendr\u00edan que tomar en cuenta un caso especial en el principio. Si lo hacen de otra forma, tendr\u00edan que tener unas pruebas extra de NULL, lo cual esta bien tambi\u00e9n. Les decimos esto para que no se preocupen de la \"limpieza\" de su c\u00f3digo, si no les ayuda, simplemente ignoren esta pista. El punto de este ejercicio es asegurarse de que entiendan como usar punteros. Aqu\u00ed hay un Art\u00edculo del algoritmo y por qu\u00e9 funciona. No se preocupen de entender completamente todo (no hay examen de esto). A prop\u00f3sito, los punteros se llaman tortoise y hare porque el puntero \"tortoise (tortuga)\" se incrementa lentamente (como una tortuga, que se mueve muy lento) y el puntero \"hare (liebre)\" se incrementa r\u00e1pidamente (m\u00e1s r\u00e1pido que una tortuga, como una liebre, o conejo, que se mueve muy r\u00e1pido). Al finalizar, compilen y ejecuten el archivo, y verifiquen que el resultado de su c\u00f3digo, el cual deber\u00eda ser m\u00e1s o menos igual a este: 1 2 3 4 5 6 7 8 $ gcc -g -o ll_cycle ll_cycle.c $ ./ll_cycle Checking first list for cycles. There should be none, ll_has_cycle says it has no cycle Checking second list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking third list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fourth list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fifth list for cycles. There should be none, ll_has_cycle says it has no cycle Checking length-zero list for cycles. There should be none, ll_has_cycle says it has no cycle Si su c\u00f3digo presenta errores, entonces ya son capaces de utilizar CGDB para poder encontrarlos y corregirlos. Finalmente, pueden subir el archivo a github: 1 2 3 $ git add ll_cycle.c $ git commit -m \"LAB01 terminado\" $ git push -u origin main Para finalizar, la f\u00e1bula de la tortuga y la liebre es relevante siempre, especialmente en este curso. Escribir sus programas en C a paso lento pero seguro (ayud\u00e1ndose de programas como CGDB) es lo que les har\u00e1 ganar la carrera.","title":"Ejercicio 5: Punteros y estructuras en C"},{"location":"labs/lab01/#entrega-de-laboratorio","text":"A partir de este laboratorio contaremos con autograders, por lo que podr\u00e1 conocer su nota de inmediato. Para poder utilizarlo debemos realizar una pequena instalaci\u00f3n (todos, incluyendo a quienes bajaron nuestra m\u00e1quina virtual, los autograders est\u00e1n reci\u00e9n salidos del horno). Para instalar necesitamos tener Python 3.6 o superior, nuestra m\u00e1quina virtual ya lo cumple. Comenzamos con... 1 pip3 install autograders-cli Esto instala el modulo a traves del cual entregar\u00e1 su asignaci\u00f3n. Luego tenemos que registrarnos. Por favor sea MUY CUIDADOSO al ingresar sus datos. Como es usual en Linux no se vera su contrasena mientras la escribe, de momento NO EXISTE RECUPERACION DE CONTRASENA por si se equivoca o se le olvida. SEA MUY CUIDADOSO . 1 autograder --register Tras llenar su nombre completo, correo y crear su contrase\u00f1a se le enviar\u00e1 un correo. Haga click en el link que va en el correo (es posible que al hacer click se quede \"trabado\" en redirecting/redirigiendo, esto es normal, no se preocupe). Luego de hacer click en ese link, esta listo para entregar. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json ; si aparecio, est\u00e1 en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aproximadamente y luego puede ver sus resultados con... 1 autograder --stats Vera desplegado sus resultados de esta manera (excepto que usted tendra 100 en lugar de 0 :P). Si dice Queued: True significa que el autograder esta un poquito ocupado y no le ha calificado, revise de nuevo en unos cinco minutos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ___ __ __ / _ | __ __/ /____ ___ ________ ____/ /__ _______ / __ / // / __/ _ \\/ _ ` / __/ _ ` / _ / -_ ) __ ( _- /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ /___/ Command Line Interface Autograders.org Get Task Stats - Queued: False - Grade: 0 .00/100 - Created At: 2021 -01-29T12:57:05.454Z - Updated At: 2021 -01-29T12:57:12.131Z Details: \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555 \u2502 Name \u2502 Grade \u2502 Message \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 1 . Eccentric \u2502 0 \u2502 incomplete: some answers are wrong... \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 2 . CGDB \u2502 0 \u2502 incomplete: q1,q2,q3,q4,q5,q6,q7,q8,q9 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 . ll_equal \u2502 0 \u2502 failed: runtime error \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 4 . ll_cycle \u2502 0 \u2502 failed: Failed some tests... \u2502 \u2558\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255b Felicidades! Termino su lab 1. Envie el link de su repo en el GES (el GES le permite enviar links, no pegue su link en un TXT u otro documento, es inc\u00f3modo).","title":"Entrega de laboratorio"},{"location":"labs/lab02/","text":"Lab 2 - C Avanzado y Manejo de Memoria Objetivos Manipular los bits de n\u00fameros binarios. Aprendan a utilizar sus nuevos poderes. Practicar trabajar con la asignaci\u00f3n de memoria de manera din\u00e1mica (esa cosa de malloc ). Aprovechar toda la memoria no utilizada. Pensar c\u00f3mo el manejo de memoria din\u00e1mica los puede hacer mejores personas. Son bromas, pero s\u00f3lo los puede volver mejores programadores. Preparaci\u00f3n De primero, deben de descargar todos los archivos que necesitar\u00e1n para completar este laboratorio, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario. Recuerden que este ser\u00e1 revisado en b\u00fasqueda de copia o plagio, as\u00ed que no lo hagan. De lo contrario, ser\u00e1 sancionado acorde al reglamento de la universidad. Ahora, ya pueden ejecutar en la terminal el comando que les descargar\u00e1 los archivos base en el directorio a su elecci\u00f3n: 1 git clone link_al_lab Ejercicio 1: Operando Bits Para este inciso, su trabajo es completar los archivos ex1/get_bit.c , ex1/set_bit.c y ex1/flip_bit.c de manera que las funciones cumplan con su tarea (as\u00ed como el nombre de las funciones sugiere). Para ello deber\u00e1n utilizar las operaciones de bits b\u00e1sicas: and (&), or (|), xor (^), not (~) y los corrimientos a la derecha (>>) y a la izquierda (<<). Deben evitar el uso de ciclos o condicionales. \u00a1\u00a1\u00a1\u00a1No usen ciclos ni condicionales!!!! Eso significa que mientras realicen el ejercicio no pueden y no deben de escribir las palabras: if, else, do, while, for, switch o algo de \u00edndole similar. Por favor no traten de enga\u00f1arnos, todo el personal involucrado (esperamos) sabe c\u00f3mo se miran todas estas palabras, entonces si encontramos una de ellas... El autograder analiza su c\u00f3digo de todas formas... \u00af\\_(\u30c4)_/\u00af sorry not sorry NOTA IMPORTANTE: Considerar que n es un valor que inicia en la posici\u00f3n cero, contando desde la derecha, por lo que el bit que se encuentra hasta la derecha es el bit cero. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Return the nth bit of x. // Assume 0 <= n <= 31 unsigned get_bit ( unsigned x , unsigned n ); // Set the nth bit of the value of x to v. // Assume 0 <= n <= 31, and v is 0 or 1 void set_bit ( unsigned * x , unsigned n , unsigned v ); // Flip the nth bit of the value of x. // Assume 0 <= n <= 31 void flip_bit ( unsigned * x , unsigned n ); Ayuda para set_bit : La parte complicada es no saber el valor del bit antes de cambiarlo. Pero, sabemos que 0 | x = x , pero \u00bfpodemos aprovecharnos de esto? \u00bfEs posible volverlo cero? Una vez terminen de editar las funciones, pueden compilar y correr el c\u00f3digo con: 1 2 make bit_ops ./bit_ops Lo cual imprimir\u00e1 el resultado de algunas pruebas. Si tienen curiosidad pueden revisar con libertad la carpeta tests/ que contiene las pruebas que se van a realizar en cada ejercicio de este laboratorio y que reflejan bastante lo que evaluar\u00e1 el autograder, por ejemplo el archivo que se utiliza para este ejercicio es tests/bit_ops_test.c . De ahora en adelante hasta que esten 100% seguros de que tienen completo el laboratorio o ya est\u00e9 cerca la hora de entregar su laboratorio, pueden mandar sus archivos como en los laboratorios pasados utilizando ./submit <TOKEN> . Acu\u00e9rdense de realizar el proceso de \"hacerle push\" al archivo para subirlo al repositorio de GitHub. Ejercicio 2: Registro de Corrimiento con Retroalimentaci\u00f3n Lineal En este ejercicio deben de implementar una funci\u00f3n que compute la siguiente iteraci\u00f3n de un registro de corrimiento de retroalimentaci\u00f3n lineal (LFSR por sus siglas en ingl\u00e9s). \u00a1Algunas aplicaciones que utilizan LFSRs son: televisi\u00f3n digital, tel\u00e9fonos con acceso m\u00faltiple por divisi\u00f3n de c\u00f3digo, Ethernet, USB 3.0 y mucho m\u00e1s! Esta funci\u00f3n deber\u00e1 generar n\u00fameros pseudo-aleatorios utilizando operadores binarios. Para un poco de informaci\u00f3n adicional, pueden visitar el siguiente link de Wikipedia . En el archivo ex2/lfsr_calculate.c deben de completar la funci\u00f3n lfsr_calculate() de manera que realice lo siguiente: Diagrama del Hardware (Explicaci\u00f3n M\u00e1s Abajo) Explicaci\u00f3n del Diagrama de Arriba En cada llamada de lfsr_calculate() , deben de correr el contenido del registro un bit hacia la derecha. Este corrimiento no es ni l\u00f3gico, ni aritm\u00e9tico. En el lado izquierdo deben de colocar un bit equivalente a un XOR de los bits que estaban, originalmente, en las posiciones 1, 3, 4 y 6. El objeto que parece un faro de autom\u00f3vil curvado es un XOR, el cual recibe dos entradas (a, b) y devuelve en su salida a^b. A diferencia del ejercicio 1, las posiciones de los bits inician con 1 . Despu\u00e9s que hayan implementado de manera correcta lfsr_calculate() , compilen y c\u00f3rranlo. Su respuesta debe ser similar a lo siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 make lfsr ./lfsr My number is: 1 My number is: 5185 My number is: 38801 My number is: 52819 My number is: 21116 My number is: 54726 My number is: 26552 My number is: 46916 My number is: 41728 My number is: 26004 My number is: 62850 My number is: 40625 My number is: 647 My number is: 12837 My number is: 7043 My number is: 26003 My number is: 35845 My number is: 61398 My number is: 42863 My number is: 57133 My number is: 59156 My number is: 13312 My number is: 16285 ... etc etc ... Got 65535 numbers before cycling! Congratulations! It works! De nuevo, recu\u00e9rdense de hacer el push. Ejercicio 3: Manejo de Memoria Este ejercicio requiere de los archivos: tests/include/vector.h , tests/vector_test.c y ex3/vector.c , en donde les proveemos con la base para la implementaci\u00f3n de un arreglo de longitud variable. Este inciso busca que se familiaricen con el uso de los \"structs\" de C, as\u00ed como el manejo de memoria en este lenguaje. En otras palabras, no se preocupen por los detalles pr\u00e1cticos de esta estructura de datos un tanto extra\u00f1a. S\u00f3lo no lo hagan. Su trabajo es completar las funciones vector_new() , vector_get() , vector_delete() y vector_set() en ex3/vector.c de manera que tests/vector-test.c corra sin errores de manejo de memoria. \u00bfC\u00f3mo funciona un vector_t ? Posee un int size que indica cu\u00e1ntos elementos posee actualmente. En otras palabras, el size es igual al \u00edndice de la \u00faltima posici\u00f3n que ha sido alterada del vector. Por ejemplo, si se tiene un vector con un size de 5 y se altera su ducent\u00e9cimo bit (\u00edndice iniciando en cero), su tama\u00f1o se ver\u00e1 actualizado a 201. La longitud por defecto del vector vector_new es de 1. Tiene un int *data , un arreglo din\u00e1mico de enteros que contiene los valores de los componentes del vector. Si se altera el ducent\u00e9cimo elemento de un vector v a 8 entonces el elemento modificado (de nuevo, iniciando en cero) de v->data deber\u00eda evaluar a 8. El valor de un vector vector_new es 0 por defecto. El valor de cualquier componente de alg\u00fan vector que no ha sido expl\u00edcitamente editado es 0. Si se deseara conocer el valor en la quinta posici\u00f3n de un vector, pero s\u00f3lo se ha alterado el valor de los primeras dos, la interrogante tendr\u00eda como respuesta 0. Adem\u00e1s, si se quisiera el contenido en la s\u00e9ptima posici\u00f3n de un vector de longitud igual a 5, tambi\u00e9n ser\u00eda 0. NO devolver\u00eda un error. Es momento de revisar el c\u00f3digo de ex3/vector.c si no lo han hecho. Aqu\u00ed hay comentarios complementarios que describen c\u00f3mo deber\u00edan de correr las funciones. Recuerden que los usuarios de su estructura de datos vector_t deben asumir que todas las entradas al vector son 0, a menos que hayan sido definidas de otra manera por ellos. Tengan esto en mente, porque malloc no hace esto por ustedes. \u00bfQu\u00e9 deben hacer? Completen vector_new , la versi\u00f3n correcta. Hay exactamente seis (6) espacios para que escriban una expresi\u00f3n en C, indicados con el comentario que dice /* YOUR CODE HERE */ . Escriban una expresi\u00f3n en estos sitios. Esto significa no m\u00e1s de una l\u00ednea de c\u00f3digo. Existen comentarios adicionales que describen qu\u00e9 deber\u00eda de suceder en la l\u00ednea de c\u00f3digo inferior a cada divisi\u00f3n. Terminen vector_get() de la misma manera en que lo hicieron para la funci\u00f3n anterior: de manera respetuosa, dispuesto a aprender, con mente abierta y conscientes de qu\u00e9 es lo que est\u00e1n escribiendo, ya que esta es la mejor forma de programar. Complementen vector_delete() . Una soluci\u00f3n satisfactoria no deber\u00eda de llevar m\u00e1s de dos l\u00edneas de c\u00f3digo. Corrijan a vector_set() . Esta es la m\u00e1s complicada. Bienvenidos a las ligas mayores. El problema de manipular una posici\u00f3n/\u00edndice arbitrario en un vector v es que es posible que no se haya reservado suficiente espacio con malloc en vector->data (s\u00ed, eso significa que tuvieron que haber guardado memoria con malloc ). Piensen c\u00f3mo administrar la memoria para lograr esto, para ver qu\u00e9 hacer con la data que estaba ah\u00ed antes y de qu\u00e9 otras cosas deben de hacer en su nuevo bloque de datos. Ayuda: Recuerden que los \u00edndices que no hayan sido alterados deben de ser cero. Hay distintas formas de acabar resolviendo esta funci\u00f3n. Consideren el uso de las 3 funciones __alloc , porque pueden resultar \u00fatiles... Saber c\u00f3mo reorganizar y liberar memoria es importante para la programaci\u00f3n en C. Piensen que el manejo de memoria es como un parqueo, si hay carros parqueados y los due\u00f1os nunca se van, entonces no tienen espacio para nuevos carros. Y recuerden que deber\u00edan tener un 'heap' vac\u00edo al terminar su programa. Utilicen free y todo estar\u00e1 bien. Calificaci\u00f3n Por favor actualizar siempre la versi\u00f3n del CLI de autograders: 1 pip3 install --upgrade autograders-cli Como en todos los dem\u00e1s laboratorios, hay un autograder y este no es la excepci\u00f3n. El staff trabajo bastante para que su experiencia en este curso sea de las mejores. Entregaremos este lab de la misma manera que el pasado. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aprox. y luego puede ver sus resultados con... 1 autograder --stats Si le aparece Queued: True, espere un par de minutos y luego repita el autograder --stats \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.","title":"Lab 2 - C Avanzado y Manejo de Memoria"},{"location":"labs/lab02/#lab-2-c-avanzado-y-manejo-de-memoria","text":"","title":"Lab 2 - C Avanzado y Manejo de Memoria"},{"location":"labs/lab02/#objetivos","text":"Manipular los bits de n\u00fameros binarios. Aprendan a utilizar sus nuevos poderes. Practicar trabajar con la asignaci\u00f3n de memoria de manera din\u00e1mica (esa cosa de malloc ). Aprovechar toda la memoria no utilizada. Pensar c\u00f3mo el manejo de memoria din\u00e1mica los puede hacer mejores personas. Son bromas, pero s\u00f3lo los puede volver mejores programadores.","title":"Objetivos"},{"location":"labs/lab02/#preparacion","text":"De primero, deben de descargar todos los archivos que necesitar\u00e1n para completar este laboratorio, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario. Recuerden que este ser\u00e1 revisado en b\u00fasqueda de copia o plagio, as\u00ed que no lo hagan. De lo contrario, ser\u00e1 sancionado acorde al reglamento de la universidad. Ahora, ya pueden ejecutar en la terminal el comando que les descargar\u00e1 los archivos base en el directorio a su elecci\u00f3n: 1 git clone link_al_lab","title":"Preparaci\u00f3n"},{"location":"labs/lab02/#ejercicio-1-operando-bits","text":"Para este inciso, su trabajo es completar los archivos ex1/get_bit.c , ex1/set_bit.c y ex1/flip_bit.c de manera que las funciones cumplan con su tarea (as\u00ed como el nombre de las funciones sugiere). Para ello deber\u00e1n utilizar las operaciones de bits b\u00e1sicas: and (&), or (|), xor (^), not (~) y los corrimientos a la derecha (>>) y a la izquierda (<<). Deben evitar el uso de ciclos o condicionales. \u00a1\u00a1\u00a1\u00a1No usen ciclos ni condicionales!!!! Eso significa que mientras realicen el ejercicio no pueden y no deben de escribir las palabras: if, else, do, while, for, switch o algo de \u00edndole similar. Por favor no traten de enga\u00f1arnos, todo el personal involucrado (esperamos) sabe c\u00f3mo se miran todas estas palabras, entonces si encontramos una de ellas... El autograder analiza su c\u00f3digo de todas formas... \u00af\\_(\u30c4)_/\u00af sorry not sorry NOTA IMPORTANTE: Considerar que n es un valor que inicia en la posici\u00f3n cero, contando desde la derecha, por lo que el bit que se encuentra hasta la derecha es el bit cero. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Return the nth bit of x. // Assume 0 <= n <= 31 unsigned get_bit ( unsigned x , unsigned n ); // Set the nth bit of the value of x to v. // Assume 0 <= n <= 31, and v is 0 or 1 void set_bit ( unsigned * x , unsigned n , unsigned v ); // Flip the nth bit of the value of x. // Assume 0 <= n <= 31 void flip_bit ( unsigned * x , unsigned n ); Ayuda para set_bit : La parte complicada es no saber el valor del bit antes de cambiarlo. Pero, sabemos que 0 | x = x , pero \u00bfpodemos aprovecharnos de esto? \u00bfEs posible volverlo cero? Una vez terminen de editar las funciones, pueden compilar y correr el c\u00f3digo con: 1 2 make bit_ops ./bit_ops Lo cual imprimir\u00e1 el resultado de algunas pruebas. Si tienen curiosidad pueden revisar con libertad la carpeta tests/ que contiene las pruebas que se van a realizar en cada ejercicio de este laboratorio y que reflejan bastante lo que evaluar\u00e1 el autograder, por ejemplo el archivo que se utiliza para este ejercicio es tests/bit_ops_test.c . De ahora en adelante hasta que esten 100% seguros de que tienen completo el laboratorio o ya est\u00e9 cerca la hora de entregar su laboratorio, pueden mandar sus archivos como en los laboratorios pasados utilizando ./submit <TOKEN> . Acu\u00e9rdense de realizar el proceso de \"hacerle push\" al archivo para subirlo al repositorio de GitHub.","title":"Ejercicio 1: Operando Bits"},{"location":"labs/lab02/#ejercicio-2-registro-de-corrimiento-con-retroalimentacion-lineal","text":"En este ejercicio deben de implementar una funci\u00f3n que compute la siguiente iteraci\u00f3n de un registro de corrimiento de retroalimentaci\u00f3n lineal (LFSR por sus siglas en ingl\u00e9s). \u00a1Algunas aplicaciones que utilizan LFSRs son: televisi\u00f3n digital, tel\u00e9fonos con acceso m\u00faltiple por divisi\u00f3n de c\u00f3digo, Ethernet, USB 3.0 y mucho m\u00e1s! Esta funci\u00f3n deber\u00e1 generar n\u00fameros pseudo-aleatorios utilizando operadores binarios. Para un poco de informaci\u00f3n adicional, pueden visitar el siguiente link de Wikipedia . En el archivo ex2/lfsr_calculate.c deben de completar la funci\u00f3n lfsr_calculate() de manera que realice lo siguiente:","title":"Ejercicio 2: Registro de Corrimiento con Retroalimentaci\u00f3n Lineal"},{"location":"labs/lab02/#diagrama-del-hardware-explicacion-mas-abajo","text":"","title":"Diagrama del Hardware (Explicaci\u00f3n M\u00e1s Abajo)"},{"location":"labs/lab02/#explicacion-del-diagrama-de-arriba","text":"En cada llamada de lfsr_calculate() , deben de correr el contenido del registro un bit hacia la derecha. Este corrimiento no es ni l\u00f3gico, ni aritm\u00e9tico. En el lado izquierdo deben de colocar un bit equivalente a un XOR de los bits que estaban, originalmente, en las posiciones 1, 3, 4 y 6. El objeto que parece un faro de autom\u00f3vil curvado es un XOR, el cual recibe dos entradas (a, b) y devuelve en su salida a^b. A diferencia del ejercicio 1, las posiciones de los bits inician con 1 . Despu\u00e9s que hayan implementado de manera correcta lfsr_calculate() , compilen y c\u00f3rranlo. Su respuesta debe ser similar a lo siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 make lfsr ./lfsr My number is: 1 My number is: 5185 My number is: 38801 My number is: 52819 My number is: 21116 My number is: 54726 My number is: 26552 My number is: 46916 My number is: 41728 My number is: 26004 My number is: 62850 My number is: 40625 My number is: 647 My number is: 12837 My number is: 7043 My number is: 26003 My number is: 35845 My number is: 61398 My number is: 42863 My number is: 57133 My number is: 59156 My number is: 13312 My number is: 16285 ... etc etc ... Got 65535 numbers before cycling! Congratulations! It works! De nuevo, recu\u00e9rdense de hacer el push.","title":"Explicaci\u00f3n del Diagrama de Arriba"},{"location":"labs/lab02/#ejercicio-3-manejo-de-memoria","text":"Este ejercicio requiere de los archivos: tests/include/vector.h , tests/vector_test.c y ex3/vector.c , en donde les proveemos con la base para la implementaci\u00f3n de un arreglo de longitud variable. Este inciso busca que se familiaricen con el uso de los \"structs\" de C, as\u00ed como el manejo de memoria en este lenguaje. En otras palabras, no se preocupen por los detalles pr\u00e1cticos de esta estructura de datos un tanto extra\u00f1a. S\u00f3lo no lo hagan. Su trabajo es completar las funciones vector_new() , vector_get() , vector_delete() y vector_set() en ex3/vector.c de manera que tests/vector-test.c corra sin errores de manejo de memoria.","title":"Ejercicio 3: Manejo de Memoria"},{"location":"labs/lab02/#como-funciona-un-vector_t","text":"Posee un int size que indica cu\u00e1ntos elementos posee actualmente. En otras palabras, el size es igual al \u00edndice de la \u00faltima posici\u00f3n que ha sido alterada del vector. Por ejemplo, si se tiene un vector con un size de 5 y se altera su ducent\u00e9cimo bit (\u00edndice iniciando en cero), su tama\u00f1o se ver\u00e1 actualizado a 201. La longitud por defecto del vector vector_new es de 1. Tiene un int *data , un arreglo din\u00e1mico de enteros que contiene los valores de los componentes del vector. Si se altera el ducent\u00e9cimo elemento de un vector v a 8 entonces el elemento modificado (de nuevo, iniciando en cero) de v->data deber\u00eda evaluar a 8. El valor de un vector vector_new es 0 por defecto. El valor de cualquier componente de alg\u00fan vector que no ha sido expl\u00edcitamente editado es 0. Si se deseara conocer el valor en la quinta posici\u00f3n de un vector, pero s\u00f3lo se ha alterado el valor de los primeras dos, la interrogante tendr\u00eda como respuesta 0. Adem\u00e1s, si se quisiera el contenido en la s\u00e9ptima posici\u00f3n de un vector de longitud igual a 5, tambi\u00e9n ser\u00eda 0. NO devolver\u00eda un error. Es momento de revisar el c\u00f3digo de ex3/vector.c si no lo han hecho. Aqu\u00ed hay comentarios complementarios que describen c\u00f3mo deber\u00edan de correr las funciones. Recuerden que los usuarios de su estructura de datos vector_t deben asumir que todas las entradas al vector son 0, a menos que hayan sido definidas de otra manera por ellos. Tengan esto en mente, porque malloc no hace esto por ustedes.","title":"\u00bfC\u00f3mo funciona un vector_t?"},{"location":"labs/lab02/#que-deben-hacer","text":"Completen vector_new , la versi\u00f3n correcta. Hay exactamente seis (6) espacios para que escriban una expresi\u00f3n en C, indicados con el comentario que dice /* YOUR CODE HERE */ . Escriban una expresi\u00f3n en estos sitios. Esto significa no m\u00e1s de una l\u00ednea de c\u00f3digo. Existen comentarios adicionales que describen qu\u00e9 deber\u00eda de suceder en la l\u00ednea de c\u00f3digo inferior a cada divisi\u00f3n. Terminen vector_get() de la misma manera en que lo hicieron para la funci\u00f3n anterior: de manera respetuosa, dispuesto a aprender, con mente abierta y conscientes de qu\u00e9 es lo que est\u00e1n escribiendo, ya que esta es la mejor forma de programar. Complementen vector_delete() . Una soluci\u00f3n satisfactoria no deber\u00eda de llevar m\u00e1s de dos l\u00edneas de c\u00f3digo. Corrijan a vector_set() . Esta es la m\u00e1s complicada. Bienvenidos a las ligas mayores. El problema de manipular una posici\u00f3n/\u00edndice arbitrario en un vector v es que es posible que no se haya reservado suficiente espacio con malloc en vector->data (s\u00ed, eso significa que tuvieron que haber guardado memoria con malloc ). Piensen c\u00f3mo administrar la memoria para lograr esto, para ver qu\u00e9 hacer con la data que estaba ah\u00ed antes y de qu\u00e9 otras cosas deben de hacer en su nuevo bloque de datos. Ayuda: Recuerden que los \u00edndices que no hayan sido alterados deben de ser cero. Hay distintas formas de acabar resolviendo esta funci\u00f3n. Consideren el uso de las 3 funciones __alloc , porque pueden resultar \u00fatiles... Saber c\u00f3mo reorganizar y liberar memoria es importante para la programaci\u00f3n en C. Piensen que el manejo de memoria es como un parqueo, si hay carros parqueados y los due\u00f1os nunca se van, entonces no tienen espacio para nuevos carros. Y recuerden que deber\u00edan tener un 'heap' vac\u00edo al terminar su programa. Utilicen free y todo estar\u00e1 bien.","title":"\u00bfQu\u00e9 deben hacer?"},{"location":"labs/lab02/#calificacion","text":"Por favor actualizar siempre la versi\u00f3n del CLI de autograders: 1 pip3 install --upgrade autograders-cli Como en todos los dem\u00e1s laboratorios, hay un autograder y este no es la excepci\u00f3n. El staff trabajo bastante para que su experiencia en este curso sea de las mejores. Entregaremos este lab de la misma manera que el pasado. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aprox. y luego puede ver sus resultados con... 1 autograder --stats Si le aparece Queued: True, espere un par de minutos y luego repita el autograder --stats \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.","title":"Calificaci\u00f3n"},{"location":"labs/lab03/","text":"Lab 3 - RISC-V Objetivos Practicar, corriendo y debuggeando c\u00f3digo ensamblador RISC-V. Escribir funciones en RISC-V con el procedimiento correcto de llamadas a funciones. Tener una idea de como traducir c\u00f3digo en C a RISC-V. Lecturas P&H: 2.12 Preparaci\u00f3n Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): 1 git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3. Introducci\u00f3n a Lenguaje Ensamblador RISC-V Los siguientes ejercicios utilizan un ensamblador y simulador de RISC-V, desarrollado por nuestro catedr\u00e1tico Ing. Andr\u00e9s Castellanos . El simulador se llama Jupiter (anteriormente V-Sim) y es un proyecto open source inspirado, inicialmente, en el lengendario SPIM y, posteriormente, en MARS y VENUS para la versi\u00f3n gr\u00e1fica. Para instalarlo en su computadora deben seguir estas instrucciones. M\u00e1quina virtual del curso Felicidades! No necesita instalar nada, puede ejecutar Jupiter usando el siguiente comando 1 jupiter Ubuntu 18 Debe instalar Jupiter usando estos comandos 1 2 3 sudo add-apt-repository ppa:andrescv/jupiter sudo apt-get update sudo apt-get install jupiter Luego podr\u00e1 ejecutarlo usando el comando jupiter Ubuntu 20 Descargar este archivo . Ir a la carpeta donde lo descarg\u00f3 y ejecutar los siguientes comandos 1 2 3 4 unzip Jupiter-3.1-linux.zip sudo mv image /opt/jupiter echo export\\ PATH=/opt/jupiter/bin:\\$PATH >> ~/.bashrc source ~/.bashrc Despu\u00e9s de esto, ya deber\u00eda poder usar el comando jupiter . Si no, la vieja y confiable, reinicie su computadora. Cosas b\u00e1sicas en V-Sim: A continuaci\u00f3n, les vamos a dar una peque\u00f1a gu\u00eda de Jupiter, para m\u00e1s informaci\u00f3n visiten la p\u00e1gina de documentaci\u00f3n en https://jupitersim.gitbook.io/jupiter/ . Pueden crear archivos, editarlos y borrarlos desde la pesta\u00f1a \"Editor\". Los programas empiezan en la etiqueta global __start , es decir que tienen que definir una etiqueta llamada __start y declararla como global. 1 2 3 4 .globl __start __start: li a0 , 10 ecall # exit Las etiquetas terminan con dos puntos como ven en el ejemplo anterior. Los comentarios comienzan con el simbolo \"#\" o \";\". NO PUEDEN poner m\u00e1s de una instrucci\u00f3n por l\u00ednea. Cuando hayan terminado de editar las instrucciones que conforman su c\u00f3digo, guarden y presionen F3 para preparar la ejecuci\u00f3n. Los programas siempre tienen que terminar con un ecall de exit y esto se logra poniendo un 10 en a0 ( exactamente como el ejemplo anterior ). Esto le indica al programa que tiene que terminar. Las instrucciones ecall son an\u00e1logas a los \"System Calls\" (llamadas al sistema) y nos permiten hacer cosas como imprimir a consola o reservar memoria din\u00e1mica. Ejercicio 1: Familiariz\u00e1ndote con Jupiter Para este ejercicio ustedes van a familiarizarse con Jupiter corriendo un programa sencillo de RISC-V y, luego, contestar\u00e1n unas preguntas. Abran una terminal ( CTRL + T ) y dir\u00edjanse a la carpeta del repositorio que clonaron. Abran el modo GUI de V-Sim ejecutando en la terminal jupiter . Desde el editor abran el archivo llamado ex1.s que esta en la carpeta ex1 . En la barra de herramientas de Jupiter, vayan a settings y aseg\u00farense de que Assemble Only Selected Tab est\u00e9 seleccionado con un cheque verde. Presionen F3 . Esto va a preparar el c\u00f3digo para que pueda ser ejecutado y simulado. Si hacen click a la pesta\u00f1a \"Editor\", su simulaci\u00f3n se va a reiniciar. En el simulador, para ejecutar la siguiente instrucci\u00f3n, presionen el bot\u00f3n que dice \"step\". Para regresar un paso atr\u00e1s, presionen el bot\u00f3n que dice \"backstep\". Para correr todo el programa hasta que termine, presionen el bot\u00f3n que dice \"go\". Para volver a empezar el programa nuevamente, presionen el bot\u00f3n que dice \"reset\". Para ver el contenido de los 32 registros en la parte derecha del simulador, hay una pesta\u00f1a que dice RVI . La consola est\u00e1 en la parte de abajo del simulador. Para ver el contenido de la memoria, en el mismo lugar que los registros hay una pesta\u00f1a que dice Memory , pueden navegar a diferentes secciones de la memoria haciendo click derecho encima de la tabla que muestra el estado de la memoria. Preguntas Ahora que ya han corrido su primer programa de RISC-V y que ganaron experiencia con Jupiter pueden contestar las siguientes preguntas en el archivo ex1.txt que se encuentra en la carpeta ex1 . 1) \u00bfQu\u00e9 significan las directivas .data , .word , .text , es decir, para qu\u00e9 las utilizan? Escriban s\u00f3lo una de las siguientes letras para responder. Pista: Piensen acerca de las cuatro secciones de memoria. A) Son como etiquetas sirven para hacer referencia a cosas que est\u00e1n en memoria, con .data apuntamos hacia los datos con .word hacia palabras de 32 bits y con .text hacia texto. B) .data le indica al ensamblador que guarde los siguientes elementos en la secci\u00f3n est\u00e1tica de la memoria, .word que guarde una palabra de 32 bits en memoria en la secci\u00f3n est\u00e1tica de datos y .text que estamos en la secci\u00f3n de texto y entonces deber\u00edamos escribir instrucciones de ensamblador. C) .data es para guardar datos en la secci\u00f3n de datos de la memoria, .word es para guardar palabras de 32 bits en la secci\u00f3n de palabras de la memoria, .text es para guardar texto ascii en la secci\u00f3n de texto de la memoria. D) .data y .word no son directivas de ensamblador, y .text siempre est\u00e1 por defecto y ni se tendr\u00eda que poner. 2) Corran por completo el programa. \u00bfQu\u00e9 n\u00famero da como \"output\"? 3) \u00bfQu\u00e9 representa el n\u00famero que da como output el programa? Escriban s\u00f3lo una de las siguientes letras para responder: A) N\u00famero \u00e1ureo B) Factorial de 9 C) Fibonnaci de 9 D) Factorial de 10 4) \u00bfEn qu\u00e9 direcci\u00f3n de memoria (en hexadecimal) est\u00e1 almacenado \"n\"? Pista: Miren el contenido de los registros. 5) Sin utilizar la pesta\u00f1a \"Editor\", hagan que el programa calcule el 13\u00ba n\u00famero (tomando en cuenta que el \u00edndice empieza en 0) de la sucesi\u00f3n de Fibonacci, modificando manualmente el valor de un registro. Encontrar\u00e1n \u00fatil de primero correr l\u00ednea por l\u00ednea el c\u00f3digo. Si prefieren ver los valores en decimal, cambien esto haciendo click derecho sobre la tabla de registros y presionando \"Decimal Display Mode\". \u00bfQu\u00e9 registro modificaron? Ejercicio 2: Traduciendo de C a RISC-V Desde Jupiter abran el archivo ex2.s que est\u00e1 en la carpeta ex2 y, desde alg\u00fan editor de texto de su preferencia, abran ex2.c , que est\u00e1 en la misma carpeta. El c\u00f3digo ensamblador que se provee (archivo ex2.s) es una traducci\u00f3n del programa escrito en C (archivo ex2.c) pero en RISC-V. Su tarea es encontrar/explicar los siguientes componentes de este archivo escrito en lenguaje ensamblador en el archivo de texto llamado ex2.txt , que tambi\u00e9n est\u00e1 en la misma carpeta. Preguntas \u00bfCu\u00e1l es el registro que representa la variable k ? \u00bfCu\u00e1les son los registros que act\u00faan como punteros a los arreglos source y dest (separados por coma)? \u00bfDe qu\u00e9 n\u00famero de l\u00ednea a que n\u00famero l\u00ednea se encuentra el loop (separado por coma)? \u00bfEn qu\u00e9 n\u00famero de l\u00ednea se copia el contenido de source a dest ?, es decir \u00bfd\u00f3nde se puede observar dest[k] = source[k] ?. \u00bfC\u00f3mo son manipulados los punteros en el c\u00f3digo? Escriban s\u00f3lo una de las siguientes letras para responder: A) En cada iteraci\u00f3n se le suma k a cada puntero, que es el equivalente en C a arreglo[k] . B) En cada iteraci\u00f3n se le suma k * 4 a cada puntero, que es equivalente en C a arreglo[k] . C) En cada iteraci\u00f3n se le hace corrimiento l\u00f3gico a la derecha a cada puntero, que es equivalente en C a arreglo[k] . D) En cada iteraci\u00f3n se le suma +1 a cada puntero, que es equivalente en C a arreglo[k] . Ejercicio 3: Factorial. En este ejercicio, tienen que implementar la funci\u00f3n de factorial en RISC-V que toma un s\u00f3lo par\u00e1metro entero n y retorna n! . Pueden encontrar un esqueleto de esta funci\u00f3n en el archivo factorial.s , que se encuentra en la carpeta ex3 del repositorio que clonaron. Ustedes s\u00f3lo necesitan agregar las instrucciones bajo la etiqueta factorial , y el argumento que se pasa a la funci\u00f3n va en el registro a0 . Pueden resolver este problema ya sea de forma recursiva o iterativa. Aseg\u00farense de que su funci\u00f3n retorne de forma apropidada lo siguiente 3! = 6 , 7! = 5040 y 8! = 40320 . Ejercicio 4: List Map Para este ejercicio van a utilizar el archivo list_map.s que se encuentra en la carpeta ex4 . En este ejercicio, van a completar una funci\u00f3n de \"map\" con listas encadenadas en RISC-V. La funci\u00f3n se simplificar\u00e1 en mutar la lista en cuesti\u00f3n, es decir que tomar\u00e1 una lista encadenada como entrada y va a retornar la lista con los valores modificados. Nuestro procedimiento de \"map\" toma dos par\u00e1metros, el primero ser\u00e1 la direcci\u00f3n del nodo \"head\" de una lista encadenada, cuyos valores son enteros de 32 bits. Entonces, en C, la estructura se define como: 1 2 3 4 struct node { int value ; struct node * next ; }; El segundo par\u00e1metro ser\u00e1 la direcci\u00f3n de una funci\u00f3n que toma un entero como argumento y devuelve un entero. Usaremos la instrucci\u00f3n \"jalr\" de RISC-V para llamar a esta funci\u00f3n con los valores de cada nodo de la lista. Nuestra funci\u00f3n \"map\" ir\u00e1 recorriendo la lista recursivamente, aplicando la funci\u00f3n a cada valor de la lista y almacenando el valor devuelto al nodo correspondiente. En C, la funci\u00f3n se ver\u00eda algo como esta: 1 2 3 4 5 void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } head -> value = f ( head -> value ); map ( head -> next , f ); } Si no hab\u00edan visto lo de int (*f)(int) antes, no se preocupen demasiado. Significa b\u00e1sicamente que f es un puntero a una funci\u00f3n de C, f entonces puede ser utilizado exactamente como cualquier otra funci\u00f3n. Les ser\u00e1 \u00fatil acudir al green card de RISC-V que pueden encontrar aqu\u00ed para completar este ejercicio. Hay exactamente 9 espacios (8 en map y 1 en main ), en el c\u00f3digo que se provee, donde dice YOUR_INSTRUCTION_HERE . Reemplacen esos espacios con las instrucciones de su implementaci\u00f3n de map, y escriban una simple llamada a map con square como argumento de la funci\u00f3n. Hay comentarios en el c\u00f3digo que explican qu\u00e9 deber\u00eda hacer, o cumplir, cada instrucci\u00f3n. Cuando hayan rellenado los espacios con las instrucciones correctas, pueden correr el c\u00f3digo pulsando en F3 y luego el bot\u00f3n Go , al hacer esto, deber\u00eda de darles como output lo siguiente: 1 2 9 8 7 6 5 4 3 2 1 0 81 64 49 36 25 16 9 4 1 0 La primera l\u00ednea es la lista original, y la segunda es la lista modificada despu\u00e9s de que se aplic\u00f3 la funci\u00f3n \"map\". Calificaci\u00f3n Por favor actualizar siempre la versi\u00f3n del CLI de autograders: 1 pip3 install --upgrade autograders-cli Como en todos los dem\u00e1s laboratorios, hay un autograder y este no es la excepci\u00f3n. El staff trabajo bastante para que su experiencia en este curso sea de las mejores. Entregaremos este lab de la misma manera que el pasado. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aprox. y luego puede ver sus resultados con... 1 autograder --stats Si le aparece Queued: True, espere un par de minutos y luego repita el autograder --stats \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.","title":"Lab 3 - RISC-V"},{"location":"labs/lab03/#lab-3-risc-v","text":"","title":"Lab 3 - RISC-V"},{"location":"labs/lab03/#objetivos","text":"Practicar, corriendo y debuggeando c\u00f3digo ensamblador RISC-V. Escribir funciones en RISC-V con el procedimiento correcto de llamadas a funciones. Tener una idea de como traducir c\u00f3digo en C a RISC-V.","title":"Objetivos"},{"location":"labs/lab03/#lecturas","text":"P&H: 2.12","title":"Lecturas"},{"location":"labs/lab03/#preparacion","text":"Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): 1 git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3.","title":"Preparaci\u00f3n"},{"location":"labs/lab03/#introduccion-a-lenguaje-ensamblador-risc-v","text":"Los siguientes ejercicios utilizan un ensamblador y simulador de RISC-V, desarrollado por nuestro catedr\u00e1tico Ing. Andr\u00e9s Castellanos . El simulador se llama Jupiter (anteriormente V-Sim) y es un proyecto open source inspirado, inicialmente, en el lengendario SPIM y, posteriormente, en MARS y VENUS para la versi\u00f3n gr\u00e1fica. Para instalarlo en su computadora deben seguir estas instrucciones. M\u00e1quina virtual del curso Felicidades! No necesita instalar nada, puede ejecutar Jupiter usando el siguiente comando 1 jupiter Ubuntu 18 Debe instalar Jupiter usando estos comandos 1 2 3 sudo add-apt-repository ppa:andrescv/jupiter sudo apt-get update sudo apt-get install jupiter Luego podr\u00e1 ejecutarlo usando el comando jupiter Ubuntu 20 Descargar este archivo . Ir a la carpeta donde lo descarg\u00f3 y ejecutar los siguientes comandos 1 2 3 4 unzip Jupiter-3.1-linux.zip sudo mv image /opt/jupiter echo export\\ PATH=/opt/jupiter/bin:\\$PATH >> ~/.bashrc source ~/.bashrc Despu\u00e9s de esto, ya deber\u00eda poder usar el comando jupiter . Si no, la vieja y confiable, reinicie su computadora.","title":"Introducci\u00f3n a Lenguaje Ensamblador RISC-V"},{"location":"labs/lab03/#cosas-basicas-en-v-sim","text":"A continuaci\u00f3n, les vamos a dar una peque\u00f1a gu\u00eda de Jupiter, para m\u00e1s informaci\u00f3n visiten la p\u00e1gina de documentaci\u00f3n en https://jupitersim.gitbook.io/jupiter/ . Pueden crear archivos, editarlos y borrarlos desde la pesta\u00f1a \"Editor\". Los programas empiezan en la etiqueta global __start , es decir que tienen que definir una etiqueta llamada __start y declararla como global. 1 2 3 4 .globl __start __start: li a0 , 10 ecall # exit Las etiquetas terminan con dos puntos como ven en el ejemplo anterior. Los comentarios comienzan con el simbolo \"#\" o \";\". NO PUEDEN poner m\u00e1s de una instrucci\u00f3n por l\u00ednea. Cuando hayan terminado de editar las instrucciones que conforman su c\u00f3digo, guarden y presionen F3 para preparar la ejecuci\u00f3n. Los programas siempre tienen que terminar con un ecall de exit y esto se logra poniendo un 10 en a0 ( exactamente como el ejemplo anterior ). Esto le indica al programa que tiene que terminar. Las instrucciones ecall son an\u00e1logas a los \"System Calls\" (llamadas al sistema) y nos permiten hacer cosas como imprimir a consola o reservar memoria din\u00e1mica.","title":"Cosas b\u00e1sicas en V-Sim:"},{"location":"labs/lab03/#ejercicio-1-familiarizandote-con-jupiter","text":"Para este ejercicio ustedes van a familiarizarse con Jupiter corriendo un programa sencillo de RISC-V y, luego, contestar\u00e1n unas preguntas. Abran una terminal ( CTRL + T ) y dir\u00edjanse a la carpeta del repositorio que clonaron. Abran el modo GUI de V-Sim ejecutando en la terminal jupiter . Desde el editor abran el archivo llamado ex1.s que esta en la carpeta ex1 . En la barra de herramientas de Jupiter, vayan a settings y aseg\u00farense de que Assemble Only Selected Tab est\u00e9 seleccionado con un cheque verde. Presionen F3 . Esto va a preparar el c\u00f3digo para que pueda ser ejecutado y simulado. Si hacen click a la pesta\u00f1a \"Editor\", su simulaci\u00f3n se va a reiniciar. En el simulador, para ejecutar la siguiente instrucci\u00f3n, presionen el bot\u00f3n que dice \"step\". Para regresar un paso atr\u00e1s, presionen el bot\u00f3n que dice \"backstep\". Para correr todo el programa hasta que termine, presionen el bot\u00f3n que dice \"go\". Para volver a empezar el programa nuevamente, presionen el bot\u00f3n que dice \"reset\". Para ver el contenido de los 32 registros en la parte derecha del simulador, hay una pesta\u00f1a que dice RVI . La consola est\u00e1 en la parte de abajo del simulador. Para ver el contenido de la memoria, en el mismo lugar que los registros hay una pesta\u00f1a que dice Memory , pueden navegar a diferentes secciones de la memoria haciendo click derecho encima de la tabla que muestra el estado de la memoria.","title":"Ejercicio 1: Familiariz\u00e1ndote con Jupiter"},{"location":"labs/lab03/#preguntas","text":"Ahora que ya han corrido su primer programa de RISC-V y que ganaron experiencia con Jupiter pueden contestar las siguientes preguntas en el archivo ex1.txt que se encuentra en la carpeta ex1 . 1) \u00bfQu\u00e9 significan las directivas .data , .word , .text , es decir, para qu\u00e9 las utilizan? Escriban s\u00f3lo una de las siguientes letras para responder. Pista: Piensen acerca de las cuatro secciones de memoria. A) Son como etiquetas sirven para hacer referencia a cosas que est\u00e1n en memoria, con .data apuntamos hacia los datos con .word hacia palabras de 32 bits y con .text hacia texto. B) .data le indica al ensamblador que guarde los siguientes elementos en la secci\u00f3n est\u00e1tica de la memoria, .word que guarde una palabra de 32 bits en memoria en la secci\u00f3n est\u00e1tica de datos y .text que estamos en la secci\u00f3n de texto y entonces deber\u00edamos escribir instrucciones de ensamblador. C) .data es para guardar datos en la secci\u00f3n de datos de la memoria, .word es para guardar palabras de 32 bits en la secci\u00f3n de palabras de la memoria, .text es para guardar texto ascii en la secci\u00f3n de texto de la memoria. D) .data y .word no son directivas de ensamblador, y .text siempre est\u00e1 por defecto y ni se tendr\u00eda que poner. 2) Corran por completo el programa. \u00bfQu\u00e9 n\u00famero da como \"output\"? 3) \u00bfQu\u00e9 representa el n\u00famero que da como output el programa? Escriban s\u00f3lo una de las siguientes letras para responder: A) N\u00famero \u00e1ureo B) Factorial de 9 C) Fibonnaci de 9 D) Factorial de 10 4) \u00bfEn qu\u00e9 direcci\u00f3n de memoria (en hexadecimal) est\u00e1 almacenado \"n\"? Pista: Miren el contenido de los registros. 5) Sin utilizar la pesta\u00f1a \"Editor\", hagan que el programa calcule el 13\u00ba n\u00famero (tomando en cuenta que el \u00edndice empieza en 0) de la sucesi\u00f3n de Fibonacci, modificando manualmente el valor de un registro. Encontrar\u00e1n \u00fatil de primero correr l\u00ednea por l\u00ednea el c\u00f3digo. Si prefieren ver los valores en decimal, cambien esto haciendo click derecho sobre la tabla de registros y presionando \"Decimal Display Mode\". \u00bfQu\u00e9 registro modificaron?","title":"Preguntas"},{"location":"labs/lab03/#ejercicio-2-traduciendo-de-c-a-risc-v","text":"Desde Jupiter abran el archivo ex2.s que est\u00e1 en la carpeta ex2 y, desde alg\u00fan editor de texto de su preferencia, abran ex2.c , que est\u00e1 en la misma carpeta. El c\u00f3digo ensamblador que se provee (archivo ex2.s) es una traducci\u00f3n del programa escrito en C (archivo ex2.c) pero en RISC-V. Su tarea es encontrar/explicar los siguientes componentes de este archivo escrito en lenguaje ensamblador en el archivo de texto llamado ex2.txt , que tambi\u00e9n est\u00e1 en la misma carpeta.","title":"Ejercicio 2: Traduciendo de C a RISC-V"},{"location":"labs/lab03/#preguntas_1","text":"\u00bfCu\u00e1l es el registro que representa la variable k ? \u00bfCu\u00e1les son los registros que act\u00faan como punteros a los arreglos source y dest (separados por coma)? \u00bfDe qu\u00e9 n\u00famero de l\u00ednea a que n\u00famero l\u00ednea se encuentra el loop (separado por coma)? \u00bfEn qu\u00e9 n\u00famero de l\u00ednea se copia el contenido de source a dest ?, es decir \u00bfd\u00f3nde se puede observar dest[k] = source[k] ?. \u00bfC\u00f3mo son manipulados los punteros en el c\u00f3digo? Escriban s\u00f3lo una de las siguientes letras para responder: A) En cada iteraci\u00f3n se le suma k a cada puntero, que es el equivalente en C a arreglo[k] . B) En cada iteraci\u00f3n se le suma k * 4 a cada puntero, que es equivalente en C a arreglo[k] . C) En cada iteraci\u00f3n se le hace corrimiento l\u00f3gico a la derecha a cada puntero, que es equivalente en C a arreglo[k] . D) En cada iteraci\u00f3n se le suma +1 a cada puntero, que es equivalente en C a arreglo[k] .","title":"Preguntas"},{"location":"labs/lab03/#ejercicio-3-factorial","text":"En este ejercicio, tienen que implementar la funci\u00f3n de factorial en RISC-V que toma un s\u00f3lo par\u00e1metro entero n y retorna n! . Pueden encontrar un esqueleto de esta funci\u00f3n en el archivo factorial.s , que se encuentra en la carpeta ex3 del repositorio que clonaron. Ustedes s\u00f3lo necesitan agregar las instrucciones bajo la etiqueta factorial , y el argumento que se pasa a la funci\u00f3n va en el registro a0 . Pueden resolver este problema ya sea de forma recursiva o iterativa. Aseg\u00farense de que su funci\u00f3n retorne de forma apropidada lo siguiente 3! = 6 , 7! = 5040 y 8! = 40320 .","title":"Ejercicio 3: Factorial."},{"location":"labs/lab03/#ejercicio-4-list-map","text":"Para este ejercicio van a utilizar el archivo list_map.s que se encuentra en la carpeta ex4 . En este ejercicio, van a completar una funci\u00f3n de \"map\" con listas encadenadas en RISC-V. La funci\u00f3n se simplificar\u00e1 en mutar la lista en cuesti\u00f3n, es decir que tomar\u00e1 una lista encadenada como entrada y va a retornar la lista con los valores modificados. Nuestro procedimiento de \"map\" toma dos par\u00e1metros, el primero ser\u00e1 la direcci\u00f3n del nodo \"head\" de una lista encadenada, cuyos valores son enteros de 32 bits. Entonces, en C, la estructura se define como: 1 2 3 4 struct node { int value ; struct node * next ; }; El segundo par\u00e1metro ser\u00e1 la direcci\u00f3n de una funci\u00f3n que toma un entero como argumento y devuelve un entero. Usaremos la instrucci\u00f3n \"jalr\" de RISC-V para llamar a esta funci\u00f3n con los valores de cada nodo de la lista. Nuestra funci\u00f3n \"map\" ir\u00e1 recorriendo la lista recursivamente, aplicando la funci\u00f3n a cada valor de la lista y almacenando el valor devuelto al nodo correspondiente. En C, la funci\u00f3n se ver\u00eda algo como esta: 1 2 3 4 5 void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } head -> value = f ( head -> value ); map ( head -> next , f ); } Si no hab\u00edan visto lo de int (*f)(int) antes, no se preocupen demasiado. Significa b\u00e1sicamente que f es un puntero a una funci\u00f3n de C, f entonces puede ser utilizado exactamente como cualquier otra funci\u00f3n. Les ser\u00e1 \u00fatil acudir al green card de RISC-V que pueden encontrar aqu\u00ed para completar este ejercicio. Hay exactamente 9 espacios (8 en map y 1 en main ), en el c\u00f3digo que se provee, donde dice YOUR_INSTRUCTION_HERE . Reemplacen esos espacios con las instrucciones de su implementaci\u00f3n de map, y escriban una simple llamada a map con square como argumento de la funci\u00f3n. Hay comentarios en el c\u00f3digo que explican qu\u00e9 deber\u00eda hacer, o cumplir, cada instrucci\u00f3n. Cuando hayan rellenado los espacios con las instrucciones correctas, pueden correr el c\u00f3digo pulsando en F3 y luego el bot\u00f3n Go , al hacer esto, deber\u00eda de darles como output lo siguiente: 1 2 9 8 7 6 5 4 3 2 1 0 81 64 49 36 25 16 9 4 1 0 La primera l\u00ednea es la lista original, y la segunda es la lista modificada despu\u00e9s de que se aplic\u00f3 la funci\u00f3n \"map\".","title":"Ejercicio 4: List Map"},{"location":"labs/lab03/#calificacion","text":"Por favor actualizar siempre la versi\u00f3n del CLI de autograders: 1 pip3 install --upgrade autograders-cli Como en todos los dem\u00e1s laboratorios, hay un autograder y este no es la excepci\u00f3n. El staff trabajo bastante para que su experiencia en este curso sea de las mejores. Entregaremos este lab de la misma manera que el pasado. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aprox. y luego puede ver sus resultados con... 1 autograder --stats Si le aparece Queued: True, espere un par de minutos y luego repita el autograder --stats \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.","title":"Calificaci\u00f3n"},{"location":"labs/lab04/","text":"Lab 4 - RISC-V Objetivos Divertirse con RISC-V Encontrar los errores de Ali Hacer algo imposible Pensar en la idea de hacer lo imposible Lecturas P&H: 2.12 Preparaci\u00f3n Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): 1 git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3. Ejercicio 1: Depurando megalistmanips.s Hace mucho tiempo, su catedr\u00e1tico Ali era un principiante en RISC-V, y escribi\u00f3 su soluci\u00f3n a un lab en este archivo: megalistmanips.s . Ustedes, ahora que ya son expertos en RISC-V, deben arreglar los bugs que cometi\u00f3 Ali. El objetivo principal de este ejercicio es que encuentren los errores en la funci\u00f3n map en megalistmanips.s . Antes de hacer eso, familiar\u00edcense con lo que la funci\u00f3n trata de hacer. En el lab anterior, ten\u00edamos una lista encadenada de enteros, ahora nuestra estructura de datos es una lista encadena cuyo valor en cada nodo es un arreglo de enteros. Recuerden que cuando se trabaja con arreglos en structs, necesitamos almacenar expl\u00edcitamente el tama\u00f1o del array. En c\u00f3digo de C, el struct se ver\u00eda as\u00ed: 1 2 3 4 5 struct node { int * arr ; int size ; struct node * next ; }; Aqu\u00ed tambi\u00e9n est\u00e1 lo que la nueva funci\u00f3n map hace: atraviesa la lista encadenada y para cada elemento del arreglo de cada nodo, aplica la funci\u00f3n y vuelve a guardarlo en el array. En C, esto se mirar\u00eda de la siguiente manera: 1 2 3 4 5 6 7 void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } for ( int i = 0 ; i < head -> size ; i ++ ) { head -> arr [ i ] = f ( head -> arr [ i ]); } map ( head -> next , f ); } Lean todos los comentarios en la funci\u00f3n map en megalistmanips.s (antes de que retorne con jr ra ), y aseg\u00farense de que las l\u00edneas hagan lo que el comentario dice. Algunas pistas: \u00bfPor qu\u00e9 necesitamos guardar cosas en el stack antes de llamar a jal ? \u00bfCu\u00e1l es la diferencia entre add t0, s0, x0 y lw t0, 0(s0) ? Presten atenci\u00f3n a los tipos de los atributos en el struct . \u00a1Gracias por hacer el ejercicio! Estamos seguros de que Ali se estar\u00e1 preguntando d\u00f3nde estaban para ayudarlo cuando no entend\u00eda RISC-V hace un tiempo atr\u00e1s. Ejercicio 2: Escriban una funci\u00f3n sin utilizar branches Consideren la funci\u00f3n \\(f\\) de valor discreto definida en el set de enteros \\({-3, -2, -1, 0, 1, 2, 3}\\) . Esta es la definici\u00f3n de la funci\u00f3n: \\(\\begin{align} &f(-3) = 6\\\\\\\\ &f(-2) = 61\\\\\\\\ &f(-1) = 17\\\\\\\\ &f(0) = -38\\\\\\\\ &f(1) = 19\\\\\\\\ &f(2) = 42\\\\\\\\ &f(3) = 5 \\end{align}\\) No les vamos a mentir, es una funci\u00f3n muy tonta. Sin embargo, su tarea es implementarla en RISC-V, con la condici\u00f3n de que NO pueden utilizar las instrucciones de branch por ning\u00fan motivo. Por suerte alguna persona ha dejado por accidente un array de enteros en la secci\u00f3n .data de discrete_fn.s . \u00bfC\u00f3mo pueden utilizarlo para tener ventaja sobre eso y completar esta tarea que aparenta ser imposible? Calificaci\u00f3n Por favor actualizar siempre la versi\u00f3n del CLI de autograders: 1 pip3 install --upgrade autograders-cli Entregaremos este lab de la misma manera que el pasado. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aprox. y luego puede ver sus resultados con... 1 autograder --stats Si le aparece Queued: True, espere un par de minutos y luego repita el autograder --stats \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.","title":"Lab 4 - RISC-V"},{"location":"labs/lab04/#lab-4-risc-v","text":"","title":"Lab 4 - RISC-V"},{"location":"labs/lab04/#objetivos","text":"Divertirse con RISC-V Encontrar los errores de Ali Hacer algo imposible Pensar en la idea de hacer lo imposible","title":"Objetivos"},{"location":"labs/lab04/#lecturas","text":"P&H: 2.12","title":"Lecturas"},{"location":"labs/lab04/#preparacion","text":"Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): 1 git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3.","title":"Preparaci\u00f3n"},{"location":"labs/lab04/#ejercicio-1-depurando-megalistmanipss","text":"Hace mucho tiempo, su catedr\u00e1tico Ali era un principiante en RISC-V, y escribi\u00f3 su soluci\u00f3n a un lab en este archivo: megalistmanips.s . Ustedes, ahora que ya son expertos en RISC-V, deben arreglar los bugs que cometi\u00f3 Ali. El objetivo principal de este ejercicio es que encuentren los errores en la funci\u00f3n map en megalistmanips.s . Antes de hacer eso, familiar\u00edcense con lo que la funci\u00f3n trata de hacer. En el lab anterior, ten\u00edamos una lista encadenada de enteros, ahora nuestra estructura de datos es una lista encadena cuyo valor en cada nodo es un arreglo de enteros. Recuerden que cuando se trabaja con arreglos en structs, necesitamos almacenar expl\u00edcitamente el tama\u00f1o del array. En c\u00f3digo de C, el struct se ver\u00eda as\u00ed: 1 2 3 4 5 struct node { int * arr ; int size ; struct node * next ; }; Aqu\u00ed tambi\u00e9n est\u00e1 lo que la nueva funci\u00f3n map hace: atraviesa la lista encadenada y para cada elemento del arreglo de cada nodo, aplica la funci\u00f3n y vuelve a guardarlo en el array. En C, esto se mirar\u00eda de la siguiente manera: 1 2 3 4 5 6 7 void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } for ( int i = 0 ; i < head -> size ; i ++ ) { head -> arr [ i ] = f ( head -> arr [ i ]); } map ( head -> next , f ); } Lean todos los comentarios en la funci\u00f3n map en megalistmanips.s (antes de que retorne con jr ra ), y aseg\u00farense de que las l\u00edneas hagan lo que el comentario dice. Algunas pistas: \u00bfPor qu\u00e9 necesitamos guardar cosas en el stack antes de llamar a jal ? \u00bfCu\u00e1l es la diferencia entre add t0, s0, x0 y lw t0, 0(s0) ? Presten atenci\u00f3n a los tipos de los atributos en el struct . \u00a1Gracias por hacer el ejercicio! Estamos seguros de que Ali se estar\u00e1 preguntando d\u00f3nde estaban para ayudarlo cuando no entend\u00eda RISC-V hace un tiempo atr\u00e1s.","title":"Ejercicio 1: Depurando megalistmanips.s"},{"location":"labs/lab04/#ejercicio-2-escriban-una-funcion-sin-utilizar-branches","text":"Consideren la funci\u00f3n \\(f\\) de valor discreto definida en el set de enteros \\({-3, -2, -1, 0, 1, 2, 3}\\) . Esta es la definici\u00f3n de la funci\u00f3n: \\(\\begin{align} &f(-3) = 6\\\\\\\\ &f(-2) = 61\\\\\\\\ &f(-1) = 17\\\\\\\\ &f(0) = -38\\\\\\\\ &f(1) = 19\\\\\\\\ &f(2) = 42\\\\\\\\ &f(3) = 5 \\end{align}\\) No les vamos a mentir, es una funci\u00f3n muy tonta. Sin embargo, su tarea es implementarla en RISC-V, con la condici\u00f3n de que NO pueden utilizar las instrucciones de branch por ning\u00fan motivo. Por suerte alguna persona ha dejado por accidente un array de enteros en la secci\u00f3n .data de discrete_fn.s . \u00bfC\u00f3mo pueden utilizarlo para tener ventaja sobre eso y completar esta tarea que aparenta ser imposible?","title":"Ejercicio 2: Escriban una funci\u00f3n sin utilizar branches"},{"location":"labs/lab04/#calificacion","text":"Por favor actualizar siempre la versi\u00f3n del CLI de autograders: 1 pip3 install --upgrade autograders-cli Entregaremos este lab de la misma manera que el pasado. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aprox. y luego puede ver sus resultados con... 1 autograder --stats Si le aparece Queued: True, espere un par de minutos y luego repita el autograder --stats \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.","title":"Calificaci\u00f3n"},{"location":"labs/lab05/","text":"Lab 7 - ALU Proyecto 2 Objetivo Este laboratorio es bastante corto y representa los primeros 25 puntos de su proyecto 2 (procesador de RISC-V en Logisim). El motivo principal es que tengan m\u00e1s tiempo para invertir en otras partes del proyecto. Si logran sacar 100 en el laboratorio tendr\u00e1n una de tres partes terminadas... \u00e9xitos. Preparaci\u00f3n Para este laboratorio, nuevamente, es necesario que tengan la aplicaci\u00f3n de Logisim . Adicionalmente pueden utilizar la documentaci\u00f3n de Logisim para refrescar el conocimiento que adquirieron en los laboratorios anteriores. Tambi\u00e9n tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): 1 git clone <link del repositorio> Ejercicio 1: Arithmetic Logic Unit (ALU) Las instrucciones de este ejercicio son una copia literal de las instrucciones del proyecto 2, por favor lean cuidadosamente . Su tarea es crear un ALU que soporte todas las operaciones que necesitan las instrucciones de nuestro ISA. Van a estar trabajando en el archivo alu.circ . Este tiene tres entradas: Nombre de Entrada Ancho en Bits Descripci\u00f3n A 32 Datos para usar por A en la operaci\u00f3n del ALU B 32 Datos para usar por B en la operaci\u00f3n del ALU ALU Op 4 Selecciona la operaci\u00f3n que el ALU deber\u00eda de efectuar y cuatro salidas: Nombre de Entrada Ancho en Bits Descripci\u00f3n Out 32 Resultado de la operaci\u00f3n efectuada por el ALU Equal 1 1 si A y B son iguales, 0 de lo contrario LT 1 1 si A es menor que B (signed), 0 de lo contrario LTU 1 1 si A es menor que B (unsigned), 0 de lo contrario Esta es la lista de operaciones que necesitan implementar. Ustedes tienen que utilizar y les recomendamos utilizar los componentes de logisim que ya efectuan estas operaciones, por favor no las implementen desde 0, ser\u00eda muy tardado y no es el objetivo del proyecto ni del laboratorio. Valor de ALU Op Instrucci\u00f3n 0 sll: Out = A << B[4:0] 1 srl: Out = (unsigned) A >> B[4:0] 2 add: Out = A + B 3 and: Out = A & B 4 or: Out = A | B 5 xor: Out = A ^ B 6 slt: Out = (A < B) ? 1 : 0 Signed 7 mul: Out = (X * Y)[31:0] 8 mulh: Out = (A * B)[63:32] 9 div: Out =(unsigned) A / B 10 rem: Out = A % B 11 sub: Out = A - B Algunas cosas adicionales que tienen que tener en mente: La salidas Equal , LT , LTU siempre tienen que sacar el valor correcto de comparaci\u00f3n sin importar el valor de ALU Op . Ustedes no pueden modificar (mover, reemplazar, cortar, pegar, eliminar, etc) los pines de entrada ni de salida que nosotros les damos de lo contrario el autograder no va a funcionar correctamente, tengan en cuenta esto para evitar problemas con el autograder a la hora de hacer submit. Calificaci\u00f3n Al finalizar su circuito puede usar ./check para probarlo de forma local. Debido a lo importante que sera el ALU para su proyecto, este lab se calificara con 0 o 100 unicamente. Cuando haya superado el test local puede hacer autograder --upload para subir su laboratorio y luego autograder --stats para comprobar su 100 de nota. No olvide hacer add + commit + push a su repositorio y subir el link de este al GES.","title":"Lab 7 - ALU Proyecto 2"},{"location":"labs/lab05/#lab-7-alu-proyecto-2","text":"","title":"Lab 7 - ALU Proyecto 2"},{"location":"labs/lab05/#objetivo","text":"Este laboratorio es bastante corto y representa los primeros 25 puntos de su proyecto 2 (procesador de RISC-V en Logisim). El motivo principal es que tengan m\u00e1s tiempo para invertir en otras partes del proyecto. Si logran sacar 100 en el laboratorio tendr\u00e1n una de tres partes terminadas... \u00e9xitos.","title":"Objetivo"},{"location":"labs/lab05/#preparacion","text":"Para este laboratorio, nuevamente, es necesario que tengan la aplicaci\u00f3n de Logisim . Adicionalmente pueden utilizar la documentaci\u00f3n de Logisim para refrescar el conocimiento que adquirieron en los laboratorios anteriores. Tambi\u00e9n tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): 1 git clone <link del repositorio>","title":"Preparaci\u00f3n"},{"location":"labs/lab05/#ejercicio-1-arithmetic-logic-unit-alu","text":"Las instrucciones de este ejercicio son una copia literal de las instrucciones del proyecto 2, por favor lean cuidadosamente . Su tarea es crear un ALU que soporte todas las operaciones que necesitan las instrucciones de nuestro ISA. Van a estar trabajando en el archivo alu.circ . Este tiene tres entradas: Nombre de Entrada Ancho en Bits Descripci\u00f3n A 32 Datos para usar por A en la operaci\u00f3n del ALU B 32 Datos para usar por B en la operaci\u00f3n del ALU ALU Op 4 Selecciona la operaci\u00f3n que el ALU deber\u00eda de efectuar y cuatro salidas: Nombre de Entrada Ancho en Bits Descripci\u00f3n Out 32 Resultado de la operaci\u00f3n efectuada por el ALU Equal 1 1 si A y B son iguales, 0 de lo contrario LT 1 1 si A es menor que B (signed), 0 de lo contrario LTU 1 1 si A es menor que B (unsigned), 0 de lo contrario Esta es la lista de operaciones que necesitan implementar. Ustedes tienen que utilizar y les recomendamos utilizar los componentes de logisim que ya efectuan estas operaciones, por favor no las implementen desde 0, ser\u00eda muy tardado y no es el objetivo del proyecto ni del laboratorio. Valor de ALU Op Instrucci\u00f3n 0 sll: Out = A << B[4:0] 1 srl: Out = (unsigned) A >> B[4:0] 2 add: Out = A + B 3 and: Out = A & B 4 or: Out = A | B 5 xor: Out = A ^ B 6 slt: Out = (A < B) ? 1 : 0 Signed 7 mul: Out = (X * Y)[31:0] 8 mulh: Out = (A * B)[63:32] 9 div: Out =(unsigned) A / B 10 rem: Out = A % B 11 sub: Out = A - B Algunas cosas adicionales que tienen que tener en mente: La salidas Equal , LT , LTU siempre tienen que sacar el valor correcto de comparaci\u00f3n sin importar el valor de ALU Op . Ustedes no pueden modificar (mover, reemplazar, cortar, pegar, eliminar, etc) los pines de entrada ni de salida que nosotros les damos de lo contrario el autograder no va a funcionar correctamente, tengan en cuenta esto para evitar problemas con el autograder a la hora de hacer submit.","title":"Ejercicio 1: Arithmetic Logic Unit (ALU)"},{"location":"labs/lab05/#calificacion","text":"Al finalizar su circuito puede usar ./check para probarlo de forma local. Debido a lo importante que sera el ALU para su proyecto, este lab se calificara con 0 o 100 unicamente. Cuando haya superado el test local puede hacer autograder --upload para subir su laboratorio y luego autograder --stats para comprobar su 100 de nota. No olvide hacer add + commit + push a su repositorio y subir el link de este al GES.","title":"Calificaci\u00f3n"},{"location":"projects/pj01/","text":"Proyecto 1: C y RISC-V Objetivos Mejorar sus habilidades de programaci\u00f3n en C. Conocer algunos de los detalles de RISC-V. Prepararse para lo que viene m\u00e1s adelante en el curso. Requisitos de Conocimiento Para realizar este proyecto ustedes tienen que tener claros algunos conceptos, de lo contrario ser\u00e1 bastante dif\u00edcil e inc\u00f3modo empezar a trabajar. Les recomendamos que antes de empezar est\u00e9n totalmente seguros que dominan al 100% los siguientes puntos: Operaciones binarias en C ( xor , or , and , etc). Operaciones aritm\u00e9ticas con signo y sin signo en C. Type casting en C. Control de flujo en C ( switch , if , etc). Funciones en C. Entender qu\u00e9 son las estructuras ( struct ) en C. Entender c\u00f3mo funcionan las uniones ( union ) en C. Uso correcto de printf . Entender la estructura del set de instrucciones de RISC-V. Programar en lenguaje ensamblador RISC-V. Si creen que no tienen claro alguno de estos temas al 100%, por favor no duden en ir a consultar los libros y material correspondiente del curso, por ejemplo K&R , es indispensable. En Lecturas Recomendadas pueden encontrar algunas lecturas que tocan los puntos antes mencionados y otras cosas que tambi\u00e9n les pueden servir, nunca est\u00e1 dem\u00e1s tener un poco m\u00e1s de informaci\u00f3n. Lecturas Recomendadas Gu\u00eda Pr\u00e1ctica de RISC-V: 2 K&R: 6 P&H: B-43 Introducci\u00f3n En este proyecto ustedes deben de crear un emulador que pueda ejecutar un subconjunto de instrucciones de RISC-V . Ustedes se van a encargar de hacer un programa que decodifique y ejecute varias instrucciones de RISC-V. Consid\u00e9renlo como una versi\u00f3n miniatura de Jupiter . RISC-V Green Card Aqu\u00ed hay dos RISC-V Green Cards que pueden consultar y as\u00ed tener m\u00e1s herramientras que les pueden ayudar a completar el proyecto. La primera tiene informaci\u00f3n acerca de los opcodes y otros campos de cada uno de los diferentes formatos de instrucci\u00f3n, por lo que esta ser\u00eda su mejor opci\u00f3n. Preparaci\u00f3n Antes de comenzar aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta pueden consultar la secci\u00f3n de preguntas frecuentes para ver si ya ha sido resuelta, de lo contrario por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que represente al grupo y que no est\u00e9 ya en los grupos existentes. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que al hacer esto pueden tener acceso al repositorio del otro miembro del grupo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): 1 git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3. Estructura del Proyecto Cuando hayan clonado el repositorio, se van a encontrar con los siguientes archivos: 1 2 3 4 5 6 7 8 9 10 11 Makefile part1.c part2.c README.md riscv.c riscvcode/ riscv.h autograder.json types.h utils.c utils.h Los \u00fanicos archivos que pueden modificar son: part1.c : Este es el archivo que van a modificar en la parte 1 del proyecto. utils.c : Archivo auxiliar que contendr\u00e1 varias funciones de ayuda para la parte 1 y 2 del proyecto. part2.c : Este es el archivo que van a modificar en la parte 2 del proyecto. Ustedes NO pueden crear otros archivos ni crear archivos de cabecera .h . Si necesitan agregar funciones de ayuda, por favor col\u00f3quenlas en los archivos C correspondientes ( utils.c , part1.c , part2.c ). Si ustedes no siguen estas recomendaciones, su c\u00f3digo no va a compilar en el autograder y obtendr\u00e1n 0 como nota . Otros archivos que necesitan consultar detenidamente para entender el proyecto: type.h : Archivo de cabecera que tiene los tipos de datos que ustedes van a utilizar. Makefile : Para compilar y probar su c\u00f3digo. riscvcode/* : Archivos para hacer algunas pruebas. utils.h : Archivo que contiene el formato de las instrucciones a ser utilizadas en la parte 1 del proyecto. Archivos que no es necesario que los revisen, pero si son curiosos: riscv.h : tiene declaraciones de funciones que se utilizan en la parte 1 y 2 del proyecto. riscv.c : programa encargado de probar la parte 1 y 2 del proyecto, el simulador como tal. El emulador de RISC-V Los archivos proporcionados en el repositorio que crearon con GitHub Classroom son la base para un emulador de RISC-V. Primero, ustedes deber\u00e1n agregar c\u00f3digo en part1.c y utils.c para imprimir las instrucciones en ensamblador correspondientes al c\u00f3digo de m\u00e1quina (binario). Una vez realizaron esto, ustedes completar\u00e1n el programa agregando c\u00f3digo en el archivo parte2.c para ejecutar cada instrucci\u00f3n (incluyendo los accesos a memoria). Su simulador debe de ser capaz de entender cada una de las instrucciones siguientes ya codificadas en c\u00f3digo de m\u00e1quina (binario), nosotros ya les damos una tabla de los tipos de instrucciones que debe de ser capaz de manejar su emulador. Es muy IMPORTANTE que ustedes lean y entiendan las definiciones encontradas en types.h antes de empezar su proyecto. Si tiene alguna duda, o encuentran algo que no entiendan respecto a las mismas consulten el cap\u00edtulo 6 de K&R, que habla sobre estructuras, bitfields y uniones . Set de Instrucciones El set de instrucciones que su emulador debe soportar esta listado a continuaci\u00f3n. Toda la informaci\u00f3n ac\u00e1 es copiada desde RISC-V green card , como ayuda adicional pueden utilizar la hoja proporcionada anteriormente. Tipo R FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO R R-TYPE funct7 rs2 rs1 funct3 rd opcode Bits 7 5 5 3 5 7 INTRUCCIONES TIPO R (OPCODE 0x33) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N add rd , rs1 , rs2 0x0 0x00 R [ rd ] < - R [ rs1 ] + R [ rs2 ] mul rd , rs1 , rs2 0x0 0x01 R [ rd ] < -( R [ rs1 ] * R [ rs2 ]) [31:0] sub rd , rs1 , rs2 0x0 0x20 R [ rd ] < - R [ rs1 ] - R [ rs2 ] sll rd , rs1 , rs2 0x1 0x00 R [ rd ] < - R [ rs1 ] < < R [ rs2 ] mulh rd , rs1 , rs2 0x1 0x01 R [ rd ] < -( R [ rs1 ] * R [ rs2 ]) [63:32] slt rd , rs1 , rs2 0x2 0x00 R [ rd ] < -( R [ rs1 ] < R [ rs2 ]) ? 1 : 0 xor rd , rs1 , rs2 0x4 0x00 R [ rd ] < - R [ rs1 ] ^ R [ rs2 ] div rd , rs1 , rs2 0x4 0x01 R [ rd ] < - R [ rs1 ] / R [ rs2 ] srl rd , rs1 , rs2 0x5 0x00 R [ rd ] < - R [ rs1 ] >> R [ rs2 ] sra rd , rs1 , rs2 0x5 0x20 R [ rd ] < - R [ rs1 ] >> R [ rs2 ] or rd , rs1 , rs2 0x6 0x00 R [ rd ] < - R [ rs1 ] | R [ rs2 ] rem rd , rs1 , rs2 0x6 0x01 R [ rd ] < - R [ rs1 ] % R [ rs2 ] and rd , rs1 , rs2 0x7 0x00 R [ rd ] < - R [ rs1 ] & R [ rs2 ] Tipo I FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO I I-TYPE imm[11:0] rs1 funct3 rd opcode Bits 12 5 3 5 7 INTRUCCIONES TIPO I (OPCODE 0x03) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lb rd, offset ( rs1 ) 0x0 R [ rd ] < - SignExt(Mem( R [ rs1 ] + offset , byte )) lh rd, offset ( rs1 ) 0x1 R [ rd ] < - SignExt(Mem( R [ rs1 ] + offset , half )) lw rd, offset ( rs1 ) 0x2 R [ rd ] < - Mem( R [ rs1 ] + offset , word ) INTRUCCIONES TIPO I (OPCODE 0x13) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N addi rd, rs1, imm 0x0 R [ rd ] < - R [ rs1 ] + imm slli rd, rs1, imm 0x1 0x00 R [ rd ] < - R [ rs1 ] < < imm slti rd, rs1, imm 0x2 R [ rd ] < - ( R [ rs1 ] < imm ) ? 1 : 0 xori rd, rs1, imm 0x4 R [ rd ] < - R [ rs1 ] ^ imm srli rd, rs1, imm 0x5 0x00 R [ rd ] < - R [ rs1 ] >> imm srai rd, rs1, imm 0x5 0x20 R [ rd ] < - R [ rs1 ] >> imm ori rd, rs1, imm 0x6 R [ rd ] < - R [ rs1 ] | imm andi rd, rs1, imm 0x7 R [ rd ] < - R [ rs1 ] & imm INTRUCCIONES TIPO I (OPCODE 0x67) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jalr 0x0 R [ rd ] < - PC + 4 PC < - R [ rs1 ] + imm INTRUCCIONES TIPO I (OPCODE 0x73) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N ecall 0x0 0x000 (Transfiere el control al Sistema Operativo) a0 = 1 imprime el valor contenido en a1 como entero. a0 = 10 es exit o un indicador de final de c\u00f3digo. Tipo S FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO S S-TYPE imm[11:5] rs2 rs1 funct3 imm[4:0] opcode Bits 7 5 5 3 5 7 INTRUCCIONES TIPO S (OPCODE 0x23) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N sb rs2 , offset ( rs1 ) 0x0 Mem( R [ rs1 ] + offset ) < - R [ rs2 ][7:0] sh rs2 , offset ( rs1 ) 0x1 Mem( R [ rs1 ] + offset ) < - R [ rs2 ][15:0] sw rs2 , offset ( rs1 ) 0x2 Mem( R [ rs1 ] + offset ) < - R [ rs2 ] Tipo SB FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO SB SB-TYPE imm[12] imm[10:5] rs2 rs1 funct3 imm[4:1] imm[11] opcode Bits 1 6 5 5 3 4 1 7 INTRUCCIONES TIPO SB (OPCODE 0x63) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N beq rs1 , rs2 , offset 0x0 if( R [ rs1 ] == R [ rs2 ]) PC < - PC + { offset , 1b'0} bne rs1 , rs2 , offset 0x1 if( R [ rs1 ] != R [ rs2 ]) PC < - PC + { offset , 1b'0} Tipo U FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO U U-TYPE imm[31:12] rd opcode Bits 20 5 7 INTRUCCIONES TIPO U (OPCODE 0x17) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N auipc rd , offset R [ rd ] < - PC + { offset , 12b'0} INTRUCCIONES TIPO U (OPCODE 0x37) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lui rd , offset R [ rd ] < - { offset , 12b'0} Tipo UJ FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO UJ UJ-TYPE imm[20] imm[10:1] imm[11] imm[19:12] rd opcode Bits 1 10 1 8 5 7 INTRUCCIONES TIPO UJ (OPCODE 0x6F) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jal rd , imm R [ rd ] < - PC + 4 PC < - PC + { imm , 1b'0} Al igual que la arquitectura RISC-V normal, el sistema RISC-V que est\u00e1n implementando es little-endian. Esto significa que cuando se le da un valor compuesto de m\u00faltiples bytes, el byte menos significativo se almacena en la direcci\u00f3n m\u00e1s baja. Consulten la p\u00e1gina B-43 de P&H (4\u00aa edici\u00f3n) para obtener informaci\u00f3n sobre endianness. Estructura del C\u00f3digo El c\u00f3digo base que les fue proporcionado funciona de la siguiente manera: Lee los programas en c\u00f3digo de m\u00e1quina que se encuentran en la memoria (Empezando en la direcci\u00f3n 0x01000 ). Para \"ejecutar\" el programa este es pasado como un par\u00e1metro en la l\u00ednea de comandos. Cada programa tiene 1 MiB de memoria y la unidad m\u00ednima de direccionamiento son los bytes. Todos los registros de RISC-V son inicializados en 0 y el program counter ( pc ) hacia la direcci\u00f3n 0x01000 . Las \u00fanicas excepciones a las inicializaciones antes mencionadas son el stack pointer ( sp ) que tiene un valor inicial de 0xEFFFF y el global pointer ( gp ) que tiene un valor inicial de 0x03000 . En el contexto de su emulador, el global pointer hace referencia a la secci\u00f3n est\u00e1tica de su memoria. Los registros y el program counter est\u00e1n definidos en el Processor struct definido en types.h . Se definieron banderas con las cuales puede manejar la interacci\u00f3n con el usuario. Dependiendo de la opci\u00f3n especificada en la l\u00ednea de comandos, el simulador mostrar\u00e1 un dissassembly dump ( -d ) o se ejecutar\u00e1 el programa. Habr\u00e1 m\u00e1s informaci\u00f3n sobre las opciones de l\u00ednea de comandos m\u00e1s adelante. Lo que prosigue es qu\u00e9 entra al flujo de simulaci\u00f3n principal, el cual ejecuta una \u00fanica instrucci\u00f3n repetitivamente hasta que la simulaci\u00f3n se completa. La ejecuci\u00f3n de una instrucci\u00f3n realiza las siguientes tareas: Trae una instrucci\u00f3n desde la memoria, usando el pc como direcci\u00f3n ( fetch ). Examina el opcode/funct3 para determinar que instrucci\u00f3n es ( decode ). Ejecuta la instrucci\u00f3n y actualiza el pc ( execute ). Opciones en la l\u00ednea de comandos -i : Corre el simulador en modo interactivo ( interactive ), es decir que se ejecutar\u00e1 una instrucci\u00f3n a la vez al presionar enter . Cada instrucci\u00f3n es mostrada en su forma desensamblada. -t : Corre el simulador en modo rastreo ( trace ), en donde cada instrucci\u00f3n es ejecutada y es mostrada al usuario. -r : Indica al simulador que imprima el contenido de los 32 registros despu\u00e9s de que es ejecutada cada instrucci\u00f3n. Esta opci\u00f3n es m\u00e1s \u00fatil cuando se combina con la opci\u00f3n -i . -d : Indica al simulador que desensamble el programa completo y que termine sin ejecutarlo. En la parte 2, ustedes deber\u00e1n implementar los siguientes m\u00e9todos: El execute_instruction() . Los diferentes executes . El store() . El load() . Para cuando ustedes hayan terminado la implementaci\u00f3n de todos los m\u00e9todos, el simulador ser\u00e1 capaz de manejar todas las instrucciones de la tabla anterior. Parte 1 Su primera tarea es implementar un desensamblador al completar el m\u00e9todo decode_instruction() en el archivo part1.c junto a otras funciones. El objetivo de esta parte, es que, dada una instrucci\u00f3n en c\u00f3digo de m\u00e1quina, ustedes deber\u00e1n traducirla a su instrucci\u00f3n en lenguaje ensamblador RISC-V (e.g. add x1, x2, x3 ). Para esta parte, ustedes no har\u00e1n referencia a los registros por nombre sino por su n\u00famero (como est\u00e1 definido en RISC-V Green Card ). Cuando impriman las instrucciones revisen las constantes definidas en utils.h , ya que estas le pueden ser de ayuda. M\u00e1s detalles sobre los requisitos a continuaci\u00f3n. Requisitos Parte 1 Imprimir el nombre de la instrucci\u00f3n. Si la instrucci\u00f3n tiene argumentos, impriman un tab ( \\t ). Imprimir todos los argumentos, siguiendo el orden y formato dado en la columna de INSTRUCCI\u00d3N de las tablas mostradas anteriormente. Los argumentos son generalmente separados por coma ( lw / sw , usan tambi\u00e9n par\u00e9ntesis), pero no est\u00e1n separados por espacios. Ustedes encontrar\u00e1n de ayuda revisar el archivo utils.h . Los registros que son argumentos de la instrucci\u00f3n son impresos con una x seguido del n\u00famero de registro, en decimal. (e.g. x0 o x31 ) Todos los inmediatos deben mostrarse como un n\u00famero decimal con signo. Los corrimientos (e.g. para slli ) se imprimen como n\u00fameros decimales sin signo (e.g. 0 a 31). Imprimir un salto de l\u00ednea ( \\n ) al final de cada instrucci\u00f3n. Se estar\u00e1 utilizando un autograder para calificar esta tarea. Si su output difiere del nuestro debido a errores de formato, no obtendr\u00e1n nota. Nosotros les proveemos ciertas pruebas. Sin embargo, dado que estas pruebas s\u00f3lo cubren un subconjunto de todos los escenarios posibles, pasar estas pruebas no significa que su c\u00f3digo est\u00e9 libre de errores. Ustedes deber\u00e1n identificar todos los casos y probarlos. Para completar la funcionalidad de la parte 1, deben de completar lo siguiente: La funci\u00f3n decode_instrucction() en part1.c . Los diferentes writes en part1.c . Los diferentes prints en part1.c . Los diferentes gets en utils.c . La funci\u00f3n bitSigner en utils.c . Ustedes deben de correr el test brindado para su proyecto escribiendo el siguiente comando. Si ustedes pasan el test, ver\u00e1n en su consola el siguiente output. 1 2 3 4 5 6 make part1 gcc -g -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c simple_disasm TEST PASSED! multiply_disasm TEST PASSED! random_disasm TEST PASSED! ---------Disassembly Tests Complete--------- Probando la Parte 1 Los tests que se les dieron no eval\u00faan todas las posibilidades, por eso mismo ustedes pueden ( deben ) crear sus propios archivos de prueba para comprobar su funcionamiento. Si ustedes desean correr un test en espec\u00edfico, pueden usar el siguiente comando para ello: 1 make [test_name]_disasm Para crear sus propios archivos de prueba, primero necesitar\u00e1n crear c\u00f3digo de m\u00e1quina. Para ello pueden ayudarse de V-Sim o hacerlo a mano. Si utilizan V-Sim tienen que crear un archivo .s y hacer un dump del c\u00f3digo de m\u00e1quina utilizando la bandera -code en la terminal: 1 jupiter <archivo>.s --dump-code <test_name>.input Recuerde que Jupiter requiere el .global start y la etiqueta start: para poder ensamblar. Luego que hizo el --dump-code entre al archivo generado y elimine las primeras dos l\u00edneas, estas corresponden al __start y su proyecto no necesita preocuparse de esto. Ustedes deben de poner las instrucciones en c\u00f3digo de m\u00e1quina en un archivo llamado [test_name].input y colocar el archivo dentro de la carpeta riscvcode/code . Despu\u00e9s, deben crear el archivo [test_name].solution el cual contendr\u00e1 las instrucciones que se espera obtener; y colocar el archivo en la carpeta riscvcode/ref . Vean las pruebas proporcionadas como ejemplos de este tipo de archivos. Para integrar sus pruebas en el comando make , ustedes deben de modificar el archivo Makefile . En la l\u00ednea 4 del archivo Makefile , donde dice ASM_TESTS , agregar [test_name] a la lista con espacios entre cada nombre de archivo: 1 2 3 4 SOURCES := utils.c part1.c part2.c riscv.c HEADERS := types.h utils.h riscv.h ASM_TESTS := simple multiply random test_name Si su instrucci\u00f3n desensamblada no es igual a la esperada, ustedes obtendr\u00e1n la diferencia entre el output esperado y el output que devolvieron. Aseg\u00farense de al menos pasar esta prueba antes de enviar la parte 1 al autograder . 1 2 3 4 5 # Output Esperado < 00001014 : lui x8, 1048575 --- # Output Devuelto > 00001014 : Invalid Instruction: 0xfffff437 Calificaci\u00f3n Parte 1 Recuerden que para la primera parte, s\u00f3lo deben modificar los archivos part1.c y utils.c , esto representa el 50% de su nota as\u00ed que pueden enviar sus archivos al autograder para verificar su nota de esta parte haciendo: 1 2 pip3 install --upgrade autograders-cli autograder --upload Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tienen que clonar el repositorio y hacer upload haciendo login con su correo de galileo . Parte 2 Su segunda tarea es completar el emulador implementando los m\u00e9todos execute_instruction() . execute() 's, store() y load() del archivo part2.c . Requisitos Esta parte consistir\u00e1 en implementar la funcionalidad de cada instrucci\u00f3n. Por favor implementen las funciones descritas a continuaci\u00f3n (todas en part2.c ): execute_instruction() : Ejecuta la instrucci\u00f3n proporcionada como par\u00e1metro. Esta deber\u00eda modificar los registros apropiados, realizar las llamadas a memoria necesarias y actualizar el program counter para apuntar a la siguiente instrucci\u00f3n a ejecutar. execute() 's: Varias funciones de ayuda para ser llamadas en ciertas condiciones para ciertas instrucciones. Es su decisi\u00f3n usar estas funciones, pero estas les ayudar\u00e1n de gran manera a organizar el c\u00f3digo. store() : Toma una direcci\u00f3n, un tama\u00f1o, un valor y almacena los primeros (tama\u00f1o) bytes del valor dado en la direcci\u00f3n dada. Cuando el par\u00e1metro check_align sea 1 se validar\u00e1n las restricciones de alineaci\u00f3n. Se incluy\u00f3 este par\u00e1metro para obligar a las instrucciones a estar alineadas por palabras de memoria (word-aligned). Cuando implementen el store y load , este par\u00e1metro debe ser 0 dado que RISC-V no hace cumplir las restricciones de alineaci\u00f3n. load() : Toma una direcci\u00f3n y un tama\u00f1o, y retorna los siguientes (tama\u00f1o) bytes empezando en la direcci\u00f3n dada. El check_align funciona de la misma forma que en store() . Probando la Parte 2 Les hemos adjuntado un self-checking assembly test que prueba varias de las instruciones, sin embargo este test no es exhaustivo y no prueba todas las instrucciones. A continuaci\u00f3n, se ejemplifica c\u00f3mo ejecutar los test (el output es de una soluci\u00f3n correcta). 1 2 3 4 5 6 make part2 gcc -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c simple_execute TEST PASSED! multiply_execute TEST PASSED! random_execute TEST PASSED! -----------Execute Tests Complete----------- Lo m\u00e1s probable es que ustedes tenga errores al empezar a realizar la parte 2, entonces prueben el modo de rastreo ( trace ) descrito en Opciones en la l\u00ednea de Comandos . Les hemos dado unos cuantos tests m\u00e1s, adem\u00e1s de la posibilidad de escribir test propios. Como en la parte 1, ustedes tendr\u00e1n que crear archivos .input . Sin embargo, para la parte 2, ustedes deber\u00e1n nombrar su archivo soluci\u00f3n con una extensi\u00f3n .trace . Creen el nuevo archivo de ensamblador en el directorio riscvcode (utilicen riscvcode/simple.input como plantilla). Agreguen el nombre base del test a la lista de ASM_TESTS en el Makefile . Para realizar esto s\u00f3lo agreguen [test_name] al final de la l\u00ednea 4. Ahora compilen su test de ensamblador y ejec\u00fatenlo escribiendo el siguiente comando: 1 make [ test_name ] _execute Ustedes pueden, y en efecto deben, escribir sus propios test para probar instrucciones espec\u00edficas y todos los posibles casos. Adem\u00e1s, ustedes deben compilar y probar su c\u00f3digo despu\u00e9s de cada grupo de instrucciones implementadas. De lo contrario ser\u00e1 muy dif\u00edcil probar su proyecto si esperan hasta el final. Calificaci\u00f3n Parte 2 Al completar esta parte ustedes s\u00f3lo deber\u00edan haber modificado los archivos part1.c , part2.c y utils.c , deben realizar commit de todos los cambios realizados y enviar el link de su repositorio por medio del GES. Para obtener su nota completa tienen que hacer: 1 2 pip3 install --upgrade autograders-cli autograder --upload Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tienen que clonar el repositorio y hacer upload haciendo login con su correo de galileo . Preguntas Frecuentes 1. \u00bfC\u00f3mo puedo empezar? Lo mejor es revisar types.h y analizar la estructura Instruction para empezar a trabajar en la parte1.c , por ejemplo como acceder a cada campo de cada diferente tipo de instrucci\u00f3n y al opcode tambi\u00e9n. Por ejemplo, para acceder al opcode pueden utilizar: 1 instruction . opcode siendo instruction una variable que representa una \"instancia\" de la estructura Instruction . Luego de esto, pueden ver c\u00f3mo accediendo a estos campos pueden decodificar la instrucci\u00f3n y as\u00ed lograr imprimirla. 2. En mi m\u00e1quina local saco 100% y en el autograder 0, \u00bfpor qu\u00e9? Al trabajar con uniones y estructuras de C y al utilizar la bandera -O2 pueden pasar cosas muy raras, una de ellas es el strict aliasing , por eso les recomendamos probar su c\u00f3digo en la m\u00e1quina virtual que les proporcionamos, as\u00ed est\u00e1n totalmente seguros de que c\u00f3digo funciona correctamente. 3. Me da Floating-point Exception (core dumped) al hacer algunas operaciones aritm\u00e9ticas, \u00bfpor qu\u00e9? Generalmente esto se da porque se divide por 0 o hay overflow utilizando variables enteras con signo. Por ejemplo: Division por 0 1 2 3 int x = 10; int y = 0; int z = x / y; Overflow 1 2 3 int32_t x = 0x80000000 ; int32_t y = 0xffffffff ; int32_t z = x / y ; La soluci\u00f3n para la divisi\u00f3n por 0 es simplemente tienen que devolver -1 como dice la especificaci\u00f3n de RISC-V y para el residuo devolver el primer argumento de la operaci\u00f3n, en el caso de overflow la soluci\u00f3n es castear las variables a un tipo con m\u00e1s bytes: 1 int32_t z = ( int32_t )(( int64_t ) x / ( int64_t ) y ); 4. En la parte 1 el formato nunca es el esperado por las pruebas, \u00bfpor qu\u00e9? Seguramente no est\u00e1n utilizando el formato correcto, les recomendamos que utilicen las siguientes macros para imprimir las instrucciones que se encuentran en el archivo utils.h : 1 2 3 4 5 6 7 8 9 #define RTYPE_FORMAT \"%s\\tx%d, x%d, x%d\\n\" #define ITYPE_FORMAT \"%s\\tx%d, x%d, %d\\n\" #define JALR_FORMAT \"jalr\\tx%d, x%d, %d\\n\" #define MEM_FORMAT \"%s\\tx%d, %d(x%d)\\n\" #define AUIPC_FORMAT \"auipc\\tx%d, %d\\n\" #define LUI_FORMAT \"lui\\tx%d, %d\\n\" #define JAL_FORMAT \"jal\\tx%d, %d\\n\" #define BRANCH_FORMAT \"%s\\tx%d, x%d, %d\\n\" #define ECALL_FORMAT \"ecall\\n\" 5. \u00bfPuedo crear mis propias funciones? S\u00ed, siempre y cuando estas est\u00e9n declaradas, ya sea en part1.c , part2.c o utils.c , ya que son los \u00fanicos archivos que se env\u00edan al autograder. Sin embargo, NO est\u00e1 permitido renombrar o eliminar las siguientes funciones : 1 2 3 4 5 6 7 /* archivo part1.c */ void decode_instruction ( Instruction i ); /* archivo part2.c */ void execute_instruction ( Instruction instruction , Processor * processor , Byte * memory ); void store ( Byte * memory , Address address , Alignment alignment , Word value , int ); Word load ( Byte * memory , Address address , Alignment alignment , int ); Ya que el simulador riscv.c espera que estas est\u00e9n definidas.","title":"Proyecto 1: C y RISC-V"},{"location":"projects/pj01/#proyecto-1-c-y-risc-v","text":"","title":"Proyecto 1: C y RISC-V"},{"location":"projects/pj01/#objetivos","text":"Mejorar sus habilidades de programaci\u00f3n en C. Conocer algunos de los detalles de RISC-V. Prepararse para lo que viene m\u00e1s adelante en el curso.","title":"Objetivos"},{"location":"projects/pj01/#requisitos-de-conocimiento","text":"Para realizar este proyecto ustedes tienen que tener claros algunos conceptos, de lo contrario ser\u00e1 bastante dif\u00edcil e inc\u00f3modo empezar a trabajar. Les recomendamos que antes de empezar est\u00e9n totalmente seguros que dominan al 100% los siguientes puntos: Operaciones binarias en C ( xor , or , and , etc). Operaciones aritm\u00e9ticas con signo y sin signo en C. Type casting en C. Control de flujo en C ( switch , if , etc). Funciones en C. Entender qu\u00e9 son las estructuras ( struct ) en C. Entender c\u00f3mo funcionan las uniones ( union ) en C. Uso correcto de printf . Entender la estructura del set de instrucciones de RISC-V. Programar en lenguaje ensamblador RISC-V. Si creen que no tienen claro alguno de estos temas al 100%, por favor no duden en ir a consultar los libros y material correspondiente del curso, por ejemplo K&R , es indispensable. En Lecturas Recomendadas pueden encontrar algunas lecturas que tocan los puntos antes mencionados y otras cosas que tambi\u00e9n les pueden servir, nunca est\u00e1 dem\u00e1s tener un poco m\u00e1s de informaci\u00f3n.","title":"Requisitos de Conocimiento"},{"location":"projects/pj01/#lecturas-recomendadas","text":"Gu\u00eda Pr\u00e1ctica de RISC-V: 2 K&R: 6 P&H: B-43","title":"Lecturas Recomendadas"},{"location":"projects/pj01/#introduccion","text":"En este proyecto ustedes deben de crear un emulador que pueda ejecutar un subconjunto de instrucciones de RISC-V . Ustedes se van a encargar de hacer un programa que decodifique y ejecute varias instrucciones de RISC-V. Consid\u00e9renlo como una versi\u00f3n miniatura de Jupiter .","title":"Introducci\u00f3n"},{"location":"projects/pj01/#risc-v-green-card","text":"Aqu\u00ed hay dos RISC-V Green Cards que pueden consultar y as\u00ed tener m\u00e1s herramientras que les pueden ayudar a completar el proyecto. La primera tiene informaci\u00f3n acerca de los opcodes y otros campos de cada uno de los diferentes formatos de instrucci\u00f3n, por lo que esta ser\u00eda su mejor opci\u00f3n.","title":"RISC-V Green Card"},{"location":"projects/pj01/#preparacion","text":"Antes de comenzar aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta pueden consultar la secci\u00f3n de preguntas frecuentes para ver si ya ha sido resuelta, de lo contrario por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que represente al grupo y que no est\u00e9 ya en los grupos existentes. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que al hacer esto pueden tener acceso al repositorio del otro miembro del grupo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): 1 git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3.","title":"Preparaci\u00f3n"},{"location":"projects/pj01/#estructura-del-proyecto","text":"Cuando hayan clonado el repositorio, se van a encontrar con los siguientes archivos: 1 2 3 4 5 6 7 8 9 10 11 Makefile part1.c part2.c README.md riscv.c riscvcode/ riscv.h autograder.json types.h utils.c utils.h Los \u00fanicos archivos que pueden modificar son: part1.c : Este es el archivo que van a modificar en la parte 1 del proyecto. utils.c : Archivo auxiliar que contendr\u00e1 varias funciones de ayuda para la parte 1 y 2 del proyecto. part2.c : Este es el archivo que van a modificar en la parte 2 del proyecto. Ustedes NO pueden crear otros archivos ni crear archivos de cabecera .h . Si necesitan agregar funciones de ayuda, por favor col\u00f3quenlas en los archivos C correspondientes ( utils.c , part1.c , part2.c ). Si ustedes no siguen estas recomendaciones, su c\u00f3digo no va a compilar en el autograder y obtendr\u00e1n 0 como nota . Otros archivos que necesitan consultar detenidamente para entender el proyecto: type.h : Archivo de cabecera que tiene los tipos de datos que ustedes van a utilizar. Makefile : Para compilar y probar su c\u00f3digo. riscvcode/* : Archivos para hacer algunas pruebas. utils.h : Archivo que contiene el formato de las instrucciones a ser utilizadas en la parte 1 del proyecto. Archivos que no es necesario que los revisen, pero si son curiosos: riscv.h : tiene declaraciones de funciones que se utilizan en la parte 1 y 2 del proyecto. riscv.c : programa encargado de probar la parte 1 y 2 del proyecto, el simulador como tal.","title":"Estructura del Proyecto"},{"location":"projects/pj01/#el-emulador-de-risc-v","text":"Los archivos proporcionados en el repositorio que crearon con GitHub Classroom son la base para un emulador de RISC-V. Primero, ustedes deber\u00e1n agregar c\u00f3digo en part1.c y utils.c para imprimir las instrucciones en ensamblador correspondientes al c\u00f3digo de m\u00e1quina (binario). Una vez realizaron esto, ustedes completar\u00e1n el programa agregando c\u00f3digo en el archivo parte2.c para ejecutar cada instrucci\u00f3n (incluyendo los accesos a memoria). Su simulador debe de ser capaz de entender cada una de las instrucciones siguientes ya codificadas en c\u00f3digo de m\u00e1quina (binario), nosotros ya les damos una tabla de los tipos de instrucciones que debe de ser capaz de manejar su emulador. Es muy IMPORTANTE que ustedes lean y entiendan las definiciones encontradas en types.h antes de empezar su proyecto. Si tiene alguna duda, o encuentran algo que no entiendan respecto a las mismas consulten el cap\u00edtulo 6 de K&R, que habla sobre estructuras, bitfields y uniones .","title":"El emulador de RISC-V"},{"location":"projects/pj01/#set-de-instrucciones","text":"El set de instrucciones que su emulador debe soportar esta listado a continuaci\u00f3n. Toda la informaci\u00f3n ac\u00e1 es copiada desde RISC-V green card , como ayuda adicional pueden utilizar la hoja proporcionada anteriormente.","title":"Set de Instrucciones"},{"location":"projects/pj01/#tipo-r","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO R R-TYPE funct7 rs2 rs1 funct3 rd opcode Bits 7 5 5 3 5 7 INTRUCCIONES TIPO R (OPCODE 0x33) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N add rd , rs1 , rs2 0x0 0x00 R [ rd ] < - R [ rs1 ] + R [ rs2 ] mul rd , rs1 , rs2 0x0 0x01 R [ rd ] < -( R [ rs1 ] * R [ rs2 ]) [31:0] sub rd , rs1 , rs2 0x0 0x20 R [ rd ] < - R [ rs1 ] - R [ rs2 ] sll rd , rs1 , rs2 0x1 0x00 R [ rd ] < - R [ rs1 ] < < R [ rs2 ] mulh rd , rs1 , rs2 0x1 0x01 R [ rd ] < -( R [ rs1 ] * R [ rs2 ]) [63:32] slt rd , rs1 , rs2 0x2 0x00 R [ rd ] < -( R [ rs1 ] < R [ rs2 ]) ? 1 : 0 xor rd , rs1 , rs2 0x4 0x00 R [ rd ] < - R [ rs1 ] ^ R [ rs2 ] div rd , rs1 , rs2 0x4 0x01 R [ rd ] < - R [ rs1 ] / R [ rs2 ] srl rd , rs1 , rs2 0x5 0x00 R [ rd ] < - R [ rs1 ] >> R [ rs2 ] sra rd , rs1 , rs2 0x5 0x20 R [ rd ] < - R [ rs1 ] >> R [ rs2 ] or rd , rs1 , rs2 0x6 0x00 R [ rd ] < - R [ rs1 ] | R [ rs2 ] rem rd , rs1 , rs2 0x6 0x01 R [ rd ] < - R [ rs1 ] % R [ rs2 ] and rd , rs1 , rs2 0x7 0x00 R [ rd ] < - R [ rs1 ] & R [ rs2 ]","title":"Tipo R"},{"location":"projects/pj01/#tipo-i","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO I I-TYPE imm[11:0] rs1 funct3 rd opcode Bits 12 5 3 5 7 INTRUCCIONES TIPO I (OPCODE 0x03) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lb rd, offset ( rs1 ) 0x0 R [ rd ] < - SignExt(Mem( R [ rs1 ] + offset , byte )) lh rd, offset ( rs1 ) 0x1 R [ rd ] < - SignExt(Mem( R [ rs1 ] + offset , half )) lw rd, offset ( rs1 ) 0x2 R [ rd ] < - Mem( R [ rs1 ] + offset , word ) INTRUCCIONES TIPO I (OPCODE 0x13) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N addi rd, rs1, imm 0x0 R [ rd ] < - R [ rs1 ] + imm slli rd, rs1, imm 0x1 0x00 R [ rd ] < - R [ rs1 ] < < imm slti rd, rs1, imm 0x2 R [ rd ] < - ( R [ rs1 ] < imm ) ? 1 : 0 xori rd, rs1, imm 0x4 R [ rd ] < - R [ rs1 ] ^ imm srli rd, rs1, imm 0x5 0x00 R [ rd ] < - R [ rs1 ] >> imm srai rd, rs1, imm 0x5 0x20 R [ rd ] < - R [ rs1 ] >> imm ori rd, rs1, imm 0x6 R [ rd ] < - R [ rs1 ] | imm andi rd, rs1, imm 0x7 R [ rd ] < - R [ rs1 ] & imm INTRUCCIONES TIPO I (OPCODE 0x67) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jalr 0x0 R [ rd ] < - PC + 4 PC < - R [ rs1 ] + imm INTRUCCIONES TIPO I (OPCODE 0x73) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N ecall 0x0 0x000 (Transfiere el control al Sistema Operativo) a0 = 1 imprime el valor contenido en a1 como entero. a0 = 10 es exit o un indicador de final de c\u00f3digo.","title":"Tipo I"},{"location":"projects/pj01/#tipo-s","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO S S-TYPE imm[11:5] rs2 rs1 funct3 imm[4:0] opcode Bits 7 5 5 3 5 7 INTRUCCIONES TIPO S (OPCODE 0x23) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N sb rs2 , offset ( rs1 ) 0x0 Mem( R [ rs1 ] + offset ) < - R [ rs2 ][7:0] sh rs2 , offset ( rs1 ) 0x1 Mem( R [ rs1 ] + offset ) < - R [ rs2 ][15:0] sw rs2 , offset ( rs1 ) 0x2 Mem( R [ rs1 ] + offset ) < - R [ rs2 ]","title":"Tipo S"},{"location":"projects/pj01/#tipo-sb","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO SB SB-TYPE imm[12] imm[10:5] rs2 rs1 funct3 imm[4:1] imm[11] opcode Bits 1 6 5 5 3 4 1 7 INTRUCCIONES TIPO SB (OPCODE 0x63) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N beq rs1 , rs2 , offset 0x0 if( R [ rs1 ] == R [ rs2 ]) PC < - PC + { offset , 1b'0} bne rs1 , rs2 , offset 0x1 if( R [ rs1 ] != R [ rs2 ]) PC < - PC + { offset , 1b'0}","title":"Tipo SB"},{"location":"projects/pj01/#tipo-u","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO U U-TYPE imm[31:12] rd opcode Bits 20 5 7 INTRUCCIONES TIPO U (OPCODE 0x17) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N auipc rd , offset R [ rd ] < - PC + { offset , 12b'0} INTRUCCIONES TIPO U (OPCODE 0x37) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lui rd , offset R [ rd ] < - { offset , 12b'0}","title":"Tipo U"},{"location":"projects/pj01/#tipo-uj","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO UJ UJ-TYPE imm[20] imm[10:1] imm[11] imm[19:12] rd opcode Bits 1 10 1 8 5 7 INTRUCCIONES TIPO UJ (OPCODE 0x6F) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jal rd , imm R [ rd ] < - PC + 4 PC < - PC + { imm , 1b'0} Al igual que la arquitectura RISC-V normal, el sistema RISC-V que est\u00e1n implementando es little-endian. Esto significa que cuando se le da un valor compuesto de m\u00faltiples bytes, el byte menos significativo se almacena en la direcci\u00f3n m\u00e1s baja. Consulten la p\u00e1gina B-43 de P&H (4\u00aa edici\u00f3n) para obtener informaci\u00f3n sobre endianness.","title":"Tipo UJ"},{"location":"projects/pj01/#estructura-del-codigo","text":"El c\u00f3digo base que les fue proporcionado funciona de la siguiente manera: Lee los programas en c\u00f3digo de m\u00e1quina que se encuentran en la memoria (Empezando en la direcci\u00f3n 0x01000 ). Para \"ejecutar\" el programa este es pasado como un par\u00e1metro en la l\u00ednea de comandos. Cada programa tiene 1 MiB de memoria y la unidad m\u00ednima de direccionamiento son los bytes. Todos los registros de RISC-V son inicializados en 0 y el program counter ( pc ) hacia la direcci\u00f3n 0x01000 . Las \u00fanicas excepciones a las inicializaciones antes mencionadas son el stack pointer ( sp ) que tiene un valor inicial de 0xEFFFF y el global pointer ( gp ) que tiene un valor inicial de 0x03000 . En el contexto de su emulador, el global pointer hace referencia a la secci\u00f3n est\u00e1tica de su memoria. Los registros y el program counter est\u00e1n definidos en el Processor struct definido en types.h . Se definieron banderas con las cuales puede manejar la interacci\u00f3n con el usuario. Dependiendo de la opci\u00f3n especificada en la l\u00ednea de comandos, el simulador mostrar\u00e1 un dissassembly dump ( -d ) o se ejecutar\u00e1 el programa. Habr\u00e1 m\u00e1s informaci\u00f3n sobre las opciones de l\u00ednea de comandos m\u00e1s adelante. Lo que prosigue es qu\u00e9 entra al flujo de simulaci\u00f3n principal, el cual ejecuta una \u00fanica instrucci\u00f3n repetitivamente hasta que la simulaci\u00f3n se completa. La ejecuci\u00f3n de una instrucci\u00f3n realiza las siguientes tareas: Trae una instrucci\u00f3n desde la memoria, usando el pc como direcci\u00f3n ( fetch ). Examina el opcode/funct3 para determinar que instrucci\u00f3n es ( decode ). Ejecuta la instrucci\u00f3n y actualiza el pc ( execute ).","title":"Estructura del C\u00f3digo"},{"location":"projects/pj01/#opciones-en-la-linea-de-comandos","text":"-i : Corre el simulador en modo interactivo ( interactive ), es decir que se ejecutar\u00e1 una instrucci\u00f3n a la vez al presionar enter . Cada instrucci\u00f3n es mostrada en su forma desensamblada. -t : Corre el simulador en modo rastreo ( trace ), en donde cada instrucci\u00f3n es ejecutada y es mostrada al usuario. -r : Indica al simulador que imprima el contenido de los 32 registros despu\u00e9s de que es ejecutada cada instrucci\u00f3n. Esta opci\u00f3n es m\u00e1s \u00fatil cuando se combina con la opci\u00f3n -i . -d : Indica al simulador que desensamble el programa completo y que termine sin ejecutarlo. En la parte 2, ustedes deber\u00e1n implementar los siguientes m\u00e9todos: El execute_instruction() . Los diferentes executes . El store() . El load() . Para cuando ustedes hayan terminado la implementaci\u00f3n de todos los m\u00e9todos, el simulador ser\u00e1 capaz de manejar todas las instrucciones de la tabla anterior.","title":"Opciones en la l\u00ednea de comandos"},{"location":"projects/pj01/#parte-1","text":"Su primera tarea es implementar un desensamblador al completar el m\u00e9todo decode_instruction() en el archivo part1.c junto a otras funciones. El objetivo de esta parte, es que, dada una instrucci\u00f3n en c\u00f3digo de m\u00e1quina, ustedes deber\u00e1n traducirla a su instrucci\u00f3n en lenguaje ensamblador RISC-V (e.g. add x1, x2, x3 ). Para esta parte, ustedes no har\u00e1n referencia a los registros por nombre sino por su n\u00famero (como est\u00e1 definido en RISC-V Green Card ). Cuando impriman las instrucciones revisen las constantes definidas en utils.h , ya que estas le pueden ser de ayuda. M\u00e1s detalles sobre los requisitos a continuaci\u00f3n.","title":"Parte 1"},{"location":"projects/pj01/#requisitos-parte-1","text":"Imprimir el nombre de la instrucci\u00f3n. Si la instrucci\u00f3n tiene argumentos, impriman un tab ( \\t ). Imprimir todos los argumentos, siguiendo el orden y formato dado en la columna de INSTRUCCI\u00d3N de las tablas mostradas anteriormente. Los argumentos son generalmente separados por coma ( lw / sw , usan tambi\u00e9n par\u00e9ntesis), pero no est\u00e1n separados por espacios. Ustedes encontrar\u00e1n de ayuda revisar el archivo utils.h . Los registros que son argumentos de la instrucci\u00f3n son impresos con una x seguido del n\u00famero de registro, en decimal. (e.g. x0 o x31 ) Todos los inmediatos deben mostrarse como un n\u00famero decimal con signo. Los corrimientos (e.g. para slli ) se imprimen como n\u00fameros decimales sin signo (e.g. 0 a 31). Imprimir un salto de l\u00ednea ( \\n ) al final de cada instrucci\u00f3n. Se estar\u00e1 utilizando un autograder para calificar esta tarea. Si su output difiere del nuestro debido a errores de formato, no obtendr\u00e1n nota. Nosotros les proveemos ciertas pruebas. Sin embargo, dado que estas pruebas s\u00f3lo cubren un subconjunto de todos los escenarios posibles, pasar estas pruebas no significa que su c\u00f3digo est\u00e9 libre de errores. Ustedes deber\u00e1n identificar todos los casos y probarlos. Para completar la funcionalidad de la parte 1, deben de completar lo siguiente: La funci\u00f3n decode_instrucction() en part1.c . Los diferentes writes en part1.c . Los diferentes prints en part1.c . Los diferentes gets en utils.c . La funci\u00f3n bitSigner en utils.c . Ustedes deben de correr el test brindado para su proyecto escribiendo el siguiente comando. Si ustedes pasan el test, ver\u00e1n en su consola el siguiente output. 1 2 3 4 5 6 make part1 gcc -g -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c simple_disasm TEST PASSED! multiply_disasm TEST PASSED! random_disasm TEST PASSED! ---------Disassembly Tests Complete---------","title":"Requisitos Parte 1"},{"location":"projects/pj01/#probando-la-parte-1","text":"Los tests que se les dieron no eval\u00faan todas las posibilidades, por eso mismo ustedes pueden ( deben ) crear sus propios archivos de prueba para comprobar su funcionamiento. Si ustedes desean correr un test en espec\u00edfico, pueden usar el siguiente comando para ello: 1 make [test_name]_disasm Para crear sus propios archivos de prueba, primero necesitar\u00e1n crear c\u00f3digo de m\u00e1quina. Para ello pueden ayudarse de V-Sim o hacerlo a mano. Si utilizan V-Sim tienen que crear un archivo .s y hacer un dump del c\u00f3digo de m\u00e1quina utilizando la bandera -code en la terminal: 1 jupiter <archivo>.s --dump-code <test_name>.input Recuerde que Jupiter requiere el .global start y la etiqueta start: para poder ensamblar. Luego que hizo el --dump-code entre al archivo generado y elimine las primeras dos l\u00edneas, estas corresponden al __start y su proyecto no necesita preocuparse de esto. Ustedes deben de poner las instrucciones en c\u00f3digo de m\u00e1quina en un archivo llamado [test_name].input y colocar el archivo dentro de la carpeta riscvcode/code . Despu\u00e9s, deben crear el archivo [test_name].solution el cual contendr\u00e1 las instrucciones que se espera obtener; y colocar el archivo en la carpeta riscvcode/ref . Vean las pruebas proporcionadas como ejemplos de este tipo de archivos. Para integrar sus pruebas en el comando make , ustedes deben de modificar el archivo Makefile . En la l\u00ednea 4 del archivo Makefile , donde dice ASM_TESTS , agregar [test_name] a la lista con espacios entre cada nombre de archivo: 1 2 3 4 SOURCES := utils.c part1.c part2.c riscv.c HEADERS := types.h utils.h riscv.h ASM_TESTS := simple multiply random test_name Si su instrucci\u00f3n desensamblada no es igual a la esperada, ustedes obtendr\u00e1n la diferencia entre el output esperado y el output que devolvieron. Aseg\u00farense de al menos pasar esta prueba antes de enviar la parte 1 al autograder . 1 2 3 4 5 # Output Esperado < 00001014 : lui x8, 1048575 --- # Output Devuelto > 00001014 : Invalid Instruction: 0xfffff437","title":"Probando la Parte 1"},{"location":"projects/pj01/#calificacion-parte-1","text":"Recuerden que para la primera parte, s\u00f3lo deben modificar los archivos part1.c y utils.c , esto representa el 50% de su nota as\u00ed que pueden enviar sus archivos al autograder para verificar su nota de esta parte haciendo: 1 2 pip3 install --upgrade autograders-cli autograder --upload Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tienen que clonar el repositorio y hacer upload haciendo login con su correo de galileo .","title":"Calificaci\u00f3n Parte 1"},{"location":"projects/pj01/#parte-2","text":"Su segunda tarea es completar el emulador implementando los m\u00e9todos execute_instruction() . execute() 's, store() y load() del archivo part2.c .","title":"Parte 2"},{"location":"projects/pj01/#requisitos","text":"Esta parte consistir\u00e1 en implementar la funcionalidad de cada instrucci\u00f3n. Por favor implementen las funciones descritas a continuaci\u00f3n (todas en part2.c ): execute_instruction() : Ejecuta la instrucci\u00f3n proporcionada como par\u00e1metro. Esta deber\u00eda modificar los registros apropiados, realizar las llamadas a memoria necesarias y actualizar el program counter para apuntar a la siguiente instrucci\u00f3n a ejecutar. execute() 's: Varias funciones de ayuda para ser llamadas en ciertas condiciones para ciertas instrucciones. Es su decisi\u00f3n usar estas funciones, pero estas les ayudar\u00e1n de gran manera a organizar el c\u00f3digo. store() : Toma una direcci\u00f3n, un tama\u00f1o, un valor y almacena los primeros (tama\u00f1o) bytes del valor dado en la direcci\u00f3n dada. Cuando el par\u00e1metro check_align sea 1 se validar\u00e1n las restricciones de alineaci\u00f3n. Se incluy\u00f3 este par\u00e1metro para obligar a las instrucciones a estar alineadas por palabras de memoria (word-aligned). Cuando implementen el store y load , este par\u00e1metro debe ser 0 dado que RISC-V no hace cumplir las restricciones de alineaci\u00f3n. load() : Toma una direcci\u00f3n y un tama\u00f1o, y retorna los siguientes (tama\u00f1o) bytes empezando en la direcci\u00f3n dada. El check_align funciona de la misma forma que en store() .","title":"Requisitos"},{"location":"projects/pj01/#probando-la-parte-2","text":"Les hemos adjuntado un self-checking assembly test que prueba varias de las instruciones, sin embargo este test no es exhaustivo y no prueba todas las instrucciones. A continuaci\u00f3n, se ejemplifica c\u00f3mo ejecutar los test (el output es de una soluci\u00f3n correcta). 1 2 3 4 5 6 make part2 gcc -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c simple_execute TEST PASSED! multiply_execute TEST PASSED! random_execute TEST PASSED! -----------Execute Tests Complete----------- Lo m\u00e1s probable es que ustedes tenga errores al empezar a realizar la parte 2, entonces prueben el modo de rastreo ( trace ) descrito en Opciones en la l\u00ednea de Comandos . Les hemos dado unos cuantos tests m\u00e1s, adem\u00e1s de la posibilidad de escribir test propios. Como en la parte 1, ustedes tendr\u00e1n que crear archivos .input . Sin embargo, para la parte 2, ustedes deber\u00e1n nombrar su archivo soluci\u00f3n con una extensi\u00f3n .trace . Creen el nuevo archivo de ensamblador en el directorio riscvcode (utilicen riscvcode/simple.input como plantilla). Agreguen el nombre base del test a la lista de ASM_TESTS en el Makefile . Para realizar esto s\u00f3lo agreguen [test_name] al final de la l\u00ednea 4. Ahora compilen su test de ensamblador y ejec\u00fatenlo escribiendo el siguiente comando: 1 make [ test_name ] _execute Ustedes pueden, y en efecto deben, escribir sus propios test para probar instrucciones espec\u00edficas y todos los posibles casos. Adem\u00e1s, ustedes deben compilar y probar su c\u00f3digo despu\u00e9s de cada grupo de instrucciones implementadas. De lo contrario ser\u00e1 muy dif\u00edcil probar su proyecto si esperan hasta el final.","title":"Probando la Parte 2"},{"location":"projects/pj01/#calificacion-parte-2","text":"Al completar esta parte ustedes s\u00f3lo deber\u00edan haber modificado los archivos part1.c , part2.c y utils.c , deben realizar commit de todos los cambios realizados y enviar el link de su repositorio por medio del GES. Para obtener su nota completa tienen que hacer: 1 2 pip3 install --upgrade autograders-cli autograder --upload Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tienen que clonar el repositorio y hacer upload haciendo login con su correo de galileo .","title":"Calificaci\u00f3n Parte 2"},{"location":"projects/pj01/#preguntas-frecuentes","text":"","title":"Preguntas Frecuentes"},{"location":"projects/pj01/#1-como-puedo-empezar","text":"Lo mejor es revisar types.h y analizar la estructura Instruction para empezar a trabajar en la parte1.c , por ejemplo como acceder a cada campo de cada diferente tipo de instrucci\u00f3n y al opcode tambi\u00e9n. Por ejemplo, para acceder al opcode pueden utilizar: 1 instruction . opcode siendo instruction una variable que representa una \"instancia\" de la estructura Instruction . Luego de esto, pueden ver c\u00f3mo accediendo a estos campos pueden decodificar la instrucci\u00f3n y as\u00ed lograr imprimirla.","title":"1. \u00bfC\u00f3mo puedo empezar?"},{"location":"projects/pj01/#2-en-mi-maquina-local-saco-100-y-en-el-autograder-0-por-que","text":"Al trabajar con uniones y estructuras de C y al utilizar la bandera -O2 pueden pasar cosas muy raras, una de ellas es el strict aliasing , por eso les recomendamos probar su c\u00f3digo en la m\u00e1quina virtual que les proporcionamos, as\u00ed est\u00e1n totalmente seguros de que c\u00f3digo funciona correctamente.","title":"2. En mi m\u00e1quina local saco 100% y en el autograder 0, \u00bfpor qu\u00e9?"},{"location":"projects/pj01/#3-me-da-floating-point-exception-core-dumped-al-hacer-algunas-operaciones-aritmeticas-por-que","text":"Generalmente esto se da porque se divide por 0 o hay overflow utilizando variables enteras con signo. Por ejemplo: Division por 0 1 2 3 int x = 10; int y = 0; int z = x / y; Overflow 1 2 3 int32_t x = 0x80000000 ; int32_t y = 0xffffffff ; int32_t z = x / y ; La soluci\u00f3n para la divisi\u00f3n por 0 es simplemente tienen que devolver -1 como dice la especificaci\u00f3n de RISC-V y para el residuo devolver el primer argumento de la operaci\u00f3n, en el caso de overflow la soluci\u00f3n es castear las variables a un tipo con m\u00e1s bytes: 1 int32_t z = ( int32_t )(( int64_t ) x / ( int64_t ) y );","title":"3. Me da Floating-point Exception (core dumped) al hacer algunas operaciones aritm\u00e9ticas, \u00bfpor qu\u00e9?"},{"location":"projects/pj01/#4-en-la-parte-1-el-formato-nunca-es-el-esperado-por-las-pruebas-por-que","text":"Seguramente no est\u00e1n utilizando el formato correcto, les recomendamos que utilicen las siguientes macros para imprimir las instrucciones que se encuentran en el archivo utils.h : 1 2 3 4 5 6 7 8 9 #define RTYPE_FORMAT \"%s\\tx%d, x%d, x%d\\n\" #define ITYPE_FORMAT \"%s\\tx%d, x%d, %d\\n\" #define JALR_FORMAT \"jalr\\tx%d, x%d, %d\\n\" #define MEM_FORMAT \"%s\\tx%d, %d(x%d)\\n\" #define AUIPC_FORMAT \"auipc\\tx%d, %d\\n\" #define LUI_FORMAT \"lui\\tx%d, %d\\n\" #define JAL_FORMAT \"jal\\tx%d, %d\\n\" #define BRANCH_FORMAT \"%s\\tx%d, x%d, %d\\n\" #define ECALL_FORMAT \"ecall\\n\"","title":"4. En la parte 1 el formato nunca es el esperado por las pruebas, \u00bfpor qu\u00e9?"},{"location":"projects/pj01/#5-puedo-crear-mis-propias-funciones","text":"S\u00ed, siempre y cuando estas est\u00e9n declaradas, ya sea en part1.c , part2.c o utils.c , ya que son los \u00fanicos archivos que se env\u00edan al autograder. Sin embargo, NO est\u00e1 permitido renombrar o eliminar las siguientes funciones : 1 2 3 4 5 6 7 /* archivo part1.c */ void decode_instruction ( Instruction i ); /* archivo part2.c */ void execute_instruction ( Instruction instruction , Processor * processor , Byte * memory ); void store ( Byte * memory , Address address , Alignment alignment , Word value , int ); Word load ( Byte * memory , Address address , Alignment alignment , int ); Ya que el simulador riscv.c espera que estas est\u00e9n definidas.","title":"5. \u00bfPuedo crear mis propias funciones?"},{"location":"projects/pj02/","text":"Proyecto 2: CPU Introducci\u00f3n En este proyecto utilizaremos Logisim para implementar un procesador de 32-bits, cuyo ISA es un subset de las instrucciones de RISC-V. Algunos componentes del proyecto ser\u00e1n m\u00e1s sencillos que los componentes de hardware verdaderos para evitar realizar trabajo repetitivo. Nuestro ISA utiliza 32 registros de 32 bits cada uno y una memoria, cuyas direcciones son de 32 bits. A continuaci\u00f3n, algunos detalles importantes que debemos leer antes de iniciar. Pueden utilizar cualquier bloque ya existente en Logisim para el proyecto. Guarden constantemente. Realicen commits y hagan push al menos una vez por cada d\u00eda que trabajen. Logisim es un excelente simulador pero ocasionalmente tiene errores, entonces hagamos caso a la indicaci\u00f3n anterior. Guarden constantemente... Trabajemos de la misma forma que en un proyecto de software: Construyamos el proyecto pieza por pieza y realicemos pruebas antes de unir un bloque con otros. Podemos construir todos los subcircuitos adicionales que necesitemos, siempre y cuando sigamos las reglas espec\u00edficas que cada parte impone (m\u00e1s de esto a continuaci\u00f3n). Se incluyen algunos tests. S\u00f3lo se debe correr el script ./check (esto seguramente tendr\u00e1n que hacerlo en Linux, se requiere Python 3.X instalado). \u00a1Necesitaremos m\u00e1s tests! Cada equipo deber\u00eda hacer sus propios tests adicionales. En la secci\u00f3n de Testing hay algunas indicaciones de c\u00f3mo hacer pruebas adicionales. Finalmente, las dos indicaciones m\u00e1s importantes: Se les dar\u00e1n algunos armazones (harnesses) a los cuales sus circuitos se conectar\u00e1n. ASEGURENSE QUE S\u00cd SE ADAPTAN DE FORMA CORRECTA, TODOS LOS TESTS FALLAR\u00c1N SI NO LO HACEN. En el camino nos hemos encontrado con algunos problemas de git merge si ambos miembros del equipo estaban trabajando en el mismo archivo; a veces git los resolv\u00eda autom\u00e1ticamente y a veces no. En Logisim es garantizado que git NO RESOLVER\u00c1 ESTO DE FORMA CORRECTA, entonces si trabajamos en equipo NO DEBEMOS MODIFICAR EL MISMO ARCHIVO AL MISMO TIEMPO Preparaci\u00f3n Antes de comenzar, aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta, por favor dir\u00edjanse a Telergam y pregunten. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que represente lo represente y que no haya sido tomado por otro. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s, lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que, al hacer esto, pueden tener acceso al repositorio del otro miembro del grupo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): 1 git clone <link del repositorio> Parte 1: Register File Como aprendimos en clase, RISC-V tiene 32 registros. En el proyecto s\u00f3lo implementaremos 9 (abajo se indica cuales) para evitar realizar trabajo repetitivo. Todas nuestras se\u00f1ales (rs1, rs2, rd) siguen siendo de 5-bits, pero s\u00f3lo se estar\u00e1n usando los registros indicados. El register file debe poder leer y escribir a los registros que se especifiquen seg\u00fan la instrucci\u00f3n, sin afectar o modificar a cualquier otro registro. Existe una excepci\u00f3n: El registro cero est\u00e1 alambrado a tierra y su valor no puede ser cambiado por ning\u00fan motivo. Los registros que utilizaremos son los siguientes: Registro por n\u00famero Registro por nombre x0 zero x1 ra x2 sp x5 t0 x6 t1 x8 s0 x9 s1 x10 a0 x11 a1 En el archivo regfile.circ se encuentra el esqueleto de un register file. Este tiene seis entradas: Nombre Ancho en bits Descripci\u00f3n Clock 1 Se\u00f1al de reloj. Aqu\u00ed se recibir\u00e1 una se\u00f1al de reloj \"non gated\", es decir, se recibe la se\u00f1al directa sin ser afectada por ANDs, NOTs o cualquier compuerta. Write Enable 1 Indica si se deber\u00eda escribir a un registro en el siguiente flanco de subida del reloj. Read Register 1 5 Registro a leer y cuyo valor ser\u00e1 enviado a Read Data 1. Read Register 2 5 Registro a leer y cuyo valor ser\u00e1 enviado a Read Data 2. Write Register 5 Determina cu\u00e1l registro ser\u00e1 modificado en el siguiente flanco de subida (asumiendo que Write Enable = 1). Write Data 32 Los 32 bits de datos a guardarse en el registro, en el siguiente flanco de subida (asumiendo que Write Enable = 1). El register file tiene las siguientes salidas: Nombre Ancho en bits Descripci\u00f3n Read Data 1 32 Datos que se est\u00e1n leyendo, seg\u00fan el registro que Read Register 1 pidi\u00f3. Read Data 2 32 Datos que se est\u00e1n leyendo, seg\u00fan el registro que Read Register 2 pidi\u00f3. s0 Value 32 Valor de s0 (salida para DEBUG/TEST). s1 Value 32 Valor de s1 (salida para DEBUG/TEST). t0 Value 32 Valor de t0 (salida para DEBUG/TEST). t1 Value 32 Valor de t1 (salida para DEBUG/TEST). a0 Value 32 Valor de a0 (salida para DEBUG/TEST). ra Value 32 Valor de ra (salida para DEBUG/TEST). sp Value 32 Valor de sp (salida para DEBUG/TEST). Las salidas para DEBUG/TEST est\u00e1n presentes porque son registros de uso frecuente (por ejemplo, tienen un trabajo importante en las llamadas a funciones). Se utilizar\u00e1n s\u00f3lo para pruebas del autograder. En un register file de verdad estas salidas no existir\u00edan. Para el proyecto deben estar presentes y funcionar bien para facilitar la calificaci\u00f3n. Pueden modificar regfile.circ como deseen, pero las salidas deben cumplir con el comportamiento que se indica. Deben ser cuidadosos de no modificar (mover, reemplazar, cortar, pegar, eliminar, etc) los pines de entrada o salida. Si necesitan m\u00e1s espacio, pueden moverlos mientras sean cuidadosos de mantener el posicionamiento relativo que estos tienen. Para verificar que nuestros cambios no \"rompan\" nada, podemos abrir regfile-harness.circ y revisar que no existan errores all\u00ed y que todo funcione bien. HINTS: (1) Cuidado con los muxes. Si estos tienen un enable ese deber\u00eda estar activo (o mejor a\u00fan, buscamos en la ayuda de Logisim c\u00f3mo quitar esa funcionalidad). (2) \u00bfTri-estado? Three-state? En CC3 no debemos pensar en estados de alta impedancia (qu'est-ce que c'est?) entonces lo mejor es deshabilitar el uso de three-state. Parte 2: ALU Su segunda tarea es crear un ALU que soporte todas las operaciones que necesitan las instrucciones de nuestro ISA (se detallan m\u00e1s adelante). Van a estar trabajando en el archivo alu.circ . Este tiene tres entradas: Nombre de Entrada Ancho en Bits Descripci\u00f3n A 32 Datos para usar por A en la operaci\u00f3n del ALU B 32 Datos para usar por B en la operaci\u00f3n del ALU ALU Op 4 Selecciona la operaci\u00f3n que el ALU debe de efectuar ...y cuatro salidas: Nombre de Entrada Ancho en Bits Descripci\u00f3n Out 32 Resultado de la operaci\u00f3n efectuada por el ALU Equal 1 1 si A y B son iguales; 0 de lo contrario LT 1 1 si A es menor que B (signed); 0 de lo contrario LTU 1 1 si A es menor que B (unsigned); 0 de lo contrario Esta es la lista de operaciones que necesitan implementar. Ustedes tienen que utilizar los componentes de logisim que ya efect\u00faan estas operaciones, por favor no las implementen desde cero, ser\u00eda muy tardado y no es el objetivo del proyecto. Valor de ALU Op Instrucci\u00f3n 0 sll: Out = A << B[4:0] 1 srl: Out = (unsigned) A >> B[4:0] 2 add: Out = A + B 3 and: Out = A & B 4 or: Out = A | B 5 xor: Out = A ^ B 6 slt: Out = (A < B) ? 1 : 0 Signed 7 mul: Out = (X * Y)[31:0] 8 mulh: Out = (A * B)[63:32] 9 div: Out =(unsigned) A / B 10 rem: Out = A % B 11 sub: Out = A - B Algunas cosas adicionales que tienen que tener en mente: La salidas Equal , LT , LTU siempre tienen que sacar el valor correcto de comparaci\u00f3n sin importar el valor de ALU Op . Nuevamente, tienen que tener cuidado con los inputs y output pins, no los modifiquen por ning\u00fan motivo. Su ALU deber\u00eda de encajar con el harness alu_harness.circ . Sigan las mismas instrucciones que en el register file. En particular, ustedes deber\u00edan de asegurar que su ALU es cargado correctamente por el harness antes de que hagan submit. Parte 3: CPU Se les provee un esqueleto del procesador en cpu.circ . Su procesador tendr\u00e1 una instancia de su ALU y Register File, as\u00ed como una unidad de memoria que ya se les provee. Ustedes son los responsables de construir el datapath y control completos, desde cero. Su procesador debe implementar el ISA que se detalla m\u00e1s abajo. Su procesador obtendr\u00e1 su programa del armaz\u00f3n (harness) riscv.circ . Su procesador tendr\u00e1 un output llamado FETCH_ADDRESS que indica cu\u00e1l instrucci\u00f3n queremos, esta direcci\u00f3n ser\u00e1 entregada al harness y este nos dar\u00e1 una instrucci\u00f3n. La instrucci\u00f3n ser\u00e1 recibida por el procesador y ser\u00e1 ejecutada. Revisen riscv.circ para ver exactamente qu\u00e9 sucede. El procesador tiene dos inputs que vienen del harness: Input Name Bit Width Descripci\u00f3n INSTRUCTION 32 Aqu\u00ed se recibe la instrucci\u00f3n que se obtuvo en la direcci\u00f3n identificada por FETCH_ADDRESS. CLOCK 1 Input del reloj. Puede ser necesario estar enviando esta se\u00f1al a varios subcircuitos. Esta se\u00f1al no debe pasar por ninguna compuerta (NOT, AND, etc). El procesador debe tener los siguientes outputs, que entregar\u00e1 al harness: Output Name Bit Width Descripci\u00f3n s0 32 Contenido de s0, s\u00f3lo para pruebas. s1 32 Contenido de s1, s\u00f3lo para pruebas. t0 32 Contenido de t0, s\u00f3lo para pruebas. t1 32 Contenido de t1, s\u00f3lo para pruebas. a0 32 Contenido de a0, s\u00f3lo para pruebas. ra 32 Contenido de ra, s\u00f3lo para pruebas. sp 32 Contenido de sp, s\u00f3lo para pruebas. FETCH_ADDRESS 32 Direcci\u00f3n que indica qu\u00e9 instrucci\u00f3n queremos obtener del harness. En respuesta a esto, el harness enviar\u00e1 alguna instrucci\u00f3n a trav\u00e9s de INSTRUCTION. Como en la parte 1, tengan cuidado al mover componentes y aseg\u00farense que los pines de input y output coincidan con el harness. Memoria Se les provee una memoria ya implementada. :D Un resumen de sus inputs y outputs. Nombre Tipo Bit Width Descripci\u00f3n ADDRESS input 32 Direcci\u00f3n a leer o escribir en la memoria. WRITE DATA input 32 Valor a escribirse en la memoria. WRITE ENABLE input 1 En = 1 en las instrucciones que escriben; En = 0 en las dem\u00e1s. Clk input 1 Se\u00f1al de reloj que viene desde cpu.circ. READ DATA output 32 Datos le\u00eddos en la direcci\u00f3n especificada. Control Las se\u00f1ales de control tienen un papel muy importante en el proyecto. Se sugiere volver a leer el cap\u00edtulo 4 del libro para darse cuenta d\u00f3nde podemos necesitar un MUX y, por lo tanto, alguna se\u00f1al de control. Existen varias formas de implementar las se\u00f1ales de control. Por ejemplo, pueden construir una palabra de control y guardarla en una memoria ROM (micro-codigo) o pueden construir un circuito que elija qu\u00e9 acci\u00f3n tomar bas\u00e1ndose en algunos bits del opcode, func3 y func7. Es obligatorio que sus componentes est\u00e9n unidos y las se\u00f1ales de control necesarias est\u00e9n implementadas. Si en la calificaci\u00f3n del proyecto s\u00f3lo tiene componentes sueltos (como el ALU y Reg File de la primera fase) y estos no se comunican entre s\u00ed, su nota ser\u00e1 cero. Consejo final: \u00a1Modularicen! Creen los subcircuitos que sean necesarios y dis\u00e9\u00f1enlos bien antes de empezar a construirlos. ISA Las instrucciones a implementar son las siguientes: Instruction Type Opcode Funct3 Funct7/IMM Operation add rd, rs1, rs2 R 0x33 0x0 0x00 R[rd] \u2190 R[rs1] + R[rs2] mul rd, rs1, rs2 R 0x33 0x0 0x01 R[rd] \u2190 (R[rs1] * R[rs2])[31:0] sub rd, rs1, rs2 R 0x33 0x0 0x20 R[rd] \u2190 R[rs1] - R[rs2] sll rd, rs1, rs2 R 0x33 0x1 0x00 R[rd] \u2190 R[rs1] << R[rs2 mulh rd, rs1, rs2 R 0x33 0x1 0x01 R[rd] \u2190 (R[rs1] * R[rs2])[63:32] slt rd, rs1, rs2 R 0x33 0x2 0x00 R[rd] \u2190 (R[rs1] < R[rs2]) ? 1 : 0 (signed) xor rd, rs1, rs2 R 0x33 0x4 0x00 R[rd] \u2190 R[rs1] ^ R[rs2] div rd, rs1, rs2 R 0x33 0x4 0x01 R[rd] \u2190 R[rs1] / R[rs2] srl rd, rs1, rs2 R 0x33 0x5 0x00 R[rd] \u2190 R[rs1] >> R[rs2] or rd, rs1, rs2 R 0x33 0x6 0x00 R[rd] \u2190 R[rs1] | R[rs2] rem rd, rs1, rs2 R 0x33 0x6 0x01 R[rd] \u2190 (R[rs1] % R[rs2] and rd, rs1, rs2 R 0x33 0x7 0x00 R[rd] \u2190 R[rs1] & R[rs2] lb rd, offset(rs1) I 0x03 0x0 R[rd] \u2190 SignExt(Mem(R[rs1] + offset, byte)) lh rd, offset(rs1) I 0x03 0x1 R[rd] \u2190 SignExt(Mem(R[rs1] + offset, half)) lw rd, offset(rs1) I 0x03 0x2 R[rd] \u2190 Mem(R[rs1] + offset, word) addi rd, rs1, imm I 0x13 0x0 R[rd] \u2190 R[rs1] + imm slli rd, rs1, imm I 0x13 0x1 0x00 R[rd] \u2190 R[rs1] << imm slti rd, rs1, imm I 0x13 0x2 R[rd] \u2190 (R[rs1] < imm) ? 1 : 0 xori rd, rs1, imm I 0x13 0x4 R[rd] \u2190 R[rs1] ^ imm srli rd, rs1, imm I 0x13 0x5 0x00 R[rd] \u2190 R[rs1] >> imm ori rd, rs1, imm I 0x13 0x6 R[rd] \u2190 R[rs1] | imm andi rd, rs1, imm I 0x13 0x7 R[rd] \u2190 R[rs1] & imm sw rs2, offset(rs1) S 0x23 0x2 Mem(R[rs1] + offset) \u2190 R[rs2] beq rs1, rs2, offset SB 0x63 0x0 if(R[rs1] == R[rs2]) then {PC \u2190 PC + {offset, 1b'0}} blt rs1, rs2, offset SB 0x63 0x4 if(R[rs1] less than R[rs2] (signed)) then {PC \u2190 PC + {offset, 1b'0}} bltu rs1, rs2, offset SB 0x63 0x6 if(R[rs1] less than R[rs2] (unsigned)) then {PC \u2190 PC + {offset, 1b'0}} lui rd, offset U 0x37 R[rd] \u2190 jal rd, imm UJ 0x6f R[rd] \u2190 PC + 4, PC \u2190 PC + jalr rd,rs, imm I 0x67 0x0 R[rd] \u2190 PC + 4, PC \u2190 R[rs] + Testing Para la parte 1 y 2, con el check local es suficiente y si lo pasan significa que esas partes ya las tienen funcionando al 100%. Para la parte 2, el check local tambi\u00e9n es bastante completo, pero ustedes pueden hacer m\u00e1s pruebas si lo desean. Como no podemos probar cada componente que ustedes vayan implementando, la mejor opci\u00f3n es escribir programas de RISC-V peque\u00f1os e ir revisando su datapath de diferentes maneras. Una vez que hayan escrito su programa de RISC-V, lo van a tener que cargar en la ROM que est\u00e1 en riscv.circ y empezar la ejecuci\u00f3n. Para eso, primero, abran riscv.circ y localicen la memoria ROM. Hagan click a la memoria y, despu\u00e9s, en la barra de herramientas de la izquierda, hagan click en \"(click here to edit)\", esto va a abrir un di\u00e1logo en donde ustedes pueden cargar su archivo con el c\u00f3digo de RISC-V y este ensamblar\u00e1 y generar\u00e1 c\u00f3digo de m\u00e1quina por ustedes que va a ser la salida de la memoria ROM. Notas sobre Logisim Si Logisim les da alg\u00fan problema extra\u00f1o, REINICIEN LOGISIM Y VUELVAN A CARGAR SU CIRCUITO. No pierdan tiempo buscando errores si no han hecho esto. Si reiniciar no ha resuelto el problema, all\u00ed s\u00ed ya les corresponde revisar su circuito. Logisim tiene un \"Reference\", en la pesta\u00f1a \"Help\", y les dice las especificaciones de cada componente. Do NOT gate the clock! (esto no tiene una traducci\u00f3n directa). Los clocks tienen que llegar directo a los circuitos, ni en CC3 ni en un curso donde usen hardware deber\u00edan colocar compuertas antes que la se\u00f1al de reloj entre al componente. Si est\u00e1n usando varias ventanas de Logisim tengan mucho cuidado cuando hagan copy-paste de una ventana a otra. Aseg\u00farense que s\u00ed se copi\u00f3 el circuito completo que quer\u00edan y que funcione bien despu\u00e9s de pegarlo. Cuando importen otro archivo (Project -> Load Library -> Logisim Library...), este aparecer\u00e1 como un folder en el panel de la izquierda. Los archivos esqueleto deber\u00edan de tener importado todo lo necesario. Cambiar los atributos antes de colocar un componente cambia el default. Si quieren colocar varios pines de 32 bits (por ejemplo), habr\u00eda que cambiarlo antes de colocar el primero. Si s\u00f3lo quieren cambiar alg\u00fan valor para un componente, primero lo colocan y, luego, lo cambian. Cuando cambian los inputs y outputs de un subcircuito que ya colocaron en main, Logisim autom\u00e1ticamente a\u00f1ade o remueve puertos seg\u00fan los cambios que hagan. Esto, muchas veces, afecta el tama\u00f1o o posici\u00f3n del subcircuito. Si ya hab\u00edan cables conectados, Logisim intentar\u00e1 moverlos, pero no siempre lo hace bien. Se recomienda que si van a cambiar los inputs y outputs de un circuito, primero desconecten todos los cables que este pueda tener en main o lo eliminen del main y lo vuelvan a colocar despu\u00e9s de cambiarlo. Recuerden que s\u00f3lo pueden hacer esto para los subcircuitos que USTEDES agregan . Los cables rojos significan que algo est\u00e1 mal conectado. Algunos casos pueden no ser tan obvios, revisen bien todas las conexiones cercanas. Logisim tiene algunas herramientas de an\u00e1lisis combinacional (nos puede construir mapas de Karnaugh o circuitos completos con s\u00f3lo darle una tabla :D). Esta herramienta les puede ser \u00fatil en alg\u00fan momento de sus vidas, pero la recomendaci\u00f3n es no usarla en CC3. Recuerden que durante los ex\u00e1menes tendr\u00e1n que hacer mapas o circuitos a mano, sin acceso a su computadora. Calificaci\u00f3n Por favor actualizar siempre la versi\u00f3n del CLI de autograders: 1 pip3 install --upgrade autograders-cli Entregaremos este lab de la misma manera que el pasado. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aprox. y luego puede ver sus resultados con... 1 autograder --stats Si le aparece Queued: True, espere un par de minutos y luego repita el autograder --stats \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.","title":"Proyecto 2: CPU"},{"location":"projects/pj02/#proyecto-2-cpu","text":"","title":"Proyecto 2: CPU"},{"location":"projects/pj02/#introduccion","text":"En este proyecto utilizaremos Logisim para implementar un procesador de 32-bits, cuyo ISA es un subset de las instrucciones de RISC-V. Algunos componentes del proyecto ser\u00e1n m\u00e1s sencillos que los componentes de hardware verdaderos para evitar realizar trabajo repetitivo. Nuestro ISA utiliza 32 registros de 32 bits cada uno y una memoria, cuyas direcciones son de 32 bits. A continuaci\u00f3n, algunos detalles importantes que debemos leer antes de iniciar. Pueden utilizar cualquier bloque ya existente en Logisim para el proyecto. Guarden constantemente. Realicen commits y hagan push al menos una vez por cada d\u00eda que trabajen. Logisim es un excelente simulador pero ocasionalmente tiene errores, entonces hagamos caso a la indicaci\u00f3n anterior. Guarden constantemente... Trabajemos de la misma forma que en un proyecto de software: Construyamos el proyecto pieza por pieza y realicemos pruebas antes de unir un bloque con otros. Podemos construir todos los subcircuitos adicionales que necesitemos, siempre y cuando sigamos las reglas espec\u00edficas que cada parte impone (m\u00e1s de esto a continuaci\u00f3n). Se incluyen algunos tests. S\u00f3lo se debe correr el script ./check (esto seguramente tendr\u00e1n que hacerlo en Linux, se requiere Python 3.X instalado). \u00a1Necesitaremos m\u00e1s tests! Cada equipo deber\u00eda hacer sus propios tests adicionales. En la secci\u00f3n de Testing hay algunas indicaciones de c\u00f3mo hacer pruebas adicionales. Finalmente, las dos indicaciones m\u00e1s importantes: Se les dar\u00e1n algunos armazones (harnesses) a los cuales sus circuitos se conectar\u00e1n. ASEGURENSE QUE S\u00cd SE ADAPTAN DE FORMA CORRECTA, TODOS LOS TESTS FALLAR\u00c1N SI NO LO HACEN. En el camino nos hemos encontrado con algunos problemas de git merge si ambos miembros del equipo estaban trabajando en el mismo archivo; a veces git los resolv\u00eda autom\u00e1ticamente y a veces no. En Logisim es garantizado que git NO RESOLVER\u00c1 ESTO DE FORMA CORRECTA, entonces si trabajamos en equipo NO DEBEMOS MODIFICAR EL MISMO ARCHIVO AL MISMO TIEMPO","title":"Introducci\u00f3n"},{"location":"projects/pj02/#preparacion","text":"Antes de comenzar, aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta, por favor dir\u00edjanse a Telergam y pregunten. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que represente lo represente y que no haya sido tomado por otro. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s, lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que, al hacer esto, pueden tener acceso al repositorio del otro miembro del grupo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): 1 git clone <link del repositorio>","title":"Preparaci\u00f3n"},{"location":"projects/pj02/#parte-1-register-file","text":"Como aprendimos en clase, RISC-V tiene 32 registros. En el proyecto s\u00f3lo implementaremos 9 (abajo se indica cuales) para evitar realizar trabajo repetitivo. Todas nuestras se\u00f1ales (rs1, rs2, rd) siguen siendo de 5-bits, pero s\u00f3lo se estar\u00e1n usando los registros indicados. El register file debe poder leer y escribir a los registros que se especifiquen seg\u00fan la instrucci\u00f3n, sin afectar o modificar a cualquier otro registro. Existe una excepci\u00f3n: El registro cero est\u00e1 alambrado a tierra y su valor no puede ser cambiado por ning\u00fan motivo. Los registros que utilizaremos son los siguientes: Registro por n\u00famero Registro por nombre x0 zero x1 ra x2 sp x5 t0 x6 t1 x8 s0 x9 s1 x10 a0 x11 a1 En el archivo regfile.circ se encuentra el esqueleto de un register file. Este tiene seis entradas: Nombre Ancho en bits Descripci\u00f3n Clock 1 Se\u00f1al de reloj. Aqu\u00ed se recibir\u00e1 una se\u00f1al de reloj \"non gated\", es decir, se recibe la se\u00f1al directa sin ser afectada por ANDs, NOTs o cualquier compuerta. Write Enable 1 Indica si se deber\u00eda escribir a un registro en el siguiente flanco de subida del reloj. Read Register 1 5 Registro a leer y cuyo valor ser\u00e1 enviado a Read Data 1. Read Register 2 5 Registro a leer y cuyo valor ser\u00e1 enviado a Read Data 2. Write Register 5 Determina cu\u00e1l registro ser\u00e1 modificado en el siguiente flanco de subida (asumiendo que Write Enable = 1). Write Data 32 Los 32 bits de datos a guardarse en el registro, en el siguiente flanco de subida (asumiendo que Write Enable = 1). El register file tiene las siguientes salidas: Nombre Ancho en bits Descripci\u00f3n Read Data 1 32 Datos que se est\u00e1n leyendo, seg\u00fan el registro que Read Register 1 pidi\u00f3. Read Data 2 32 Datos que se est\u00e1n leyendo, seg\u00fan el registro que Read Register 2 pidi\u00f3. s0 Value 32 Valor de s0 (salida para DEBUG/TEST). s1 Value 32 Valor de s1 (salida para DEBUG/TEST). t0 Value 32 Valor de t0 (salida para DEBUG/TEST). t1 Value 32 Valor de t1 (salida para DEBUG/TEST). a0 Value 32 Valor de a0 (salida para DEBUG/TEST). ra Value 32 Valor de ra (salida para DEBUG/TEST). sp Value 32 Valor de sp (salida para DEBUG/TEST). Las salidas para DEBUG/TEST est\u00e1n presentes porque son registros de uso frecuente (por ejemplo, tienen un trabajo importante en las llamadas a funciones). Se utilizar\u00e1n s\u00f3lo para pruebas del autograder. En un register file de verdad estas salidas no existir\u00edan. Para el proyecto deben estar presentes y funcionar bien para facilitar la calificaci\u00f3n. Pueden modificar regfile.circ como deseen, pero las salidas deben cumplir con el comportamiento que se indica. Deben ser cuidadosos de no modificar (mover, reemplazar, cortar, pegar, eliminar, etc) los pines de entrada o salida. Si necesitan m\u00e1s espacio, pueden moverlos mientras sean cuidadosos de mantener el posicionamiento relativo que estos tienen. Para verificar que nuestros cambios no \"rompan\" nada, podemos abrir regfile-harness.circ y revisar que no existan errores all\u00ed y que todo funcione bien. HINTS: (1) Cuidado con los muxes. Si estos tienen un enable ese deber\u00eda estar activo (o mejor a\u00fan, buscamos en la ayuda de Logisim c\u00f3mo quitar esa funcionalidad). (2) \u00bfTri-estado? Three-state? En CC3 no debemos pensar en estados de alta impedancia (qu'est-ce que c'est?) entonces lo mejor es deshabilitar el uso de three-state.","title":"Parte 1: Register File"},{"location":"projects/pj02/#parte-2-alu","text":"Su segunda tarea es crear un ALU que soporte todas las operaciones que necesitan las instrucciones de nuestro ISA (se detallan m\u00e1s adelante). Van a estar trabajando en el archivo alu.circ . Este tiene tres entradas: Nombre de Entrada Ancho en Bits Descripci\u00f3n A 32 Datos para usar por A en la operaci\u00f3n del ALU B 32 Datos para usar por B en la operaci\u00f3n del ALU ALU Op 4 Selecciona la operaci\u00f3n que el ALU debe de efectuar ...y cuatro salidas: Nombre de Entrada Ancho en Bits Descripci\u00f3n Out 32 Resultado de la operaci\u00f3n efectuada por el ALU Equal 1 1 si A y B son iguales; 0 de lo contrario LT 1 1 si A es menor que B (signed); 0 de lo contrario LTU 1 1 si A es menor que B (unsigned); 0 de lo contrario Esta es la lista de operaciones que necesitan implementar. Ustedes tienen que utilizar los componentes de logisim que ya efect\u00faan estas operaciones, por favor no las implementen desde cero, ser\u00eda muy tardado y no es el objetivo del proyecto. Valor de ALU Op Instrucci\u00f3n 0 sll: Out = A << B[4:0] 1 srl: Out = (unsigned) A >> B[4:0] 2 add: Out = A + B 3 and: Out = A & B 4 or: Out = A | B 5 xor: Out = A ^ B 6 slt: Out = (A < B) ? 1 : 0 Signed 7 mul: Out = (X * Y)[31:0] 8 mulh: Out = (A * B)[63:32] 9 div: Out =(unsigned) A / B 10 rem: Out = A % B 11 sub: Out = A - B Algunas cosas adicionales que tienen que tener en mente: La salidas Equal , LT , LTU siempre tienen que sacar el valor correcto de comparaci\u00f3n sin importar el valor de ALU Op . Nuevamente, tienen que tener cuidado con los inputs y output pins, no los modifiquen por ning\u00fan motivo. Su ALU deber\u00eda de encajar con el harness alu_harness.circ . Sigan las mismas instrucciones que en el register file. En particular, ustedes deber\u00edan de asegurar que su ALU es cargado correctamente por el harness antes de que hagan submit.","title":"Parte 2: ALU"},{"location":"projects/pj02/#parte-3-cpu","text":"Se les provee un esqueleto del procesador en cpu.circ . Su procesador tendr\u00e1 una instancia de su ALU y Register File, as\u00ed como una unidad de memoria que ya se les provee. Ustedes son los responsables de construir el datapath y control completos, desde cero. Su procesador debe implementar el ISA que se detalla m\u00e1s abajo. Su procesador obtendr\u00e1 su programa del armaz\u00f3n (harness) riscv.circ . Su procesador tendr\u00e1 un output llamado FETCH_ADDRESS que indica cu\u00e1l instrucci\u00f3n queremos, esta direcci\u00f3n ser\u00e1 entregada al harness y este nos dar\u00e1 una instrucci\u00f3n. La instrucci\u00f3n ser\u00e1 recibida por el procesador y ser\u00e1 ejecutada. Revisen riscv.circ para ver exactamente qu\u00e9 sucede. El procesador tiene dos inputs que vienen del harness: Input Name Bit Width Descripci\u00f3n INSTRUCTION 32 Aqu\u00ed se recibe la instrucci\u00f3n que se obtuvo en la direcci\u00f3n identificada por FETCH_ADDRESS. CLOCK 1 Input del reloj. Puede ser necesario estar enviando esta se\u00f1al a varios subcircuitos. Esta se\u00f1al no debe pasar por ninguna compuerta (NOT, AND, etc). El procesador debe tener los siguientes outputs, que entregar\u00e1 al harness: Output Name Bit Width Descripci\u00f3n s0 32 Contenido de s0, s\u00f3lo para pruebas. s1 32 Contenido de s1, s\u00f3lo para pruebas. t0 32 Contenido de t0, s\u00f3lo para pruebas. t1 32 Contenido de t1, s\u00f3lo para pruebas. a0 32 Contenido de a0, s\u00f3lo para pruebas. ra 32 Contenido de ra, s\u00f3lo para pruebas. sp 32 Contenido de sp, s\u00f3lo para pruebas. FETCH_ADDRESS 32 Direcci\u00f3n que indica qu\u00e9 instrucci\u00f3n queremos obtener del harness. En respuesta a esto, el harness enviar\u00e1 alguna instrucci\u00f3n a trav\u00e9s de INSTRUCTION. Como en la parte 1, tengan cuidado al mover componentes y aseg\u00farense que los pines de input y output coincidan con el harness.","title":"Parte 3: CPU"},{"location":"projects/pj02/#memoria","text":"Se les provee una memoria ya implementada. :D Un resumen de sus inputs y outputs. Nombre Tipo Bit Width Descripci\u00f3n ADDRESS input 32 Direcci\u00f3n a leer o escribir en la memoria. WRITE DATA input 32 Valor a escribirse en la memoria. WRITE ENABLE input 1 En = 1 en las instrucciones que escriben; En = 0 en las dem\u00e1s. Clk input 1 Se\u00f1al de reloj que viene desde cpu.circ. READ DATA output 32 Datos le\u00eddos en la direcci\u00f3n especificada.","title":"Memoria"},{"location":"projects/pj02/#control","text":"Las se\u00f1ales de control tienen un papel muy importante en el proyecto. Se sugiere volver a leer el cap\u00edtulo 4 del libro para darse cuenta d\u00f3nde podemos necesitar un MUX y, por lo tanto, alguna se\u00f1al de control. Existen varias formas de implementar las se\u00f1ales de control. Por ejemplo, pueden construir una palabra de control y guardarla en una memoria ROM (micro-codigo) o pueden construir un circuito que elija qu\u00e9 acci\u00f3n tomar bas\u00e1ndose en algunos bits del opcode, func3 y func7. Es obligatorio que sus componentes est\u00e9n unidos y las se\u00f1ales de control necesarias est\u00e9n implementadas. Si en la calificaci\u00f3n del proyecto s\u00f3lo tiene componentes sueltos (como el ALU y Reg File de la primera fase) y estos no se comunican entre s\u00ed, su nota ser\u00e1 cero. Consejo final: \u00a1Modularicen! Creen los subcircuitos que sean necesarios y dis\u00e9\u00f1enlos bien antes de empezar a construirlos.","title":"Control"},{"location":"projects/pj02/#isa","text":"Las instrucciones a implementar son las siguientes: Instruction Type Opcode Funct3 Funct7/IMM Operation add rd, rs1, rs2 R 0x33 0x0 0x00 R[rd] \u2190 R[rs1] + R[rs2] mul rd, rs1, rs2 R 0x33 0x0 0x01 R[rd] \u2190 (R[rs1] * R[rs2])[31:0] sub rd, rs1, rs2 R 0x33 0x0 0x20 R[rd] \u2190 R[rs1] - R[rs2] sll rd, rs1, rs2 R 0x33 0x1 0x00 R[rd] \u2190 R[rs1] << R[rs2 mulh rd, rs1, rs2 R 0x33 0x1 0x01 R[rd] \u2190 (R[rs1] * R[rs2])[63:32] slt rd, rs1, rs2 R 0x33 0x2 0x00 R[rd] \u2190 (R[rs1] < R[rs2]) ? 1 : 0 (signed) xor rd, rs1, rs2 R 0x33 0x4 0x00 R[rd] \u2190 R[rs1] ^ R[rs2] div rd, rs1, rs2 R 0x33 0x4 0x01 R[rd] \u2190 R[rs1] / R[rs2] srl rd, rs1, rs2 R 0x33 0x5 0x00 R[rd] \u2190 R[rs1] >> R[rs2] or rd, rs1, rs2 R 0x33 0x6 0x00 R[rd] \u2190 R[rs1] | R[rs2] rem rd, rs1, rs2 R 0x33 0x6 0x01 R[rd] \u2190 (R[rs1] % R[rs2] and rd, rs1, rs2 R 0x33 0x7 0x00 R[rd] \u2190 R[rs1] & R[rs2] lb rd, offset(rs1) I 0x03 0x0 R[rd] \u2190 SignExt(Mem(R[rs1] + offset, byte)) lh rd, offset(rs1) I 0x03 0x1 R[rd] \u2190 SignExt(Mem(R[rs1] + offset, half)) lw rd, offset(rs1) I 0x03 0x2 R[rd] \u2190 Mem(R[rs1] + offset, word) addi rd, rs1, imm I 0x13 0x0 R[rd] \u2190 R[rs1] + imm slli rd, rs1, imm I 0x13 0x1 0x00 R[rd] \u2190 R[rs1] << imm slti rd, rs1, imm I 0x13 0x2 R[rd] \u2190 (R[rs1] < imm) ? 1 : 0 xori rd, rs1, imm I 0x13 0x4 R[rd] \u2190 R[rs1] ^ imm srli rd, rs1, imm I 0x13 0x5 0x00 R[rd] \u2190 R[rs1] >> imm ori rd, rs1, imm I 0x13 0x6 R[rd] \u2190 R[rs1] | imm andi rd, rs1, imm I 0x13 0x7 R[rd] \u2190 R[rs1] & imm sw rs2, offset(rs1) S 0x23 0x2 Mem(R[rs1] + offset) \u2190 R[rs2] beq rs1, rs2, offset SB 0x63 0x0 if(R[rs1] == R[rs2]) then {PC \u2190 PC + {offset, 1b'0}} blt rs1, rs2, offset SB 0x63 0x4 if(R[rs1] less than R[rs2] (signed)) then {PC \u2190 PC + {offset, 1b'0}} bltu rs1, rs2, offset SB 0x63 0x6 if(R[rs1] less than R[rs2] (unsigned)) then {PC \u2190 PC + {offset, 1b'0}} lui rd, offset U 0x37 R[rd] \u2190 jal rd, imm UJ 0x6f R[rd] \u2190 PC + 4, PC \u2190 PC + jalr rd,rs, imm I 0x67 0x0 R[rd] \u2190 PC + 4, PC \u2190 R[rs] +","title":"ISA"},{"location":"projects/pj02/#testing","text":"Para la parte 1 y 2, con el check local es suficiente y si lo pasan significa que esas partes ya las tienen funcionando al 100%. Para la parte 2, el check local tambi\u00e9n es bastante completo, pero ustedes pueden hacer m\u00e1s pruebas si lo desean. Como no podemos probar cada componente que ustedes vayan implementando, la mejor opci\u00f3n es escribir programas de RISC-V peque\u00f1os e ir revisando su datapath de diferentes maneras. Una vez que hayan escrito su programa de RISC-V, lo van a tener que cargar en la ROM que est\u00e1 en riscv.circ y empezar la ejecuci\u00f3n. Para eso, primero, abran riscv.circ y localicen la memoria ROM. Hagan click a la memoria y, despu\u00e9s, en la barra de herramientas de la izquierda, hagan click en \"(click here to edit)\", esto va a abrir un di\u00e1logo en donde ustedes pueden cargar su archivo con el c\u00f3digo de RISC-V y este ensamblar\u00e1 y generar\u00e1 c\u00f3digo de m\u00e1quina por ustedes que va a ser la salida de la memoria ROM.","title":"Testing"},{"location":"projects/pj02/#notas-sobre-logisim","text":"Si Logisim les da alg\u00fan problema extra\u00f1o, REINICIEN LOGISIM Y VUELVAN A CARGAR SU CIRCUITO. No pierdan tiempo buscando errores si no han hecho esto. Si reiniciar no ha resuelto el problema, all\u00ed s\u00ed ya les corresponde revisar su circuito. Logisim tiene un \"Reference\", en la pesta\u00f1a \"Help\", y les dice las especificaciones de cada componente. Do NOT gate the clock! (esto no tiene una traducci\u00f3n directa). Los clocks tienen que llegar directo a los circuitos, ni en CC3 ni en un curso donde usen hardware deber\u00edan colocar compuertas antes que la se\u00f1al de reloj entre al componente. Si est\u00e1n usando varias ventanas de Logisim tengan mucho cuidado cuando hagan copy-paste de una ventana a otra. Aseg\u00farense que s\u00ed se copi\u00f3 el circuito completo que quer\u00edan y que funcione bien despu\u00e9s de pegarlo. Cuando importen otro archivo (Project -> Load Library -> Logisim Library...), este aparecer\u00e1 como un folder en el panel de la izquierda. Los archivos esqueleto deber\u00edan de tener importado todo lo necesario. Cambiar los atributos antes de colocar un componente cambia el default. Si quieren colocar varios pines de 32 bits (por ejemplo), habr\u00eda que cambiarlo antes de colocar el primero. Si s\u00f3lo quieren cambiar alg\u00fan valor para un componente, primero lo colocan y, luego, lo cambian. Cuando cambian los inputs y outputs de un subcircuito que ya colocaron en main, Logisim autom\u00e1ticamente a\u00f1ade o remueve puertos seg\u00fan los cambios que hagan. Esto, muchas veces, afecta el tama\u00f1o o posici\u00f3n del subcircuito. Si ya hab\u00edan cables conectados, Logisim intentar\u00e1 moverlos, pero no siempre lo hace bien. Se recomienda que si van a cambiar los inputs y outputs de un circuito, primero desconecten todos los cables que este pueda tener en main o lo eliminen del main y lo vuelvan a colocar despu\u00e9s de cambiarlo. Recuerden que s\u00f3lo pueden hacer esto para los subcircuitos que USTEDES agregan . Los cables rojos significan que algo est\u00e1 mal conectado. Algunos casos pueden no ser tan obvios, revisen bien todas las conexiones cercanas. Logisim tiene algunas herramientas de an\u00e1lisis combinacional (nos puede construir mapas de Karnaugh o circuitos completos con s\u00f3lo darle una tabla :D). Esta herramienta les puede ser \u00fatil en alg\u00fan momento de sus vidas, pero la recomendaci\u00f3n es no usarla en CC3. Recuerden que durante los ex\u00e1menes tendr\u00e1n que hacer mapas o circuitos a mano, sin acceso a su computadora.","title":"Notas sobre Logisim"},{"location":"projects/pj02/#calificacion","text":"Por favor actualizar siempre la versi\u00f3n del CLI de autograders: 1 pip3 install --upgrade autograders-cli Entregaremos este lab de la misma manera que el pasado. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aprox. y luego puede ver sus resultados con... 1 autograder --stats Si le aparece Queued: True, espere un par de minutos y luego repita el autograder --stats \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.","title":"Calificaci\u00f3n"},{"location":"tutorials/install/","text":"Tutorial de Instalaci\u00f3n de Material El objetivo de este tutorial es dejar preparado el material que necesitar\u00e1n para los laboratorios y proyectos. La mejor opci\u00f3n: M\u00e1quina virtual Descarguen la siguiente m\u00e1quina virtual y \u00e1branla con VMware. Recuerde que usando VMware Player (gratuito, sin necesidad de licencia) puede abrir y utilizar m\u00e1quinas virtuales ya hechas. Todos los links son para la misma m\u00e1quina virtual. Si alguno falla, utilicen otro. Descargar m\u00e1quina virtual desde Google Drive Descargar m\u00e1quina virtual desde Google Drive (mirror) Descargar m\u00e1quina virtual desde Mega Credenciales Usuario : student Password : student La m\u00e1quina virtual ya trae todo lo necesario para el semestre. Instalaci\u00f3n Nativa Para trabajar nativo necesitar\u00e1n Ubuntu 16 o 18 en ingl\u00e9s, se recomienda 18. En Ubuntu 20 no podr\u00e1n utilizar Jupiter. Si su Ubuntu no se encuentra en ingl\u00e9s, tendra problemas en el lab 2 (cgdb). Puede cambiar su idioma, o buscar la soluci\u00f3n al problema en Google. Si todav\u00eda no tiene Ubuntu instalado aqu\u00ed hay un tutorial para dual boot . Ponga mucha atenci\u00f3n, sea muy cuidadoso y sobre todo haga un backup de su informaci\u00f3n importante. Wow... parece que son bastantes instrucciones, \u00a1Ser\u00eda m\u00e1s f\u00e1cil usar la m\u00e1quina virtual! Instalar git 1 2 sudo apt update sudo apt install git Instalar Java 1 2 sudo apt update sudo apt install default-jdk Instalar Python 3 1 2 3 4 5 sudo apt update sudo apt install software-properties-common sudo add-apt-repository ppa:deadsnakes/ppa sudo apt update sudo apt install python3.7 Instalar pip 1 2 sudo apt update sudo apt install python3-pip Las versiones recientes de Python suelen incluir todo lo que necesitamos (en la maquina virtual ya revisamos y esta todo lo que necesita! en serio, use la m\u00e1quina virtual!), verifiqu\u00e9moslo abriendo la terminal de Python con el comando python3 , luego en la terminal escribiremos los siguientes comandos 1 2 3 4 import os import sys import requests import zipfile Si ninguno nos dio problema, Python esta listo; si alguno fallo, lo instalaremos con pip 1 pip3 install nombreDelPaqueteQueDioError cURL Finalmente instalamos curl 1 2 sudo apt update sudo apt install curl CGDB Y terminamos instalando cgdb 1 2 sudo apt update sudo apt install cgdb Casi listo! Cuando lleguemos al lab 3 y al lab 5 alli le aparecer\u00e1n las instrucciones para instalar el software faltante. Mi computadora no es muy potente, \u00bfQu\u00e9 puedo hacer? Puede probar con algun IDE en l\u00ednea como repl.it . Aqu\u00ed podr\u00e1 trabajar un poco de C y entregar su lab 0 y lab 1, pero al llegar al lab 2 comienzan los problemas. Estamos tratando de buscar herramientas para trabajar en l\u00ednea, pero haga todo lo posible por trabajar ya sea en m\u00e1quina virtual o en Ubuntu nativo. Soy demasiado fan\u00e1tico de Windows 10, \u00bfhay alguna opci\u00f3n para m\u00ed? Puede instalar WSL en su m\u00e1quina. Luego de ese mont\u00f3n de pasos, tendr\u00e1 que instalar todo el material de arriba. No haga esto, mejor use la m\u00e1quina virtual. Esta es una opci\u00f3n que no aconsejamos para nada. Si esta en Windows, no le podremos ayudar con sus problemas, solo le sugeriremos que... \u00a1adivin\u00f3! use la m\u00e1quina virtual.","title":"Tutorial de Instalaci\u00f3n de Material"},{"location":"tutorials/install/#tutorial-de-instalacion-de-material","text":"El objetivo de este tutorial es dejar preparado el material que necesitar\u00e1n para los laboratorios y proyectos.","title":"Tutorial de Instalaci\u00f3n de Material"},{"location":"tutorials/install/#la-mejor-opcion-maquina-virtual","text":"Descarguen la siguiente m\u00e1quina virtual y \u00e1branla con VMware. Recuerde que usando VMware Player (gratuito, sin necesidad de licencia) puede abrir y utilizar m\u00e1quinas virtuales ya hechas. Todos los links son para la misma m\u00e1quina virtual. Si alguno falla, utilicen otro. Descargar m\u00e1quina virtual desde Google Drive Descargar m\u00e1quina virtual desde Google Drive (mirror) Descargar m\u00e1quina virtual desde Mega","title":"La mejor opci\u00f3n: M\u00e1quina virtual"},{"location":"tutorials/install/#credenciales","text":"Usuario : student Password : student La m\u00e1quina virtual ya trae todo lo necesario para el semestre.","title":"Credenciales"},{"location":"tutorials/install/#instalacion-nativa","text":"Para trabajar nativo necesitar\u00e1n Ubuntu 16 o 18 en ingl\u00e9s, se recomienda 18. En Ubuntu 20 no podr\u00e1n utilizar Jupiter. Si su Ubuntu no se encuentra en ingl\u00e9s, tendra problemas en el lab 2 (cgdb). Puede cambiar su idioma, o buscar la soluci\u00f3n al problema en Google. Si todav\u00eda no tiene Ubuntu instalado aqu\u00ed hay un tutorial para dual boot . Ponga mucha atenci\u00f3n, sea muy cuidadoso y sobre todo haga un backup de su informaci\u00f3n importante. Wow... parece que son bastantes instrucciones, \u00a1Ser\u00eda m\u00e1s f\u00e1cil usar la m\u00e1quina virtual!","title":"Instalaci\u00f3n Nativa"},{"location":"tutorials/install/#instalar-git","text":"1 2 sudo apt update sudo apt install git","title":"Instalar git"},{"location":"tutorials/install/#instalar-java","text":"1 2 sudo apt update sudo apt install default-jdk","title":"Instalar Java"},{"location":"tutorials/install/#instalar-python-3","text":"1 2 3 4 5 sudo apt update sudo apt install software-properties-common sudo add-apt-repository ppa:deadsnakes/ppa sudo apt update sudo apt install python3.7","title":"Instalar Python 3"},{"location":"tutorials/install/#instalar-pip","text":"1 2 sudo apt update sudo apt install python3-pip Las versiones recientes de Python suelen incluir todo lo que necesitamos (en la maquina virtual ya revisamos y esta todo lo que necesita! en serio, use la m\u00e1quina virtual!), verifiqu\u00e9moslo abriendo la terminal de Python con el comando python3 , luego en la terminal escribiremos los siguientes comandos 1 2 3 4 import os import sys import requests import zipfile Si ninguno nos dio problema, Python esta listo; si alguno fallo, lo instalaremos con pip 1 pip3 install nombreDelPaqueteQueDioError","title":"Instalar pip"},{"location":"tutorials/install/#curl","text":"Finalmente instalamos curl 1 2 sudo apt update sudo apt install curl","title":"cURL"},{"location":"tutorials/install/#cgdb","text":"Y terminamos instalando cgdb 1 2 sudo apt update sudo apt install cgdb Casi listo! Cuando lleguemos al lab 3 y al lab 5 alli le aparecer\u00e1n las instrucciones para instalar el software faltante.","title":"CGDB"},{"location":"tutorials/install/#mi-computadora-no-es-muy-potente-que-puedo-hacer","text":"Puede probar con algun IDE en l\u00ednea como repl.it . Aqu\u00ed podr\u00e1 trabajar un poco de C y entregar su lab 0 y lab 1, pero al llegar al lab 2 comienzan los problemas. Estamos tratando de buscar herramientas para trabajar en l\u00ednea, pero haga todo lo posible por trabajar ya sea en m\u00e1quina virtual o en Ubuntu nativo.","title":"Mi computadora no es muy potente, \u00bfQu\u00e9 puedo hacer?"},{"location":"tutorials/install/#soy-demasiado-fanatico-de-windows-10-hay-alguna-opcion-para-mi","text":"Puede instalar WSL en su m\u00e1quina. Luego de ese mont\u00f3n de pasos, tendr\u00e1 que instalar todo el material de arriba. No haga esto, mejor use la m\u00e1quina virtual. Esta es una opci\u00f3n que no aconsejamos para nada. Si esta en Windows, no le podremos ayudar con sus problemas, solo le sugeriremos que... \u00a1adivin\u00f3! use la m\u00e1quina virtual.","title":"Soy demasiado fan\u00e1tico de Windows 10, \u00bfhay alguna opci\u00f3n para m\u00ed?"}]}