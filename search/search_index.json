{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenidos a CC-3","text":"<p>En cursos anteriores han aprendido a programar en un nivel bastante alto de abstracci\u00f3n. Ac\u00e1 nos concentraremos en la m\u00e1quina y c\u00f3mo esta ejecuta los programas que ustedes escriben. En este curso nos preocuparemos no tanto por el proceso de escribir un programa de computadora, sino m\u00e1s bien en c\u00f3mo la computadora ejecuta los programas. Es decir, el tema principal de este curso es la estructura de la m\u00e1quina: los circuitos electr\u00f3nicos, y las operaciones computacionales que estos circuitos llevan a cabo. Para concretizar estas ideas, vamos a estudiar con cierto detalle el ISA RISC-V. Usamos este ISA pues es m\u00e1s sencillo que otras familias, mientras que posee caracter\u00edsticas deseables como paralelismo.</p>"},{"location":"labs/lab00/","title":"Lab 0 - Git y Representaci\u00f3n de N\u00fameros","text":""},{"location":"labs/lab00/#objetivos","title":"Objetivos","text":"<ul> <li>Aprender git.</li> <li>Ganarse unos puntos extra.</li> <li>Crear una cuenta de GitHub.</li> <li>Ganar m\u00e1s intuici\u00f3n para trabajar con n\u00fameros binarios.</li> </ul>"},{"location":"labs/lab00/#preparacion","title":"Preparaci\u00f3n","text":"<p>Por favor lean las siguientes instrucciones cuidadosamente antes de seguir con el laboratorio. La mayor parte de los problemas que tienen los estudiantes durante este laboratorio se pueden prevenir siguiendo atentamente los pasos que se indican.</p> <p>Visiten este link. Aqu\u00ed encontrar\u00e1n todos los archivos necesarios para completar este laboratorio. En esta p\u00e1gina, encontrar\u00e1n un bot\u00f3n que dice \"Accept this assignment\". Al presionar este bot\u00f3n, se crear\u00e1 autom\u00e1ticamente un repositorio en Github llamado <code>https://www.github.com/cc3-an/2023-lab-00-git-&lt;USUARIO&gt;</code>. Noten que el \"due\u00f1o\" de este repositorio es un usuario llamado <code>cc3-an</code>, y el usuario de ustedes es \u00fanicamente el sufijo del nombre del repositorio. De esta forma, nos encargamos de tener acceso siempre a su c\u00f3digo.</p> <p>Nota: Sepan de una vez que, si encontramos plagio en sus laboratorios, su nota ser\u00e1 AUTOM\u00c1TICAMENTE 0, sin posibilidad de cambiarla. De repetirse nuevamente este acontecimiento, el staff del curso organizar\u00e1 una reuni\u00f3n con ustedes y sus directores de carrera para contarles lo ocurrido y sancionarlos conforme al reglamento de la universidad.</p> <p>Despu\u00e9s de realizar esto, en la m\u00e1quina virtual (o sus propias computadoras) abran una terminal en el directorio que prefieran, y ejecuten el siguiente comando:</p> <pre><code>git clone https://www.github.com/cc3-an/2023-lab-00-git-&lt;USUARIO&gt;\n</code></pre> <p>Recuerden reemplazar <code>&lt;USUARIO&gt;</code> con su nombre de usuario de GitHub.</p> <p>esto descargar\u00e1 en el directorio que escogieron todos los archivos base para este laboratorio.</p>"},{"location":"labs/lab00/#ejercicio-1-tutorial","title":"Ejercicio 1: Tutorial","text":"<p>Por favor lo primero que deben hacer es leer el tutorial de git y GitHub que se encuentra en la p\u00e1gina del curso. Este tutorial les va a ense\u00f1ar a utilizar git y GitHub para el resto del curso. Por favor leanlo con atenci\u00f3n y sigan los pasos que se indican.</p> <p>Tambi\u00e9n es necesario que se lean el tutorial del autograder que se encuentra en la p\u00e1gina del curso tambi\u00e9n. Este les va a ense\u00f1ar a utilizar el autograder para los laboratorios. Por favor leanlo con atenci\u00f3n y sigan los pasos que se indican.</p>"},{"location":"labs/lab00/#ejercicio-2-github","title":"Ejercicio 2: GitHub","text":"<p>Vamos a crear un archivo llamado <code>hello.sh</code> en la carpeta del laboratorio ejecutando el siguiente commando en la terminal:</p> <pre><code>echo 'echo \"Hola Mundo\"' &gt; hello.sh\n</code></pre> <p>Luego pueden correr el archivo en la terminal con <code>bash hello.sh</code>. En la terminal se imprimir\u00e1 <code>Hola Mundo</code>. Ahora utilicemos git para ver los archivos que todav\u00eda no han sido rastreados utilizando <code>status</code>:</p> <pre><code>git status\n</code></pre> <p>Lo que producir\u00e1 lo siguiente:</p> <pre><code>On branch main\n\nNo commits yet\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\nhello.sh\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n</code></pre> <p>Esto es porque hemos creado un archivo nuevo llamado <code>hello.sh</code> y no lo hemos agregado. Podemos agregarlo y hacer commit:</p> <pre><code>git add hello.sh\ngit commit -m \"Mensaje del Commit\"\ngit branch\ngit push -u origin main\n</code></pre> <p>El control de versiones git esta construido alrededor de commits, o checkpoints en el desarrollo de diferentes versiones/etapas de su c\u00f3digo. Para explicar los pasos de arriba un poco m\u00e1s:</p> <ul> <li>git add [archivo] le dir\u00e1 a git que han hecho cambios a ese archivo y que quieren que esos cambios se guarden en el siguiente commit (staging).</li> <li>git commit -m \"mensaje\" oficialmente guarda esos cambios que acaban de agregar, y crea un snapshot del contenido actual de todos los archivos en el repositorio. Ahora siempre van a tener la opci\u00f3n de revertir su c\u00f3digo hacia este commit.</li> <li>git push -u origin main manda todo el contenido del repositorio que est\u00e1 en el branch \"main\" al repositorio remoto \"origin\".</li> </ul> <p>Cuando est\u00e9n trabajando con git, y quieran asegurarse de que tienen una copia guardada del contenido actual de su c\u00f3digo, solo tienen que correr <code>git add .</code> y despu\u00e9s <code>git commit</code> en la terminal. En dado caso que no tengan cambios nuevos, esto no crear\u00e1 ning\u00fan commit. Por \u00faltimo pueden hacer <code>git push</code> para que tambi\u00e9n su c\u00f3digo est\u00e9 en la nube.</p>"},{"location":"labs/lab00/#ejercicio-3-alfabeto-binario","title":"Ejercicio 3: Alfabeto Binario","text":"<p>Vamos a utilizar n\u00fameros de 4 bits. Si apilamos cinco n\u00fameros de 4 bits uno encima de otro en binario, podemos crear patrones e im\u00e1genes. Para ayudarlos a visualizar esto, pueden pensar que un bit en cero es blanco y un bit en uno es negro. Por ejemplo miren el siguiente patr\u00f3n de bits.</p> <p></p>"},{"location":"labs/lab00/#preguntas","title":"Preguntas","text":"<ol> <li>\u00bfCu\u00e1les son los cinco n\u00fameros en decimal (separados por una coma) que producen el patr\u00f3n de arriba?</li> <li>\u00bfCu\u00e1les son los cinco digitos en hexadecimal (separados por una coma) que producen el patr\u00f3n de arriba?</li> <li>\u00bfQu\u00e9 letra se dibuja con los siguientes n\u00fameros en decimal: 1,1,9,9,6?</li> <li>\u00bfQu\u00e9 letra se dibuja con el siguiente numero en hexadecimal: 0xF8F88?</li> <li>\u00bfCu\u00e1l es el numero en hexadecimal para dibujar la letra b (min\u00fascula)?</li> <li>\u00bfUtilizar\u00edas cinco d\u00edgitos hexadecimales para dibujar la letra N? Contesten Si o No</li> </ol> <p>En los archivos del laboratorio van a encontrar un archivo de texto <code>ex3.txt</code> con lo siguiente:</p> <pre><code>1:\n2:\n3:\n4:\n5:\n6:\n</code></pre> <p>En este archivo tienen que colocar todas sus respuestas de las preguntas de arriba siguiendo ese formato por ejemplo un archivo valido ser\u00eda:</p> <pre><code>1:1,2,3,4,5\n2:0x1,0x2,0x3,0x4,0x5\n3:A\n4:A\n5:0xcafee\n6:Si/No\n</code></pre> <p>Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal:</p> <pre><code>git add ex3.txt\ngit commit -m \"ex3 complete\"\ngit push -u origin main\n</code></pre>"},{"location":"labs/lab00/#ejercicio-4-1000-billetes-de-1","title":"Ejercicio 4: 1,000 billetes de $1","text":"<p>Imaginen que tienen mil billetes de $1 y 10 sobres. Para este ejercicio tienen que encontrar una manera de poner una cantidad determinada de billetes de $1 en cada uno de los sobres de tal forma que, sin importar la cantidad de dinero que se les pida (entre $1 y $1000), simplemente entreguen una combinaci\u00f3n de los sobres y que siempre est\u00e9n seguros de que est\u00e1n dando la cantidad correcta. En los archivos del laboratorio hay un archivo de texto llamado <code>ex4.txt</code> en donde encontrar\u00e1n lo siguiente:</p> <pre><code>a,b,c,d,e,f,g,h,i,j\n</code></pre> <p>Cada una de las letras representa un sobre, tienen que reemplazar cada letra por la cantidad de billetes de $1 que crean correcta, esa cantidad tiene que ser <code>&gt;= 0</code> (en decimal) y recuerda que la suma de la cantidad de cada uno de los sobres tiene que ser igual a <code>1000</code>.</p> <p>Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal:</p> <pre><code>git add ex4.txt\ngit commit -m \"ex4 complete\"\ngit push -u origin main\n</code></pre>"},{"location":"labs/lab00/#entrega-y-calificacion","title":"Entrega y calificaci\u00f3n","text":"<p>Por favor subir el link de su repositorio al GES. Siempre es necesario que suban su repositorio al GES, incluso si no completaron todos los ejercicios, de lo contrario la nota ser\u00e1 de 0 puntos.</p> <p>La calificaci\u00f3n de este laboratorio ser\u00e1 de 0 a 100 puntos, donde 100 puntos es la calificaci\u00f3n m\u00e1xima. La calificaci\u00f3n se basar\u00e1 en la cantidad de ejercicios completados. Si tienen alguna duda sobre la calificaci\u00f3n, por favor env\u00eden un correo a los auxiliares.</p> <p>Para subir su laboratorio al autograder deben hacer lo siguiente, estando en la carpeta del laboratorio:</p> <pre><code>autograder assignment submit\n</code></pre> <p>Si por alguna razon les pide que ingresen el id de la asignaci\u00f3n, pueden ingresar el siguiente id: <code>966a5593-4aac-44b3-9c99-bed2f5d77b6e</code>.</p> <p>Una vez suban su laboratorio al autograder, les va a salir un mensaje como el siguiente:</p> <pre><code> _\n|-|  __\n|=| [Ll]        Autograder\n\"^\" ====`o\n\n=&gt;    Assignment | Submit\n\n\u2714 Got assignment info successfully!\n\u2714 Files zipped successfully!\n\u2714 Files uploaded successfully!\n\u2714 Assignment submitted successfully!\n\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 Id           \u2502 e58e7f1c-96ae-477a-8851-77ba16bf7443 \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Status       \u2502 SUBMITTED                            \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Submitted At \u2502 10 Feb, 2023 06:18:21 pm             \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre> <p>Para ver el estado de su laboratorio pueden hacer lo siguiente:</p> <pre><code>autograder submit last\n</code></pre> <p>Si ya est\u00e1 calificado, les va a salir un mensaje como el siguiente:</p> <pre><code> _\n|-|  __\n|=| [Ll]        Autograder\n\"^\" ====`o\n\n=&gt;    Submission | Last\n\nPlease enter the assignment id:\n\n? Assignment id:  966a5593-4aac-44b3-9c99-bed2f5d77b6e\n\n\u2714 Got submission info successfully!\n\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 Id     \u2502 e58e7f1c-96ae-477a-8851-77ba16bf7443 \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Grade  \u2502 100                                  \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Status \u2502 GRADED                               \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\nStdout:\n\n1. Hello\n\n...\n\n3. Binary Alphabet\n\n...\n\n4. 1,000 $1 Bills\n\n...\n</code></pre> <p>Pueden subir su laboratorio 3 veces, pero solo se tomar\u00e1 en cuenta la entrega que tenga la calificaci\u00f3n m\u00e1s alta. Si no les gusta la calificaci\u00f3n que obtuvieron, pueden volver a subir su laboratorio hasta que obtengan la calificaci\u00f3n que desean.</p>"},{"location":"labs/lab01/","title":"Lab 1 - Punteros en C y GDB","text":""},{"location":"labs/lab01/#objetivos","title":"Objetivos","text":"<ul> <li>Aprender c\u00f3mo compilar y ejecutar un programa en C.</li> <li>Examinar diferentes tipos de control de flujo en C.</li> <li>Introducirlos al debugger (depurador) de C</li> <li>Conseguir experiencia pr\u00e1ctica utilizando GBD para depurar programas en C.</li> <li>Ganar m\u00e1s confianza al trabajar con punteros.</li> </ul>"},{"location":"labs/lab01/#preparacion","title":"Preparaci\u00f3n","text":"<p>Visiten este link. Aqu\u00ed encontrar\u00e1n todos los archivos necesarios para completar este lab. En esta p\u00e1gina, encontrar\u00e1n un bot\u00f3n que dice \"Accept assignment\". Al presionar este bot\u00f3n, se crear\u00e1 autom\u00e1ticamente un repositorio en Github llamado <code>www.github.com/cc3-an/2023-lab-01-c-gdb-USUARIO</code>. Noten que el \"due\u00f1o\" de este repositorio es un usuario llamado <code>cc3-an</code>, y el usuario de ustedes es \u00fanicamente el sufijo del nombre del repo. De esta forma, nos encargamos de tener acceso siempre a su c\u00f3digo, en caso existan copias o cualquier otro tipo de trampa. Sepan de una vez que, si encontramos plagio o cualquier otro tipo de trampa en sus laboratorios, su nota ser\u00e1 AUTOM\u00c1TICAMENTE 0, sin posibilidad de cambiarla. De repetirse nuevamente este acontecimiento, el staff del curso organizar\u00e1 una reuni\u00f3n con ustedes y sus directores de carrera para contarles lo ocurrido y sancionarlos conforme al reglamento de la universidad.</p> <p>Despu\u00e9s de realizar esto, en la m\u00e1quina virtual (o sus propias computadoras) abran una terminal en el directorio que prefieran, y ejecuten el siguiente comando:</p> <pre><code>git clone https://github.com/cc3-an/2023-lab-01-c-gdb-&lt;USUARIO DE GITHUB AQUI&gt;\n</code></pre> <p>Esto descargar\u00e1 en el directorio que escogieron todos los archivos base para este laboratorio. Un <code>clone</code> solo lo hacemos la primera vez que vamos a bajar el codigo de un repositorio a nuestra maquina. Nunca bajen el zip que Github les ofrece, por favor, eso solo nos va a causar problemas.</p> <p>Recuerden que es necesario que hayan le\u00eddo el tutorial de git y GitHub que se encuentra en la p\u00e1gina del curso, as\u00ed como tambi\u00e9n el tutorial del autograder.</p>"},{"location":"labs/lab01/#compilando-y-ejecutando-un-programa-de-c","title":"Compilando y ejecutando un programa de C","text":"<p>En este laboratorio, estaremos usando el programa <code>gcc</code> para compilar programas en c. La manera m\u00e1s sencilla de ejecutar <code>gcc</code> es la siguiente:</p> <pre><code>gcc program.c\n</code></pre> <p>Esto compila el archivo <code>program.c</code> y crea un archivo ejecutable llamado <code>a.out</code>. Si tienen experiencia en Java, pueden m\u00e1s o menos considerar a <code>gcc</code> como el equivalente en C de <code>javac</code>. Este archivo se puede ejecutar con el siguiente comando:</p> <pre><code>./a.out\n</code></pre> <p>El archivo ejecutable es <code>a.out</code>, as\u00ed que, \u00bfqu\u00e9 es eso de punto y diagonal? La respuesta: cuando quieren ejecutar un ejecutable, es necesario preponer una ruta de archivo para distinguirlo de un comando como <code>python</code> (no se utiliza <code>./python</code>). El punto se refiere al \"directorio actual\". De paso, dos puntos (..) se referir\u00edan al directorio que est\u00e1 un nivel arriba.</p> <p><code>gcc</code> tiene varias opciones (o argumentos) de l\u00ednea de comandos, los cuales les recomendamos explorar. En este laboratorio, vamos a estar usando solamente -o, que se usa para especificar el nombre del ejecutable que <code>gcc</code> genera. Usando -o, se utilizar\u00edan estos comandos para compilar <code>program.c</code> en un archivo llamado <code>program</code>, y ejecutarlo. Eso nos sirve si no queremos que todos nuestros archivos ejecutables se llamen <code>a.out</code>.</p> <pre><code>gcc -o program program.c\n./program\n</code></pre>"},{"location":"labs/lab01/#ejercicio-1-programa-simple-de-c","title":"Ejercicio 1: Programa simple de C","text":"<p>En este ejercicio, veremos un ejemplo de definiciones macro de preprocesador. Las macros pueden ser un tema complicado, pero en general, la forma en que funcionan es que, antes de que un archivo en C es compilado, las constantes macro son reemplazadas exactamente por el valor al que se refieren. En este ejercicio, estaremos usando macros exclusivamente como constantes globales. Aqu\u00ed definimos <code>CONSTANT_NAME</code> como un <code>literal_value</code> (una literal entera). Noten que solo hay 1 espacio separando el nombre del valor.</p> <pre><code>#define CONSTANT_NAME LITERAL_VALUE\n</code></pre> <p>Ahora, vean el c\u00f3digo en eccentric.c (en el repo). Noten los cuatro diferentes ejemplos de control b\u00e1sico de flujo. (\u00bfCu\u00e1les son?) Compilen y ejecuten el programa para ver lo que hace. Jueguen con las constantes de las cuatro macros: <code>v0</code> a <code>v3</code>. Vean c\u00f3mo cambiar cada uno de estos cambia el output del programa. Su tarea: Modificando s\u00f3lo estos cuatro valores, hagan que el programa produzca el siguiente mensaje:</p> <pre><code>$ gcc -o eccentric eccentric.c\n$ ./eccentric\nBerkeley eccentrics:\n====================\nHappy Happy Happy\nYoshua\n\nGo BEARS!\n</code></pre> <p>Hay m\u00faltiples combinaciones de valores en las macros que consiguen este resultado, El reto para ustedes en este ejercicio es: Consideren el m\u00ednimo n\u00famero de distintos valores que las constantes <code>v0</code> a <code>v3</code> puedan tener que a\u00fan den el mismo resultado correcto. Como ejemplo, el m\u00e1ximo te\u00f3rico es cuatro (cuando todos son diferentes uno de otro).</p> <p>Cuando ya hayan logrado esto, pueden actualizar el archivo en su repositorio en Github, de esta manera:</p> <pre><code>$ git add eccentric.c\n$ git commit -m \"Ejercicio 1 terminado\"\n$ git push -u origin main\n</code></pre>"},{"location":"labs/lab01/#ejercicio-2-debugger-depurador","title":"Ejercicio 2: Debugger (depurador)","text":""},{"location":"labs/lab01/#que-es-un-debugger","title":"\u00bfQu\u00e9 es un debugger?","text":"<p>Este p\u00e1rrafo es para los estudiantes que no est\u00e1n familiarizados con los debuggers. Un debugger, como sugiere el nombre, es un programa espec\u00edficamente dise\u00f1ado para ayudarlos a encontrar bugs, o errores l\u00f3gicos, u otros errores en el c\u00f3digo (nota: si quieren saber por qu\u00e9 se les llama bugs a los errores, vean aqu\u00ed). Distintos debuggers tienen distintas caracter\u00edsticas, pero es normal que todos los debuggers sean capaces de hacer las siguientes cosas:</p> <ol> <li>Poner un breakpoint en el programa. Un Breakpoint es una l\u00ednea espec\u00edfica en su c\u00f3digo en donde quisieran que se detenga la ejecuci\u00f3n del programa, para que puedan ver lo que est\u00e1 pasando alrededor.</li> <li>Ejecuci\u00f3n por Steps (l\u00ednea a l\u00ednea) por el programa. El c\u00f3digo siempre se ejecuta l\u00ednea a l\u00ednea, pero pasa muy r\u00e1pido como para que sepamos qu\u00e9 l\u00ednea produce alg\u00fan error. Ser capaces de ejecutar l\u00ednea a l\u00ednea el programa les permite observar exactamente qu\u00e9 esta causando un bug en el programa.    Para este ejercicio, necesitar\u00e1n la GDB reference card. GDB quiere decir \"GNU De-Bugger\". Compilen hello.c con la bandera \"-g\":</li> </ol> <pre><code>gcc -g -o hello hello.c\n</code></pre> <p>Esto har\u00e1 que gcc guarde informaci\u00f3n en el archivo ejecutable para que gdb lo interprete. Ahora ejecuten el debugger, (c)gdb:</p> <pre><code>cgdb hello\n</code></pre> <p>Vean lo que hace este comando. Est\u00e1n ejecutando el programa <code>cgdb</code> en el ejecutable <code>hello</code> generado por <code>gcc</code>. No intenten ejecutar cgdb en el archivo fuente en <code>hello.c</code>! Eso no va a funcionar. Si cgdb no funciona, gdb se puede usar para completar los ejercicios (utilicen <code>gdb hello</code>). Su tarea: ejecuten el programa varias veces haciendo esto:</p> <ol> <li>Poniendo un breakpoint en el main.</li> <li>Usando el comando run de gdb.</li> <li>Utilizando el comando single-step de gdb.</li> </ol> <p>Escriban <code>help</code> adentro de gdb para averiguar c\u00f3mo hacer estas cosas, o usen la reference card.</p> <p>Si encuentran un mensaje de error que dice: <code>printf.c: No such file or directory</code>. Probablemente entraron a una funci\u00f3n <code>printf</code>. Si siguen ejecutando paso a paso, pareciera que nunca avanzaran en el c\u00f3digo. CGDB est\u00e1 dando el error porque no tienen el archivo en el que se define la funci\u00f3n <code>printf</code>. Esto es algo molesto, y para librarse de esto, usen el comando <code>finish</code> para ejecutar el programa hasta que termine la funci\u00f3n printf. Y la pr\u00f3xima vez, utilicen el comando <code>next</code> para saltar sobre la linea que usa <code>printf</code>.</p> <p>Nota: CGDB vs GDB.</p> <p>En este ejercicio, usamos cgdb para depurar nuestros programas. cgdb es id\u00e9ntico a gdb, excepto que tiene unas caracter\u00edsticas extra que hacen m\u00e1s c\u00f3modo el trabajo. Todos los comandos de la hoja de referencia funcionan tambi\u00e9n en gdb. En cgdb, pueden presionar <code>ESC</code>para ir a la ventana del c\u00f3digo (arriba), y usar <code>i</code> para regresar a la ventana de comandos (abajo), similar a <code>vim</code>. La ventana de comandos es donde se introducen los comandos de gdb.</p> <p>Para este ejercicio, encontrar\u00e1n un archivo de texto llamado ex2.txt, con el siguiente formato:</p> <pre><code>1:\n2:\n3:\n4:\n5:\n6:\n7:\n8:\n9:\n</code></pre> <p>Aqu\u00ed tendr\u00e1n que responder las siguientes preguntas de opci\u00f3n m\u00faltiple (no tengan miedo de probar las opciones en CGDB antes de responder, \u00a1lo recomendamos!) con el siguiente formato (tienen que cambiar la letra en el ejemplo por la letra de la respuesta que ustedes consideren correcta):</p> <pre><code>1:e\n2:f\n3:g\n4:h\n5:i\n6:j\n7:k\n8:l\n9:m\n</code></pre> <p>Preguntas</p> <p>1. \u00bfC\u00f3mo se le dan argumentos desde la l\u00ednea de comandos a un programa al utilizar gdb?</p> <ul> <li>a. args arglist</li> <li>b. run arglist</li> <li>c. gdb args</li> <li>d. Ninguna de las anteriores</li> </ul> <p>2. \u00bfC\u00f3mo se a\u00f1ade un breakpoint que s\u00f3lo ocurre cuando se cumplen ciertas condiciones (por ejemplo, ciertas variables alcanzan cierto valor)?</p> <ul> <li>a. expr cond</li> <li>b. cond break expr</li> <li>c. break ... if expr</li> <li>d. Ninguna de las anteriores</li> </ul> <p>3. \u00bfCon qu\u00e9 comando se ejecuta la siguiente l\u00ednea del c\u00f3digo en C despu\u00e9s de parar en un breakpoint?</p> <ul> <li>a. run</li> <li>b. s</li> <li>c. c</li> <li>d. n</li> </ul> <p>4. Si la siguiente l\u00ednea de c\u00f3digo es una llamada a funci\u00f3n, \u00bfse ejecutar\u00eda toda la funci\u00f3n si se utiliza el comando de la pregunta #3? (si no, es momento de cambiarla!). \u00bfC\u00f3mo se le indica a gdb, que quieren debuggear el c\u00f3digo adentro de la funci\u00f3n? (Si tuvieron que cambiar la respuesta #3, esa respuesta muy probablemente aplica aqu\u00ed)</p> <ul> <li>a. run</li> <li>b. s</li> <li>c. c</li> <li>d. n</li> </ul> <p>5. \u00bfC\u00f3mo se reanuda la ejecuci\u00f3n del programa despu\u00e9s de parar en un breakpoint?</p> <ul> <li>a. run</li> <li>b. s</li> <li>c. c</li> <li>d. n</li> </ul> <p>6. \u00bfC\u00f3mo podemos ver el valor de una variable (o expresi\u00f3n) en gdb?</p> <ul> <li>a. display expr</li> <li>b. signal expr</li> <li>c. print expr</li> <li>d. next expr</li> </ul> <p>7. \u00bfQu\u00e9 comando de gdb se usa para desplegar el valor de una variable despu\u00e9s de cada paso?</p> <ul> <li>a. display expr</li> <li>b. signal expr</li> <li>c. print expr</li> <li>d. next expr</li> </ul> <p>8. \u00bfC\u00f3mo se imprime una lista de todas las variables y su valor en la funci\u00f3n actual?</p> <ul> <li>a. display all</li> <li>b. display</li> <li>c. print all</li> <li>d. print</li> </ul> <p>9. \u00bfC\u00f3mo salimos de gdb?</p> <ul> <li>a. end</li> <li>b. quit</li> <li>c. exit</li> <li>d. finish</li> </ul> <p>Despu\u00e9s de responder estas preguntas, no olviden hacer el commit y push de este archivo hacia Github:</p> <pre><code>$ git add ex2.txt\n$ git commit -m \"Ejercicio 2 terminado\"\n$ git push -u origin main\n</code></pre>"},{"location":"labs/lab01/#ejercicio-3-depurando-un-problema-con-fallas-usando-gdb","title":"Ejercicio 3: Depurando un problema con fallas usando GDB","text":"<p>Ahora, usar\u00e1n su nuevo conocimiento para depurar un peque\u00f1o programa. Vean el programa <code>ll_equal.c</code>. Compilen y ejecuten el programa, y analicen un poco lo que hace. As\u00ed como est\u00e1, producir\u00e1 un resultado como el siguiente:</p> <pre><code>$ gcc -g -o ll_equal ll_equal.c\n$ ./ll_equal\nequal test 1 result = 1\nSegmentation fault\n</code></pre> <p>Averig\u00fcen qu\u00e9 produce el segmentation fault (falla de segmentaci\u00f3n).</p> <p>Ejecuten gdb en el programa, siguiendo las instrucciones aprendidas en los ejercicios anteriores. Les recomendamos a\u00f1adir un breakpoint en la funci\u00f3n <code>ll_equal()</code>. Cuando el debugger pare en el breakpoint, ejecuten paso a paso el programa, para que puedan descifrar qu\u00e9 es lo que provoca el error.</p> <p>Pista: Analicen el valor de los punteros <code>a</code> y <code>b</code> en la funci\u00f3n (\u00a1despli\u00e9guenlos!). \u00bfEst\u00e1n siempre apuntando a la direcci\u00f3n correcta?</p> <p>Pista 2: Vean el c\u00f3digo fuente en <code>main</code> para ver la estructura de los nodos y ver exactamente qu\u00e9 est\u00e1 pasando como argumento a <code>ll_equal</code>.</p> <p>Despu\u00e9s de corregir el problema, compilen nuevamente y ejecuten el c\u00f3digo. \u00bfNotan la diferencia?</p> <p>Al finalizar, no olviden subir el archivo modificado a su repositorio remoto:</p> <pre><code>$ git add ll_equal.c\n$ git commit -m \"Ejercicio 2 terminado\"\n$ git push -u origin main\n</code></pre>"},{"location":"labs/lab01/#ejercicio-4-debuggeando-un-programa-en-c-que-requiere-interaccion-del-usuario","title":"Ejercicio 4: \"Debuggeando\" un programa en C que requiere interacci\u00f3n del usuario","text":"<p>Veamos qu\u00e9 pasa cuando, a un programa que requiere interacci\u00f3n del usuario, lo ejecutamos con gdb. Primero, ejecuten el programa en <code>interactive_hello.c</code> para hablar con un programa muy amigable :).</p> <pre><code>$ gcc -g -o int_hello interactive_hello.c\n$ ./int_hello\n</code></pre> <p>Ahora, traten de depurarlo (aunque no haya ning\u00fan problema realmente):</p> <pre><code>$ cgdb int_hello\n</code></pre> <p>\u00bfQu\u00e9 pasa cuando intentar ejecutar el programa hasta el final? Vamos a aprender acerca de una herramienta que nos ayudar\u00e1 a evitar este problema. El prop\u00f3sito de este ejercicio es que no tengan miedo de usar un debugger incluso cuando el programa requiera de interacci\u00f3n con el usuario.</p> <p>Resulta que es posible enviar texto a stdin, el flujo de datos que es le\u00eddo por la funci\u00f3n <code>fgets</code> en este programa, con unos caracteres especiales desde la l\u00ednea de comandos. Echen un vistazo a la \"redirecci\u00f3n\" en esta p\u00e1gina, y vean si pueden descifrar c\u00f3mo enviar texto al programa sin escribirlo textualmente mientras el programa est\u00e1 en ejecuci\u00f3n (lo cual, como ya saben, no funciona bien en CGDB).</p> <p>Pueden ver esta discusi\u00f3n de stackoverflow para m\u00e1s inspiraci\u00f3n.</p> <p>(Pista 1: \u00a1Si est\u00e1n creando un archivo de texto que contiene su input, van bien!)</p> <p>(pista 2: Recuerden que es posible ejecutar programas con argumentos (incluyendo s\u00edmbolos de redirecci\u00f3n) desde CGDB!</p> <p>Esperamos que hayan comprendido c\u00f3mo utilizar redirecci\u00f3n y c\u00f3mo es que esto les ayuda a evitar varios problemas al usar CGDB. \u00a1Nunca tengan miedo de usar un debugger! Tal vez no es muy agradable visualmente, pero siempre estar\u00e1 para ayudarlos.</p> <p>Este ejercicio no vale puntos :-) pero es importante conocer sobre estas cosas para que puedan utilizarlo en el futuro (los siguientes laboratorios y proyectos podr\u00edan necesitar de este conocimiento)</p>"},{"location":"labs/lab01/#ejercicio-5-punteros-y-estructuras-en-c","title":"Ejercicio 5: Punteros y estructuras en C","text":"<p>En llcycle.c, completen la funci\u00f3n ll_has_cycle(), de modo que implemente el siguiente algoritmo para comprobar si una _linked list simple tiene un ciclo:</p> <ol> <li>Comiencen con dos punteros apuntando al principio de la lista. Llamaremos al primero <code>tortoise</code> (tortuga) y al segundo <code>hare</code> (liebre).</li> <li>Avancen el puntero <code>hare</code> dos nodos hacia adelante. Si no se puede debido a punteros null, hemos llegado al final de la lista. Por lo tanto, la lista no tiene un ciclo.</li> <li>Ahora, avancen <code>tortoise</code> un nodo. (Revisar si llega a ser un puntero nulo es innecesario. \u00bfPor qu\u00e9?)</li> <li>Si la tortuga y la liebre apuntan al mismo nodo, la lista es c\u00edclica. Si no, regresen al paso 2.</li> </ol> <p>Despu\u00e9s de implementar correctamente la funci\u00f3n <code>ll_has_cycle()</code>, el programa que se obtiene despu\u00e9s de compilar <code>ll_cycle.c</code> mostrar\u00e1 si el resultado de su funci\u00f3n est\u00e1 correcto, conforme a lo que esperaba como salida.</p> <p>Pista: Hay dos formas comunes en que los estudiantes resuelven esta funci\u00f3n, y la diferencia principal est\u00e1 en la forma en que deciden codificar el criterio de c\u00f3mo finalizar. Si lo hacen de una forma, tendr\u00edan que tomar en cuenta un caso especial en el principio. Si lo hacen de otra forma, tendr\u00edan que tener unas pruebas extra de NULL, lo cual esta bien tambi\u00e9n. Les decimos esto para que no se preocupen de la \"limpieza\" de su c\u00f3digo, si no les ayuda, simplemente ignoren esta pista. El punto de este ejercicio es asegurarse de que entiendan como usar punteros.</p> <p>Aqu\u00ed hay un Art\u00edculo del algoritmo y por qu\u00e9 funciona. No se preocupen de entender completamente todo (no hay examen de esto).</p> <p>A prop\u00f3sito, los punteros se llaman <code>tortoise</code> y <code>hare</code> porque el puntero \"tortoise (tortuga)\" se incrementa lentamente (como una tortuga, que se mueve muy lento) y el puntero \"hare (liebre)\" se incrementa r\u00e1pidamente (m\u00e1s r\u00e1pido que una tortuga, como una liebre, o conejo, que se mueve muy r\u00e1pido).</p> <p>Al finalizar, compilen y ejecuten el archivo, y verifiquen que el resultado de su c\u00f3digo, el cual deber\u00eda ser m\u00e1s o menos igual a este:</p> <pre><code>$ gcc -g -o ll_cycle ll_cycle.c\n$ ./ll_cycle\nChecking first list for cycles. There should be none, ll_has_cycle says it has no cycle\nChecking second list for cycles. There should be a cycle, ll_has_cycle says it has a cycle\nChecking third list for cycles. There should be a cycle, ll_has_cycle says it has a cycle\nChecking fourth list for cycles. There should be a cycle, ll_has_cycle says it has a cycle\nChecking fifth list for cycles. There should be none, ll_has_cycle says it has no cycle\nChecking length-zero list for cycles. There should be none, ll_has_cycle says it has no cycle\n</code></pre> <p>Si su c\u00f3digo presenta errores, entonces ya son capaces de utilizar CGDB para poder encontrarlos y corregirlos. Finalmente, pueden subir el archivo a github:</p> <pre><code>$ git add ll_cycle.c\n$ git commit -m \"LAB01 terminado\"\n$ git push -u origin main\n</code></pre> <p>Para finalizar, la f\u00e1bula de la tortuga y la liebre es relevante siempre, especialmente en este curso. Escribir sus programas en C a paso lento pero seguro (ayud\u00e1ndose de programas como CGDB) es lo que les har\u00e1 ganar la carrera.</p>"},{"location":"labs/lab01/#entrega-y-calificacion","title":"Entrega y calificaci\u00f3n","text":"<p>Por favor subir el link de su repositorio al GES. Siempre es necesario que suban su repositorio al GES, incluso si no completaron todos los ejercicios, de lo contrario la nota ser\u00e1 de 0 puntos.</p> <p>La calificaci\u00f3n de este laboratorio ser\u00e1 de 0 a 100 puntos, donde 100 puntos es la calificaci\u00f3n m\u00e1xima. La calificaci\u00f3n se basar\u00e1 en la cantidad de ejercicios completados. Si tienen alguna duda sobre la calificaci\u00f3n, por favor env\u00eden un correo a los auxiliares.</p> <p>Para subir su laboratorio al autograder deben hacer lo siguiente, estando en la carpeta del laboratorio:</p> <pre><code>autograder assignment submit\n</code></pre> <p>Si por alguna razon les pide que ingresen el id de la asignaci\u00f3n, pueden ingresar el siguiente id: <code>bf955a5e-35fe-4408-b796-9eb3bf55cd63</code>.</p> <p>Una vez suban su laboratorio al autograder, les va a salir un mensaje como el siguiente:</p> <pre><code> _\n|-|  __\n|=| [Ll]        Autograder\n\"^\" ====`o\n\n=&gt;    Assignment | Submit\n\n\u2714 Got assignment info successfully!\n\u2714 Files zipped successfully!\n\u2714 Files uploaded successfully!\n\u2714 Assignment submitted successfully!\n\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 Id           \u2502 e58e7f1c-96ae-477a-8851-77ba16bf7443 \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Status       \u2502 SUBMITTED                            \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Submitted At \u2502 10 Feb, 2023 06:18:21 pm             \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre> <p>Para ver el estado de su laboratorio pueden hacer lo siguiente:</p> <pre><code>autograder submit last\n</code></pre> <p>Si ya est\u00e1 calificado, les va a salir un mensaje como el siguiente:</p> <pre><code> _\n|-|  __\n|=| [Ll]        Autograder\n\"^\" ====`o\n\n=&gt;    Submission | Last\n\n\u2714 Got submission info successfully!\n\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 Id     \u2502 a1f1f397-0e08-448a-86e6-aab8c47fff57 \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Grade  \u2502 100                                  \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Status \u2502 GRADED                               \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\nStdout:\n\n1. Eccentric\n\n...\n\n2. CGDB\n\n...\n\n3. LL Equal\n\n...\n\n4. LL Cycle\n\n...\n</code></pre> <p>Pueden subir su laboratorio 10 veces, pero solo se tomar\u00e1 en cuenta la entrega que tenga la calificaci\u00f3n m\u00e1s alta. Si no les gusta la calificaci\u00f3n que obtuvieron, pueden volver a subir su laboratorio hasta que obtengan la calificaci\u00f3n que desean.</p>"},{"location":"labs/lab02/","title":"Lab 2 - C Avanzado y Manejo de Memoria","text":""},{"location":"labs/lab02/#objetivos","title":"Objetivos","text":"<ul> <li>Manipular los bits de n\u00fameros binarios.</li> <li>Aprendan a utilizar sus nuevos poderes.</li> <li>Practicar trabajar con la asignaci\u00f3n de memoria de manera din\u00e1mica (esa cosa de malloc).</li> <li>Aprovechar toda la memoria no utilizada.</li> <li>Pensar c\u00f3mo el manejo de memoria din\u00e1mica los puede hacer mejores personas.</li> <li>Son bromas, pero s\u00f3lo los puede volver mejores programadores.</li> </ul>"},{"location":"labs/lab02/#preparacion","title":"Preparaci\u00f3n","text":"<p>De primero, deben de descargar todos los archivos que necesitar\u00e1n para completar este laboratorio, estos se encuentran aqu\u00ed. Recuerden que deben aceptar la asignaci\u00f3n y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario. Recuerden que este ser\u00e1 revisado en b\u00fasqueda de copia o plagio, as\u00ed que no lo hagan. De lo contrario, ser\u00e1 sancionado acorde al reglamento de la universidad.</p> <p>Ahora, ya pueden ejecutar en la terminal el comando que les descargar\u00e1 los archivos base en el directorio a su elecci\u00f3n:</p> <pre><code>git clone link_al_lab\n</code></pre>"},{"location":"labs/lab02/#ejercicio-1-operando-bits","title":"Ejercicio 1: Operando Bits","text":"<p>Para este inciso, su trabajo es completar los archivos ex1/get_bit.c, ex1/set_bit.c y ex1/flip_bit.c de manera que las funciones cumplan con su tarea (as\u00ed como el nombre de las funciones sugiere). Para ello deber\u00e1n utilizar las operaciones de bits b\u00e1sicas: and (&amp;), or (|), xor (^), not (~) y los corrimientos a la derecha (&gt;&gt;) y a la izquierda (&lt;&lt;). Deben evitar el uso de ciclos o condicionales.</p> <p>\u00a1\u00a1\u00a1\u00a1No usen ciclos ni condicionales!!!! Eso significa que mientras realicen el ejercicio no pueden y no deben de escribir las palabras: if, else, do, while, for, switch o algo de \u00edndole similar. Por favor no traten de enga\u00f1arnos, todo el personal involucrado (esperamos) sabe c\u00f3mo se miran todas estas palabras, entonces si encontramos una de ellas...</p> <p> El autograder analiza su c\u00f3digo de todas formas... \u00af\\_(\u30c4)_/\u00af sorry not sorry </p> <p>NOTA IMPORTANTE: Considerar que n es un valor que inicia en la posici\u00f3n cero, contando desde la derecha, por lo que el bit que se encuentra hasta la derecha es el bit cero.</p> <pre><code>// Return the nth bit of x.\n// Assume 0 &lt;= n &lt;= 31\nunsigned get_bit(unsigned x,\nunsigned n);\n\n// Set the nth bit of the value of x to v.\n// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1\nvoid set_bit(unsigned * x,\nunsigned n,\nunsigned v);\n\n// Flip the nth bit of the value of x.\n// Assume 0 &lt;= n &lt;= 31\nvoid flip_bit(unsigned * x,\nunsigned n);\n</code></pre> <p>Ayuda para set_bit: La parte complicada es no saber el valor del bit antes de cambiarlo. Pero, sabemos que 0 | x = x, pero \u00bfpodemos aprovecharnos de esto? \u00bfEs posible volverlo cero?</p> <p>Una vez terminen de editar las funciones, pueden compilar y correr el c\u00f3digo con:</p> <pre><code>make bit_ops\n./bit_ops\n</code></pre> <p>Lo cual imprimir\u00e1 el resultado de algunas pruebas. Si tienen curiosidad pueden revisar con libertad la carpeta tests/ que contiene las pruebas que se van a realizar en cada ejercicio de este laboratorio y que reflejan bastante lo que evaluar\u00e1 el autograder, por ejemplo el archivo que se utiliza para este ejercicio es tests/bit_ops_test.c. De ahora en adelante hasta que esten 100% seguros de que tienen completo el laboratorio o ya est\u00e9 cerca la hora de entregar su laboratorio, pueden mandar sus archivos como en los laboratorios pasados utilizando <code>./submit &lt;TOKEN&gt;</code>.</p> <p>Acu\u00e9rdense de realizar el proceso de \"hacerle push\" al archivo para subirlo al repositorio de GitHub.</p>"},{"location":"labs/lab02/#ejercicio-2-registro-de-corrimiento-con-retroalimentacion-lineal","title":"Ejercicio 2: Registro de Corrimiento con Retroalimentaci\u00f3n Lineal","text":"<p>En este ejercicio deben de implementar una funci\u00f3n que compute la siguiente iteraci\u00f3n de un registro de corrimiento de retroalimentaci\u00f3n lineal (LFSR por sus siglas en ingl\u00e9s). \u00a1Algunas aplicaciones que utilizan LFSRs son: televisi\u00f3n digital, tel\u00e9fonos con acceso m\u00faltiple por divisi\u00f3n de c\u00f3digo, Ethernet, USB 3.0 y mucho m\u00e1s! Esta funci\u00f3n deber\u00e1 generar n\u00fameros pseudo-aleatorios utilizando operadores binarios. Para un poco de informaci\u00f3n adicional, pueden visitar el siguiente link de Wikipedia. En el archivo ex2/lfsr_calculate.c deben de completar la funci\u00f3n lfsr_calculate() de manera que realice lo siguiente:</p>"},{"location":"labs/lab02/#diagrama-del-hardware-explicacion-mas-abajo","title":"Diagrama del Hardware (Explicaci\u00f3n M\u00e1s Abajo)","text":""},{"location":"labs/lab02/#explicacion-del-diagrama-de-arriba","title":"Explicaci\u00f3n del Diagrama de Arriba","text":"<ul> <li>En cada llamada de lfsr_calculate(), deben de correr el contenido del registro un bit hacia la derecha.</li> <li>Este corrimiento no es ni l\u00f3gico, ni aritm\u00e9tico. En el lado izquierdo deben de colocar un bit equivalente a un XOR de los bits que estaban, originalmente, en las posiciones 1, 3, 4 y 6.</li> <li>El objeto que parece un faro de autom\u00f3vil curvado es un XOR, el cual recibe dos entradas (a, b) y devuelve en su salida a^b.</li> <li>A diferencia del ejercicio 1, las posiciones de los bits inician con 1.</li> </ul> <p>Despu\u00e9s que hayan implementado de manera correcta lfsr_calculate(), compilen y c\u00f3rranlo. Su respuesta debe ser similar a lo siguiente:</p> <pre><code>make lfsr\n./lfsr\nMy number is: 1\nMy number is: 5185\nMy number is: 38801\nMy number is: 52819\nMy number is: 21116\nMy number is: 54726\nMy number is: 26552\nMy number is: 46916\nMy number is: 41728\nMy number is: 26004\nMy number is: 62850\nMy number is: 40625\nMy number is: 647\nMy number is: 12837\nMy number is: 7043\nMy number is: 26003\nMy number is: 35845\nMy number is: 61398\nMy number is: 42863\nMy number is: 57133\nMy number is: 59156\nMy number is: 13312\nMy number is: 16285\n... etc etc ...\nGot 65535 numbers before cycling!\nCongratulations! It works!\n</code></pre> <p>De nuevo, recu\u00e9rdense de hacer el push.</p>"},{"location":"labs/lab02/#ejercicio-3-manejo-de-memoria","title":"Ejercicio 3: Manejo de Memoria","text":"<p>Este ejercicio requiere de los archivos: tests/include/vector.h, tests/vector_test.c y ex3/vector.c, en donde les proveemos con la base para la implementaci\u00f3n de un arreglo de longitud variable. Este inciso busca que se familiaricen con el uso de los \"structs\" de C, as\u00ed como el manejo de memoria en este lenguaje. En otras palabras, no se preocupen por los detalles pr\u00e1cticos de esta estructura de datos un tanto extra\u00f1a. S\u00f3lo no lo hagan.</p> <p>Su trabajo es completar las funciones  vector_new(), vector_get(), vector_delete() y vector_set() en ex3/vector.c de manera que tests/vector-test.c corra sin errores de manejo de memoria.</p>"},{"location":"labs/lab02/#como-funciona-un-vector_t","title":"\u00bfC\u00f3mo funciona un vector_t?","text":"<ul> <li>Posee un int size que indica cu\u00e1ntos elementos posee actualmente. En otras palabras, el size es igual al \u00edndice de la \u00faltima posici\u00f3n que ha sido alterada del vector. Por ejemplo, si se tiene un vector con un size de 5 y se altera su ducent\u00e9cimo bit (\u00edndice iniciando en cero), su tama\u00f1o se ver\u00e1 actualizado a 201. La longitud por defecto del vector vector_new es de 1.</li> <li>Tiene un int *data, un arreglo din\u00e1mico de enteros que contiene los valores de los componentes del vector. Si se altera el ducent\u00e9cimo elemento de un vector v a 8 entonces el elemento modificado (de nuevo, iniciando en cero) de v-&gt;data deber\u00eda evaluar a 8. El valor de un vector vector_new es 0 por defecto.</li> <li>El valor de cualquier componente de alg\u00fan vector que no ha sido expl\u00edcitamente editado es 0. Si se deseara conocer el valor en la quinta posici\u00f3n de un vector, pero s\u00f3lo se ha alterado el valor de los primeras dos, la interrogante tendr\u00eda como respuesta 0. Adem\u00e1s, si se quisiera el contenido en la s\u00e9ptima posici\u00f3n de un vector de longitud igual a 5, tambi\u00e9n ser\u00eda 0. NO devolver\u00eda un error.</li> </ul> <p>Es momento de revisar el c\u00f3digo de ex3/vector.c si no lo han hecho. Aqu\u00ed hay comentarios complementarios que describen c\u00f3mo deber\u00edan de correr las funciones. Recuerden que los usuarios de su estructura de datos vector_t deben asumir que todas las entradas al vector son 0, a menos que hayan sido definidas de otra manera por ellos. Tengan esto en mente, porque malloc no hace esto por ustedes.</p>"},{"location":"labs/lab02/#que-deben-hacer","title":"\u00bfQu\u00e9 deben hacer?","text":"<ul> <li>Completen vector_new, la versi\u00f3n correcta. Hay exactamente seis (6) espacios para que escriban una expresi\u00f3n en C, indicados con el comentario que dice /* YOUR CODE HERE */. Escriban una expresi\u00f3n en estos sitios. Esto significa no m\u00e1s de una l\u00ednea de c\u00f3digo. Existen comentarios adicionales que describen qu\u00e9 deber\u00eda de suceder en la l\u00ednea de c\u00f3digo inferior a cada divisi\u00f3n.</li> <li>Terminen vector_get() de la misma manera en que lo hicieron para la funci\u00f3n anterior: de manera respetuosa, dispuesto a aprender, con mente abierta y conscientes de qu\u00e9 es lo que est\u00e1n escribiendo, ya que esta es la mejor forma de programar.</li> <li>Complementen vector_delete(). Una soluci\u00f3n satisfactoria no deber\u00eda de llevar m\u00e1s de dos l\u00edneas de c\u00f3digo.</li> <li>Corrijan a vector_set(). Esta es la m\u00e1s complicada. Bienvenidos a las ligas mayores. El problema de manipular una posici\u00f3n/\u00edndice arbitrario en un vector v es que es posible que no se haya reservado suficiente espacio con malloc en vector-&gt;data (s\u00ed, eso significa que tuvieron que haber guardado memoria con malloc). Piensen c\u00f3mo administrar la memoria para lograr esto, para ver qu\u00e9 hacer con la data que estaba ah\u00ed antes y de qu\u00e9 otras cosas deben de hacer en su nuevo bloque de datos. Ayuda: Recuerden que los \u00edndices que no hayan sido alterados deben de ser cero. Hay distintas formas de acabar resolviendo esta funci\u00f3n. Consideren el uso de las 3 funciones __alloc, porque pueden resultar \u00fatiles...</li> </ul> <p>Saber c\u00f3mo reorganizar y liberar memoria es importante para la programaci\u00f3n en C. Piensen que el manejo de memoria es como un parqueo, si hay carros parqueados y los due\u00f1os nunca se van, entonces no tienen espacio para nuevos carros. Y recuerden que deber\u00edan tener un 'heap' vac\u00edo al terminar su programa. Utilicen free y todo estar\u00e1 bien.</p>"},{"location":"labs/lab03/","title":"Lab 3 - RISC-V","text":""},{"location":"labs/lab03/#objetivos","title":"Objetivos","text":"<ul> <li>Practicar, corriendo y debuggeando c\u00f3digo ensamblador RISC-V.</li> <li>Escribir funciones en RISC-V con el procedimiento correcto de llamadas a funciones.</li> <li>Tener una idea de como traducir c\u00f3digo en C a RISC-V.</li> </ul>"},{"location":"labs/lab03/#lecturas","title":"Lecturas","text":"<ul> <li>P&amp;H: 2.12</li> </ul>"},{"location":"labs/lab03/#preparacion","title":"Preparaci\u00f3n","text":"<p>Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed. Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal (CTRL + T ):</p> <pre><code>git clone &lt;link del repositorio&gt;\n</code></pre> <p>NOTA: Tienen que reemplazar &lt;link del repositorio&gt; con el link del repositorio que se cre\u00f3.</p>"},{"location":"labs/lab03/#introduccion-a-lenguaje-ensamblador-risc-v","title":"Introducci\u00f3n a Lenguaje Ensamblador RISC-V","text":"<p>Los siguientes ejercicios utilizan un ensamblador y simulador de RISC-V, desarrollado por nuestro catedr\u00e1tico Ing. Andr\u00e9s Castellanos. El simulador se llama Jupiter (anteriormente V-Sim) y es un proyecto open source inspirado, inicialmente, en el lengendario SPIM y, posteriormente, en MARS y VENUS para la versi\u00f3n gr\u00e1fica.</p> <p> </p> <p>Para instalarlo en su computadora deben seguir estas instrucciones.</p> <p>M\u00e1quina virtual del curso</p> <p>Felicidades! No necesita instalar nada, puede ejecutar Jupiter usando el siguiente comando</p> <pre><code>jupiter\n</code></pre> <p>Ubuntu 18</p> <p>Debe instalar Jupiter usando estos comandos</p> <pre><code>sudo add-apt-repository ppa:andrescv/jupiter\nsudo apt-get update\nsudo apt-get install jupiter\n</code></pre> <p>Luego podr\u00e1 ejecutarlo usando el comando <code>jupiter</code></p> <p>Ubuntu 20</p> <p>Descargar este archivo. Ir a la carpeta donde lo descarg\u00f3 y ejecutar los siguientes comandos</p> <pre><code>unzip Jupiter-3.1-linux.zip\nsudo mv image /opt/jupiter\necho export\\ PATH=/opt/jupiter/bin:\\$PATH &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre> <p>Despu\u00e9s de esto, ya deber\u00eda poder usar el comando <code>jupiter</code>. Si no, la vieja y confiable, reinicie su computadora.</p>"},{"location":"labs/lab03/#cosas-basicas-en-jupiter","title":"Cosas b\u00e1sicas en Jupiter:","text":"<p>A continuaci\u00f3n, les vamos a dar una peque\u00f1a gu\u00eda de Jupiter, para m\u00e1s informaci\u00f3n visiten la p\u00e1gina de documentaci\u00f3n en https://jupitersim.gitbook.io/jupiter/.</p> <ul> <li>Pueden crear archivos, editarlos y borrarlos desde la pesta\u00f1a \"Editor\".</li> <li>Los programas empiezan en la etiqueta global <code>__start</code>, es decir que tienen que definir una etiqueta llamada <code>__start</code> y declararla como global.</li> </ul> <pre><code>.globl __start\n__start:\nli a0, 10\necall # exit\n</code></pre> <ul> <li>Las etiquetas terminan con dos puntos como ven en el ejemplo anterior.</li> <li>Los comentarios comienzan con el simbolo \"#\" o \";\".</li> <li>NO PUEDEN poner m\u00e1s de una instrucci\u00f3n por l\u00ednea.</li> <li>Cuando hayan terminado de editar las instrucciones que conforman su c\u00f3digo, guarden y presionen F3 para preparar la ejecuci\u00f3n.</li> <li>Los programas siempre tienen que terminar con un <code>ecall</code> de exit y esto se logra poniendo un 10 en <code>a0</code> (exactamente como el ejemplo anterior). Esto le indica al programa que tiene que terminar. Las instrucciones <code>ecall</code> son an\u00e1logas a los \"System Calls\" (llamadas al sistema) y nos permiten hacer cosas como imprimir a consola o reservar memoria din\u00e1mica.</li> </ul>"},{"location":"labs/lab03/#ejercicio-1-familiarizandote-con-jupiter","title":"Ejercicio 1: Familiariz\u00e1ndote con Jupiter","text":"<p>Para este ejercicio ustedes van a familiarizarse con Jupiter corriendo un programa sencillo de RISC-V y, luego, contestar\u00e1n unas preguntas.</p> <ol> <li>Abran una terminal (CTRL+T) y dir\u00edjanse a la carpeta del repositorio que clonaron.</li> <li>Abran el modo GUI de V-Sim ejecutando en la terminal <code>jupiter</code>.</li> <li>Desde el editor abran el archivo llamado ex1.s que esta en la carpeta ex1.</li> <li>En la barra de herramientas de Jupiter, vayan a settings y aseg\u00farense de que Assemble Only Selected Tab est\u00e9 seleccionado con un cheque verde.</li> <li>Presionen F3. Esto va a preparar el c\u00f3digo para que pueda ser ejecutado y simulado. Si hacen click a la pesta\u00f1a \"Editor\", su simulaci\u00f3n se va a reiniciar.</li> <li>En el simulador, para ejecutar la siguiente instrucci\u00f3n, presionen el bot\u00f3n que dice \"step\".</li> <li>Para regresar un paso atr\u00e1s, presionen el bot\u00f3n que dice \"backstep\".</li> <li>Para correr todo el programa hasta que termine, presionen el bot\u00f3n que dice \"go\".</li> <li>Para volver a empezar el programa nuevamente, presionen el bot\u00f3n que dice \"reset\".</li> <li>Para ver el contenido de los 32 registros en la parte derecha del simulador, hay una pesta\u00f1a que dice <code>RVI</code>.</li> <li>La consola est\u00e1 en la parte de abajo del simulador.</li> <li>Para ver el contenido de la memoria, en el mismo lugar que los registros hay una pesta\u00f1a que dice <code>Memory</code>, pueden navegar a diferentes secciones de la memoria haciendo click derecho encima de la tabla que muestra el estado de la memoria.</li> </ol>"},{"location":"labs/lab03/#preguntas","title":"Preguntas","text":"<p>Ahora que ya han corrido su primer programa de RISC-V y que ganaron experiencia con Jupiter pueden contestar las siguientes preguntas en el archivo ex1.txt que se encuentra en la carpeta ex1.</p> <p>1) \u00bfQu\u00e9 significan las directivas <code>.data</code>, <code>.word</code>, <code>.text</code>, es decir, para qu\u00e9 las utilizan? Escriban s\u00f3lo una de las siguientes letras para responder. Pista: Piensen acerca de las cuatro secciones de memoria.</p> <ul> <li>A) Son como etiquetas sirven para hacer referencia a cosas que est\u00e1n en memoria, con <code>.data</code> apuntamos hacia los datos con <code>.word</code> hacia palabras de 32 bits y con <code>.text</code> hacia texto.</li> <li>B) <code>.data</code> le indica al ensamblador que guarde los siguientes elementos en la secci\u00f3n est\u00e1tica de la memoria, <code>.word</code> que guarde una palabra de 32 bits en memoria en la secci\u00f3n est\u00e1tica de datos y <code>.text</code> que estamos en la secci\u00f3n de texto y entonces deber\u00edamos escribir instrucciones de ensamblador.</li> <li>C) <code>.data</code> es para guardar datos en la secci\u00f3n de datos de la memoria, <code>.word</code> es para guardar palabras de 32 bits en la secci\u00f3n de palabras de la memoria, <code>.text</code> es para guardar texto ascii en la secci\u00f3n de texto de la memoria.</li> <li>D) <code>.data</code> y <code>.word</code> no son directivas de ensamblador, y <code>.text</code> siempre est\u00e1 por defecto y ni se tendr\u00eda que poner.</li> </ul> <p>2) Corran por completo el programa. \u00bfQu\u00e9 n\u00famero da como \"output\"? 3) \u00bfQu\u00e9 representa el n\u00famero que da como output el programa? Escriban s\u00f3lo una de las siguientes letras para responder:</p> <ul> <li>A) N\u00famero \u00e1ureo</li> <li>B) Factorial de 9</li> <li>C) Fibonnaci de 9</li> <li>D) Factorial de 10</li> </ul> <p>4) \u00bfEn qu\u00e9 direcci\u00f3n de memoria (en hexadecimal) est\u00e1 almacenado \"n\"? Pista: Miren el contenido de los registros.</p> <p>5) Sin utilizar la pesta\u00f1a \"Editor\", hagan que el programa calcule el 13\u00ba n\u00famero (tomando en cuenta que el \u00edndice empieza en 0) de la sucesi\u00f3n de Fibonacci, modificando manualmente el valor de un registro. Encontrar\u00e1n \u00fatil de primero correr l\u00ednea por l\u00ednea el c\u00f3digo. Si prefieren ver los valores en decimal, cambien esto haciendo click derecho sobre la tabla de registros y presionando \"Decimal Display Mode\". \u00bfQu\u00e9 registro modificaron?</p>"},{"location":"labs/lab03/#ejercicio-2-traduciendo-de-c-a-risc-v","title":"Ejercicio 2: Traduciendo de C a RISC-V","text":"<p>Desde Jupiter abran el archivo ex2.s que est\u00e1 en la carpeta ex2 y, desde alg\u00fan editor de texto de su preferencia, abran ex2.c, que est\u00e1 en la misma carpeta. El c\u00f3digo ensamblador que se provee (archivo ex2.s) es una traducci\u00f3n del programa escrito en C (archivo ex2.c) pero en RISC-V. Su tarea es encontrar/explicar los siguientes componentes de este archivo escrito en lenguaje ensamblador en el archivo de texto llamado ex2.txt, que tambi\u00e9n est\u00e1 en la misma carpeta.</p>"},{"location":"labs/lab03/#preguntas_1","title":"Preguntas","text":"<ol> <li>\u00bfCu\u00e1l es el registro que representa la variable <code>k</code>?</li> <li>\u00bfCu\u00e1les son los registros que act\u00faan como punteros a los arreglos <code>source</code> y <code>dest</code> (separados por coma)?</li> <li>\u00bfDe qu\u00e9 n\u00famero de l\u00ednea a que n\u00famero l\u00ednea se encuentra el loop (separado por coma)?</li> <li>\u00bfEn qu\u00e9 n\u00famero de l\u00ednea se copia el contenido de <code>source</code> a <code>dest</code>?, es decir \u00bfd\u00f3nde se puede observar <code>dest[k] = source[k]</code>?.</li> <li>\u00bfC\u00f3mo son manipulados los punteros en el c\u00f3digo? Escriban s\u00f3lo una de las siguientes letras para responder:</li> <li>A) En cada iteraci\u00f3n se le suma <code>k</code> a cada puntero, que es el equivalente en C a <code>arreglo[k]</code>.</li> <li>B) En cada iteraci\u00f3n se le suma <code>k * 4</code> a cada puntero, que es equivalente en C a <code>arreglo[k]</code>.</li> <li>C) En cada iteraci\u00f3n se le hace corrimiento l\u00f3gico a la derecha a cada puntero, que es equivalente en C a <code>arreglo[k]</code>.</li> <li>D) En cada iteraci\u00f3n se le suma <code>+1</code> a cada puntero, que es equivalente en C a <code>arreglo[k]</code>.</li> </ol>"},{"location":"labs/lab03/#ejercicio-3-factorial","title":"Ejercicio 3: Factorial.","text":"<p>En este ejercicio, tienen que implementar la funci\u00f3n de factorial en RISC-V que toma un s\u00f3lo par\u00e1metro entero n y retorna n!. Pueden encontrar un esqueleto de esta funci\u00f3n en el archivo factorial.s, que se encuentra en la carpeta ex3 del repositorio que clonaron. Ustedes s\u00f3lo necesitan agregar las instrucciones bajo la etiqueta <code>factorial</code>, y el argumento que se pasa a la funci\u00f3n va en el registro <code>a0</code>. Pueden resolver este problema ya sea de forma recursiva o iterativa. Aseg\u00farense de que su funci\u00f3n retorne de forma apropidada lo siguiente 3! = 6, 7! = 5040 y 8! = 40320.</p>"},{"location":"labs/lab03/#ejercicio-4-list-map-extra","title":"Ejercicio 4: List Map (Extra)","text":"<p>Para este ejercicio van a utilizar el archivo list_map.s que se encuentra en la carpeta ex4. En este ejercicio, van a completar una funci\u00f3n de \"map\" con listas encadenadas en RISC-V. La funci\u00f3n se simplificar\u00e1 en mutar la lista en cuesti\u00f3n, es decir que tomar\u00e1 una lista encadenada como entrada y va a retornar la lista con los valores modificados. Nuestro procedimiento de \"map\" toma dos par\u00e1metros, el primero ser\u00e1 la direcci\u00f3n del nodo \"head\" de una lista encadenada, cuyos valores son enteros de 32 bits. Entonces, en C, la estructura se define como:</p> <pre><code>struct node {\nint value;\nstruct node *next;\n};\n</code></pre> <p>El segundo par\u00e1metro ser\u00e1 la direcci\u00f3n de una funci\u00f3n que toma un entero como argumento y devuelve un entero. Usaremos la instrucci\u00f3n \"jalr\" de RISC-V para llamar a esta funci\u00f3n con los valores de cada nodo de la lista.</p> <p>Nuestra funci\u00f3n \"map\" ir\u00e1 recorriendo la lista recursivamente, aplicando la funci\u00f3n a cada valor de la lista y almacenando el valor devuelto al nodo correspondiente. En C, la funci\u00f3n se ver\u00eda algo como esta:</p> <pre><code>void map(struct node *head, int (*f)(int)) {\nif (!head) { return; }\nhead-&gt;value = f(head-&gt;value);\nmap(head-&gt;next, f);\n}\n</code></pre> <p>Si no hab\u00edan visto lo de <code>int (*f)(int)</code> antes, no se preocupen demasiado. Significa b\u00e1sicamente que <code>f</code> es un puntero a una funci\u00f3n de C, <code>f</code> entonces puede ser utilizado exactamente como cualquier otra funci\u00f3n. Les ser\u00e1 \u00fatil acudir al green card de RISC-V que pueden encontrar aqu\u00ed para completar este ejercicio.</p> <p>Hay exactamente 9 espacios (8 en <code>map</code> y 1 en <code>main</code>), en el c\u00f3digo que se provee, donde dice <code>YOUR_INSTRUCTION_HERE</code>. Reemplacen esos espacios con las instrucciones de su implementaci\u00f3n de map, y escriban una simple llamada a <code>map</code> con <code>square</code> como argumento de la funci\u00f3n. Hay comentarios en el c\u00f3digo que explican qu\u00e9 deber\u00eda hacer, o cumplir, cada instrucci\u00f3n. Cuando hayan rellenado los espacios con las instrucciones correctas, pueden correr el c\u00f3digo pulsando en F3 y luego el bot\u00f3n Go, al hacer esto, deber\u00eda de darles como output lo siguiente:</p> <pre><code>9 8 7 6 5 4 3 2 1 0\n81 64 49 36 25 16 9 4 1 0\n</code></pre> <p>La primera l\u00ednea es la lista original, y la segunda es la lista modificada despu\u00e9s de que se aplic\u00f3 la funci\u00f3n \"map\".</p>"},{"location":"labs/lab03/#calificacion","title":"Calificaci\u00f3n","text":"<p>Por favor subir el link de su repositorio al GES ! de lo contrario la calificaci\u00f3n ser\u00e1 de 0.</p>"},{"location":"labs/lab04/","title":"Lab 4 - RISC-V Avanzado","text":""},{"location":"labs/lab04/#objetivos","title":"Objetivos","text":"<ul> <li>Divertirse con RISC-V</li> <li>Encontrar los errores de Ali</li> <li>Hacer algo imposible</li> <li>Pensar en la idea de hacer lo imposible</li> </ul>"},{"location":"labs/lab04/#lecturas","title":"Lecturas","text":"<ul> <li>P&amp;H: 2.12</li> </ul>"},{"location":"labs/lab04/#preparacion","title":"Preparaci\u00f3n","text":"<p>Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed. Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal (CTRL+T):</p> <pre><code>git clone &lt;link del repositorio&gt;\n</code></pre> <p>NOTA: Tienen que reemplazar &lt;link del repositorio&gt; con el link del repositorio que se cre\u00f3.</p>"},{"location":"labs/lab04/#ejercicio-1-depurando-megalistmanipss","title":"Ejercicio 1: Depurando megalistmanips.s","text":"<p>Hace mucho tiempo, su catedr\u00e1tico Ali era un principiante en RISC-V, y escribi\u00f3 su soluci\u00f3n a un lab en este archivo: megalistmanips.s. Ustedes, ahora que ya son expertos en RISC-V, deben arreglar los bugs que cometi\u00f3 Ali.</p> <p>El objetivo principal de este ejercicio es que encuentren los errores en la funci\u00f3n map en megalistmanips.s. Antes de hacer eso, familiar\u00edcense con lo que la funci\u00f3n trata de hacer.</p> <p>En el lab anterior, ten\u00edamos una lista encadenada de enteros, ahora nuestra estructura de datos es una lista encadena cuyo valor en cada nodo es un arreglo de enteros. Recuerden que cuando se trabaja con arreglos en structs, necesitamos almacenar expl\u00edcitamente el tama\u00f1o del array. En c\u00f3digo de C, el <code>struct</code> se ver\u00eda as\u00ed:</p> <pre><code>struct node {\nint *arr;\nint size;\nstruct node *next;\n};\n</code></pre> <p>Aqu\u00ed tambi\u00e9n est\u00e1 lo que la nueva funci\u00f3n map hace: atraviesa la lista encadenada y para cada elemento del arreglo de cada nodo, aplica la funci\u00f3n y vuelve a guardarlo en el array. En C, esto se mirar\u00eda de la siguiente manera:</p> <pre><code>void map(struct node *head, int (*f)(int)) {\nif (!head) { return; }\nfor (int i = 0; i &lt; head-&gt;size; i++) {\nhead-&gt;arr[i] = f(head-&gt;arr[i]);\n}\nmap(head-&gt;next, f);\n}\n</code></pre> <p>Lean todos los comentarios en la funci\u00f3n map en megalistmanips.s (antes de que retorne con <code>jr ra</code>), y aseg\u00farense de que las l\u00edneas hagan lo que el comentario dice.</p> <p>Algunas pistas:</p> <ul> <li>\u00bfPor qu\u00e9 necesitamos guardar cosas en el stack antes de llamar a <code>jal</code>?</li> <li>\u00bfCu\u00e1l es la diferencia entre <code>add t0, s0, x0</code> y <code>lw t0, 0(s0)</code>?</li> <li>Presten atenci\u00f3n a los tipos de los atributos en el <code>struct</code>.</li> </ul> <p>\u00a1Gracias por hacer el ejercicio! Estamos seguros de que Ali se estar\u00e1 preguntando d\u00f3nde estaban para ayudarlo cuando no entend\u00eda RISC-V hace un tiempo atr\u00e1s.</p>"},{"location":"labs/lab04/#ejercicio-2-escriban-una-funcion-sin-utilizar-branches","title":"Ejercicio 2: Escriban una funci\u00f3n sin utilizar branches","text":"<p>Consideren la funci\u00f3n \\(f\\) de valor discreto definida en el set de enteros \\({-3, -2, -1, 0, 1, 2, 3}\\). Esta es la definici\u00f3n de la funci\u00f3n:</p> <p>\\(\\begin{align} &amp;f(-3) = 6\\\\\\\\ &amp;f(-2) = 61\\\\\\\\ &amp;f(-1) = 17\\\\\\\\ &amp;f(0) = -38\\\\\\\\ &amp;f(1) = 19\\\\\\\\ &amp;f(2) = 42\\\\\\\\ &amp;f(3) = 5 \\end{align}\\)</p> <p>No les vamos a mentir, es una funci\u00f3n muy tonta. Sin embargo, su tarea es implementarla en RISC-V, con la condici\u00f3n de que NO pueden utilizar las instrucciones de branch por ning\u00fan motivo. Por suerte alguna persona ha dejado por accidente un array de enteros en la secci\u00f3n <code>.data</code> de discrete_fn.s. \u00bfC\u00f3mo pueden utilizarlo para tener ventaja sobre eso y completar esta tarea que aparenta ser imposible?</p>"},{"location":"labs/lab04/#calificacion","title":"Calificaci\u00f3n","text":"<p>Por favor actualizar siempre la versi\u00f3n del CLI de autograders:</p> <pre><code>pip3 install --upgrade autograders-cli\n</code></pre> <p>Entregaremos este lab de la misma manera que el pasado.</p> <p>Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con...</p> <pre><code>autograder --upload\n</code></pre> <p>Espera un minuto aprox. y luego puede ver sus resultados con...</p> <pre><code>autograder --stats\n</code></pre> <p>Si le aparece Queued: True, espere un par de minutos y luego repita el <code>autograder --stats</code> \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.</p>"},{"location":"labs/lab05/","title":"Lab 4 - Logisim","text":""},{"location":"labs/lab05/#objetivos","title":"Objetivos","text":"<ul> <li>Aprender a usar Logisim y simular circuitos en dicho programa.</li> <li>Aprender las herramientas b\u00e1sicas y el funcionamiento de Logisim.</li> </ul>"},{"location":"labs/lab05/#preparacion","title":"Preparaci\u00f3n","text":"<p>Para este laboratorio, que descarguen la aplicaci\u00f3n Logisim. El archivo lo pueden descargar en el siguiente link.</p> <p>Tambi\u00e9n tienen que tener todos los archivos base, estos se encuentran aqu\u00ed. Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal (Ctrl+Alt+T):</p> <pre><code>git clone &lt;link del repositorio&gt;\n</code></pre>"},{"location":"labs/lab05/#vista-general","title":"Vista General","text":"<p>Logisim es una aplicaci\u00f3n que permite simular el comportamiento de circuitos l\u00f3gicos.</p> <p>Al abrir la aplicaci\u00f3n de Logisim, la interfaz gr\u00e1fica est\u00e1 dividida en tres partes fundamentales:</p> <ul> <li>\u00c1rea de Trabajo.</li> <li>Secci\u00f3n de Componentes.</li> <li>Secci\u00f3n de Herramientas de acceso directo.</li> </ul> <p></p> <p>La secci\u00f3n de \u00e1rea de trabajo est\u00e1 compuesta por todo el espacio en blanco con puntos negros. Aqu\u00ed se pueden colocar componentes, conectarlos entre s\u00ed utilizando cables.</p> <p>La secci\u00f3n de componentes est\u00e1 ubicada en el lado izquierdo de la interfaz. Es una ventanilla que contiene numerosas carpetas que contienen los componentes.</p> <p>La secci\u00f3n de herramientas de acceso directo est\u00e1 ubicada en el lado superior izquierdo. Este posee \u00edconos para la realizaci\u00f3n de distintas tareas. Entre dichos \u00edconos se encuentran:</p> <ul> <li> Permite interactuar con el circuito, cambiando valores. Es llamado \u201cPoke\u201d en ingl\u00e9s.</li> <li> Permite editar un componente al seleccionarlo y permite crear o editar cables. Es llamado \u201cSelect Tool\u201d en ingl\u00e9s.</li> <li> Permite crear texto en el \u00e1rea de trabajo.</li> <li> Este es un acceso directo al componente llamado \u201cInput Pin\u201d. Permite crear entradas al circuito.</li> <li> Este es un acceso directo al componente llamado \u201cOutput Pin\u201d. Permite crear salidas de los circuitos.</li> <li> Este es un acceso directo a la compuerta l\u00f3gica \u201cNot\u201d.</li> <li> Permite crear compuertas l\u00f3gicas de tipo \u201cAnd\u201d.</li> <li> Generacompuertas l\u00f3gicas de tipo \u201cOr\u201d.</li> </ul> <p>Por el momento, estas son las herramientas que se van a necesitar para este laboratorio.</p>"},{"location":"labs/lab05/#ejercicio-0-las-bases","title":"Ejercicio 0: Las Bases","text":"<p>Este ejercicio consiste en crear su primer circuito. Empecemos con un circuito simple.</p> <ol> <li> <p>En el \u00e1rea de herramientas o acceso directo, hacer click en el \u00edcono de la compuerta \u201cAnd\u201d. Esto crear\u00e1 una sombra de dicha compuerta que seguir\u00e1 el cursor en el \u00e1rea de trabajo.</p> </li> <li> <p>Colocar la compuerta en el \u00e1rea de trabajo. Basta con hacer click otra vez para colocar dicho componente.    Tambi\u00e9n, se pueden rotar los componentes presionando las teclas de flechas del teclado. Se pueden colocar en la orientaci\u00f3n deseada, pero para este laboratorio, colocar la compuerta en orientaci\u00f3n \u201cEste\u201d. La orientaci\u00f3n de un componente puede ser alterado al seleccionarlo y buscar la opci\u00f3n \u201cOrientaci\u00f3n\u201d u \u201cOrientation\u201d.(Asegur\u00e1ndose de que el \u00edcono de  est\u00e9 activo).</p> </li> <li> <p>Los pines de entrada y salida ya han sido colocados, ustedes no tienen que modificar/reemplazar/alterar/cambiar estos pines sino el autograder no les va a funcionar y tendr\u00e1n que volver a descargar los archivos base nuevamente para que les funcione, en otras palabras empezar de nuevo de lo contrario tendr\u00e1n una nota de 0. Hasta este punto su circuito debe verse as\u00ed:</p> </li> </ol> <p> </p> <ol> <li>Luego, hacer click en  \u201cSelect Tool\u201d, y conectar los Input Pins y el Output Pin con la compuerta And creando cables entre ellos (Al mantener presionado el bot\u00f3n izquierdo del mouse, se puede crear un cable del largo deseado y, al soltarlo, dicho bot\u00f3n el cable se crear\u00e1. \u00a1Ojo! S\u00f3lo se pueden crear cables horizontales y verticales.)</li> </ol> <p>El circuito debe lucir algo parecido a esto:</p> <p> </p> <ol> <li>Y por \u00faltimo, hacer click en  \u201cPoke\u201d y presionar los Input Pins para interactuar con ellos. Observar que el Output Pin cambia en funci\u00f3n de los valores de los Input Pins.</li> </ol> <p>\u00a1Y listo! El primer circuito est\u00e1 listo.</p>"},{"location":"labs/lab05/#ejercicio-1-nand-nor-xor-y-multiplexores","title":"Ejercicio 1: NAND, NOR, XOR y Multiplexores","text":"<p>Ahora es momento para crear circuitos m\u00e1s complejos, van a trabajar en el archivo ex1.circ. Se dar\u00e1n cuenta que en la parte izquierda aparecen 5 subcircuitos que tienen que completar (NAND, NOR, XOR, 2-1 MUX, 4-1 MUX). En los proyectos de Logisim se pueden crear subcircuitos para mantener organizados los circuitos, ayudando a la est\u00e9tica del proyecto. Para crear un nuevo subcircuito tienen que ir a (Proyecto -&gt; A\u00f1adir Circuito) y escribir el nombre del subcircuito, pero esto lo tendr\u00e1n que hacer m\u00e1s adelante en el proyecto 2, por ahora ya est\u00e1n creados por ustedes. Si quieren tener m\u00e1s informaci\u00f3n o est\u00e1n interesados lean la siguiente documentaci\u00f3n de logisim link.</p> <p>Su tarea es implementar las compuertas NAND, NOR, XOR y multiplexores 2 a 1 y 4 a 1 utilizando \u00fanicamente compuertas AND, NOT y OR. Todos los circuitos tienen ya colocados los pines de entrada y salida, nuevamente no los pueden cambiar o no funcionar\u00e1 el autograder.</p> <p></p> <p>Cuando hayan completado un subcircuito pueden re-utilizarlo en los dem\u00e1s subcircuitos si creen que es necesario o simplifica el circuito. Para esto tienen que estar en otro subcircuito y hacer click en el subcircuito que ya han terminado y lo pueden utilizar como cualquier otro componente. Por ejemplo en la imagen que se muestra a continuaci\u00f3n se utiliza en el subcircuito NOR, el subcircuito NAND.</p> <p></p> <p>Nota: Para los circuitos que simulan los respectivos multiplexores. Se deben seguir las siguientes normas:</p> <ul> <li>Para el Multiplexor 2 a 1 de 1 bit:</li> </ul> <p> </p> <ul> <li>Para el Multiplexor 4 a 1 de 1 bit:</li> </ul> <p> </p> <p>Recueden no utilizar las compuertas l\u00f3gicas NOR, XOR ni los multiplexores que vienen por defecto.</p>"},{"location":"labs/lab05/#ejercicio-2-contador","title":"Ejercicio 2: Contador","text":"<p>Ya sabiendo sobre circuitos y subcircuitos, ahora se har\u00e1 un circuito m\u00e1s complejo aplicando todo lo aprendido en el lab hasta el momento. Sino, cuando llegue el momento de realizar un proyecto al respecto, este no tendr\u00e1 piedad de ustedes. Para este ejercicio van a estar trabajando en el archivo ex2.circ.</p> <p>El ejercicio consiste en realizar un contador utilizando un registro y un sumador. Lo especial de este circuito es que se empezar\u00e1 a utilizar un reloj y a utilizar m\u00e1s bits.</p> <p>El circuito a dise\u00f1ar es el siguiente:</p> <p> </p> <p>Los componentes a emplear se encuentran en:</p> <p> </p> <p>Los componentes utilizados son los siguientes:</p> <ul> <li>Sumador: Ubicado en la librer\u00eda \u201cAritm\u00e9tica\u201d.</li> <li>Registro: Ubicado en la librer\u00eda \u201cMemoria\u201d.</li> <li>Constante Num\u00e9rica: Ubicado en la librer\u00eda \u201cWiring\u201d.</li> <li>Reloj: Ubicado en la librer\u00eda \u201cWiring\u201d.</li> </ul> <p>Cabe mencionar que ahora se utilizan Output Pins de m\u00e1s de un bit, se puede aumentar el n\u00famero de bits en la configuraci\u00f3n de los componentes. Seleccionar un componente y, en el lado izquierdo, se puede encontrar el mismo men\u00fa que se usa para darle orientaci\u00f3n a los componentes y asignarles una etiqueta, en donde se est\u00e1 la opci\u00f3n de \u201cBits De Datos\u201d. Para este ejercicio ya est\u00e1 hecho esto para los Output pins, pero si tienen que hacerlo para el registro, para la constante num\u00e9rica y el sumador.</p> <p>Una vez se termine de construir el circuito\u2026 \u00a1es hora de simularlo!</p> <p>Seleccionar la opci\u00f3n \u201cSimular\u201d (ubicado en la parte superior de la pantalla) y presionar la opci\u00f3n de \u201cactivar reloj\u201d. Se podr\u00e1 notar que el circuito funciona por s\u00ed solo y que, efectivamente, cumple con su objetivo: \u00a1contar! (si se hizo correctamente).</p> <p>Es posible alterar la frecuencia del reloj seleccionando otra vez \u201cSimular\u201d y, luego, \u201cSeleccionar frecuencia del reloj\u201d. Con esto se puede controlar qu\u00e9 tan r\u00e1pido se contar\u00e1. Otra funci\u00f3n \u00fatil es la de \u201cResetear Simulaci\u00f3n\u201d ubicado, tambi\u00e9n, en \u201cSimular\u201d.</p> <p>NOTA: En lo que se simula el circuito, es posible revisar los estados de los subcircuitos. Para ello, se debe seleccionar la herramienta \u201cPoke\u201d, hacer click sobre un subcircuito en el \u00e1rea de trabajo y presionar en la lupa que aparece sobre el subcircuito. Para regresar al circuito principal, hay que hacer click en el m\u00f3dulo del circuito principal, ubicado en la secci\u00f3n de componentes. Esto no lo van a necesitar en este ejercicio, pero ser\u00e1 muy \u00fatil para el proyecto nuevamente.</p>"},{"location":"labs/lab05/#ejercicio-3-afd-a-logica-digital","title":"Ejercicio 3: AFD a L\u00f3gica Digital","text":"<p>Es momento de hacer algo mucho m\u00e1s interesante: \u00a1traducir un Aut\u00f3mata Finito Determin\u00edstico a un circuito digital!</p> <p>En el curso de Inform\u00e1tica 3 se aprende qu\u00e9 es un AFD (o Finite State Machine en ingl\u00e9s). Un AFD posee estados finitos y transici\u00f3n entre estados.</p> <p>El AFD de este laboratorio es una variaci\u00f3n del AFD que se ha visto en clase. Este AFD posee estados y transici\u00f3n de estados, pero, adem\u00e1s de eso, necesita inputs para cambiar de estado y al cambiar de estado regresa un output.</p> <p>El AFD es el siguiente:</p> <p> </p> <p>La tabla de verdad de dicho aut\u00f3mata puede ser \u00fatil para visualizar lo que est\u00e1 pasando:</p> <p> </p> <p>\u00bfC\u00f3mo se lee? La primera fila de la tabla se entiende de esta manera: \u201cDado el estado 00, si el input es 0, entonces se hace una transici\u00f3n al estado 01 y devuelve un output de 1\u201d.</p> <p>Para este ejercicio se les provee el circuito ex3.circ. El trabajo a realizar es completar el circuito y lograr que se comporte como el AFD mostrado anteriormente. Para esto ustedes solo van a modificar 2 subcircuitos: StateBitOne y StateBitZero.</p> <p>Se tienen dos opciones para completar el circuito: 1) fuerza bruta o 2) imaginaci\u00f3n. Con la imaginaci\u00f3n es posible completar el circuito utilizando un total de 3 componentes, pero, si se resuelve con la fuerza bruta, el n\u00famero ser\u00e1 mucho mayor. Se tiene todas las herramientas y las pistas necesarias para terminar el ejercicio con 3 componentes. \u00a1\u00c9xitos! :D</p>"},{"location":"labs/lab05/#calificacion","title":"Calificaci\u00f3n","text":"<p>Cuando crean que tiene ejercicios completos pueden hacer la prueba localmente escribiendo en la terminal:</p> <pre><code>./check\n</code></pre> <p>Si todo esta correcto les saldr\u00e1 algo como esto:</p> <pre><code>   ___       __                        __\n  / _ |__ __/ /____  ___  _______ ____/ /__ ____\n / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _  / -_) __/\n/_/ |_\\_,_/\\__/\\___/\\_, /_/  \\_,_/\\_,_/\\__/_/\n                   /___/\n\n             Machine Structures\n     Great Ideas in Computer Architecture\n               Logisim Intro\n\n\nExercise                    Grade  Message\n------------------------  -------  ---------\n0. The basics (Warm-Up)        25  passed\n1. Sub-Circuits                25  passed\n2. Storing State               25  passed\n3. FSMs to Digital Logic       25  passed\n\n=&gt; Score: 100/100\n</code></pre> <p>Al finalizar, recuerden hacer <code>add</code>, <code>commit</code> y <code>push</code> hacia Github. Luego env\u00eden el link de su repositorio en el GES. Si no env\u00eda el link, no podremos ponerle nota!</p>"},{"location":"labs/lab06/","title":"Lab 5 - Logisim Avanzado","text":""},{"location":"labs/lab06/#objetivo","title":"Objetivo","text":"<p>En este laboratorio ustedes van a aprender sobre otros componentes esenciales de Logisim, en particular, los splitters que nos permiten hacer cosas como, descomponer un cable en subsets de bits para luego manipularlos individualmente.</p>"},{"location":"labs/lab06/#preparacion","title":"Preparaci\u00f3n","text":"<p>Para este laboratorio, nuevamente, es necesario que tengan la aplicaci\u00f3n de Logisim. Adicionalmente pueden utilizar la documentaci\u00f3n de Logisim para refrescar el conocimiento que adquirieron en el laboratorio pasado o leer el lab tambi\u00e9n aqu\u00ed.</p> <p>Tambi\u00e9n tienen que tener todos los archivos base, estos se encuentran aqu\u00ed. Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal (Ctrl+Alt+T):</p> <pre><code>git clone &lt;link del repositorio&gt;\n</code></pre>"},{"location":"labs/lab06/#caracteristicas-avanzadas-de-logisim","title":"Caracter\u00edsticas Avanzadas de Logisim","text":"<p>Aqu\u00ed pueden encontrar tres caracter\u00edsticas m\u00e1s de logisim que ustedes van a encontrar bastante utiles, principalmente en el proyecto 2.</p>"},{"location":"labs/lab06/#tuneles-tunnels","title":"T\u00faneles (Tunnels)","text":"<p>Un t\u00fanel les permite dibujar un cable invisible para unir dos puntos. Los t\u00faneles son agrupados por etiquetas (case-sensitive) que se les ponen a los cables para identificarlos. Generalmente son utilizados para conectar cables de la siguiente manera:</p> <p> </p> <p>Que se traduce (o tiene un efecto similar) a esto:</p> <p> </p> <p>Hay que tener ciertas precauciones al utilizar los t\u00faneles y siempre mantener un registro de cuales cables est\u00e1n conectados con t\u00faneles hacia otros cables, para evitar situaciones como esta:</p> <p> </p> <p>Que se traduce (o tiene un efecto similar) a esto:</p> <p> </p> <p>Nosotros les recomendamos (bastante) utilizar t\u00faneles en Logisim, porque hacen los circuitos m\u00e1s limpios, claros y f\u00e1ciles de depurar.</p>"},{"location":"labs/lab06/#divisores-splitters","title":"Divisores (Splitters)","text":"<p>Los divisores crean una correspondencia entre un valor de multiples bits y subsets de esos bits. A pesar de su nombre, puede dividir un valor de multiples bits en varias partes o subsets de bits (lo que se espera por el nombre), as\u00ed como tambi\u00e9n puede combinar partes o subsets de bits en un valor de multiples bits. Por ejemplo para el primer caso, un valor float (IEEE 754) de precisi\u00f3n simple (32 bits) dividido en signo (1 bit), exponente (8 bits) y fracci\u00f3n (23 bits):</p> <p> </p> <p>Para el segundo caso se unen dos entradas de diferentes anchos de bits (3 y 2 bits) que se unen para formar un valor de 5 bits:</p> <p> </p>"},{"location":"labs/lab06/#extensores-extenders","title":"Extensores (Extenders)","text":"<p>Cuando est\u00e9n cambiando el ancho de un cable, siempre deber\u00edan de utilizar un extensor para mayor claridad en su circuito. Por ejemplo, consideren la siguiente implementaci\u00f3n en donde se extiende un cable de ancho 8 bits a un cable de ancho de 16 bits:</p> <p> </p> <p>A pesar de que hace lo que tiene que hacer, no es una buena pr\u00e1ctica y alguien que est\u00e9 revisando su proyecto posiblemente no pueda comprender la intenci\u00f3n del circuito anterior. Algo mejor, m\u00e1s simple, f\u00e1cil de leer y menos propenso a errores ser\u00eda algo como lo siguiente:</p> <p> </p> <p>Esto tamb\u00eden aplica cuando se quiere pasar de un ancho de bits mayor a un ancho de bits menor. En el siguiente ejemplo, un cable de ancho 8 bits es convertido a un cable de ancho de 4 bits, tirando/ignorando los bits sobrantes:</p> <p> </p> <p>A pesar de las implicaciones de su nombre, un extensor se puede utilizar tambi\u00e9n para realizar la misma operaci\u00f3n y as\u00ed evitar el uso de splitters para esta tarea:</p> <p> </p>"},{"location":"labs/lab06/#ejercicio-1-divisores-splitters","title":"Ejercicio 1: Divisores (Splitters)","text":"<p>Para este ejercicio van a utilizar los splitters para crear un par de circuitos simples manipulando un numero de 8 bits. Van a estar trabajando en el archivo splitters.circ.</p> <ul> <li> <p>Vayan al folder llamado \"Wiring\" y seleccionen un splitter. Este circuito va a tomar un cable y lo va a dividir en un set de cables con un ancho de bits menor.</p> </li> <li> <p>Antes de colocar el circuito en el esquem\u00e1tico, cambien el ancho a 8 bits en las propiedades del circuito y \"Fan Out\" al tamano que considere conveniente, 3 es una buena idea para comenzar. Si ustedes mueven el cursor sobre el esquem\u00e1tico, su cursor deber\u00eda de verse algo as\u00ed: .</p> </li> <li> <p>Tareas a realizar:</p> </li> <li>Out1: Realice un AND entre el bit m\u00e1s significativo y el menos significativo del input<ul> <li>Arriba le sugerimos que pusiera un fan out de 3. En el panel de la izquierda configure para que solo el bit 0 vaya a la salida 0 (Top), y que solo el bit 7 vaya a la salida 2 (Bottom), todos los dem\u00e1s bits puede mandarlos hacia la salida 1.</li> <li>Listo! Gracias al splitter, logr\u00f3 separar el bit m\u00e1s significativo y el menos significativo del resto.</li> </ul> </li> <li>Out2: Trabajando en signo-magnitud, obtenga el inverso aditivo del input<ul> <li>Recordatorio: inverso aditivo significa cambiarle de signo de positivo a negativo, y viceversa.</li> <li>Recordatorio: Signo Magnitud es una otra forma de representar n\u00fameros con signo, la vimos la primera semana de clases.</li> <li>Usted ya parti\u00f3 al input en pedacitos para resolver Out1, puede usar algunos de esos pedacitos y alguna compuerta para obtener el inverso aditivo.</li> <li>Luego puede utilizar otro splitter, ahora colocado al rev\u00e9s para reconstruir su n\u00famero: de varios pedacitos, pasar\u00e1 a tener un valor de 8 bits.</li> </ul> </li> </ul>"},{"location":"labs/lab06/#ejercicio-2-rotate-right","title":"Ejercicio 2: Rotate Right","text":"<p>Con el conocimiento que tienen acerca de los splitters y multiplexores, est\u00e1n listos para implementar un bloque de l\u00f3gica combinacional no trivial: <code>rotr</code>, que significa Rotate Right.</p> <p>La idea es que <code>rotr A,B</code> va a rotar el patr\u00f3n de bits de la entrada <code>A</code> a la derecha por <code>B</code> bits. Por ejemplo, si <code>A</code> fuera \\(0\\text{b}10110101011\\color{blue}1\\color{blue}0\\color{blue}0\\color{blue}1\\color{blue}1\\) y <code>B</code> fuera \\(0\\text{b}0101\\) (5 en decimal), el output del bloque ser\u00eda \\(0\\text{b}\\color{red}1\\color{red}0\\color{red}0\\color{red}1\\color{red}110110101011\\). Noten que los 5 bits de m\u00e1s a la derecha de <code>A</code> (azul) fueron rotados a la derecha y puestos de vuelta a la izquierda (rojo). En RTL, la operaci\u00f3n ser\u00eda algo como:</p> <pre><code>R = A &gt;&gt; B | A &lt;&lt; (16 - B)\n</code></pre> <p>Ustedes tienen que implementar el subcircuito llamado rotr en el archivo rotr.circ que tiene las siguientes entradas y salida:</p> <ul> <li>A, 16 bits, la entrada a ser rotada.</li> <li>B, 4 bits, la cantidad de rotaci\u00f3n (Resp\u00f3ndase a usted mismo, \u00bfpor qu\u00e9 4 bits? )</li> <li>C, 16 bits, salida con el resultado de la rotaci\u00f3n.</li> </ul> <p>La salida en el output deber\u00eda de ser <code>A</code> rotado por <code>B</code> bits, como se indic\u00f3 anteriormente. Ustedes NO pueden utilizar los shifters que trae Logisim en su soluci\u00f3n, pero todos los dem\u00e1s bloques combinacionales (multiplexores, splitters, t\u00faneles, constantes, compuertas, sumadores, etc) son permitidos.</p> <p>HINT 1: Antes de empezar a cablear, deber\u00edan de pensar muuuuuuuy bien acerca de como pueden descomponer este problema en peque\u00f1as partes y unirlas. Deber\u00edan de sentirse libres de implementar subcircuitos para implementar este ejercicio. Si no los utilizan, se van a arrepentir.</p> <p>HINT 2: Solo porque les dimos una representaci\u00f3n en RTL no significa que esta sea la mejor opci\u00f3n para abordar el problema. Piense en los bits de entrada de <code>B</code> y en como pueden utilizar efectivamente los splitters. Piense en c\u00f3mo resolvio el multiplexor de 4 a 1 la semana pasada, usando su multiplexor de 2 a 1.</p> <p>Si su cableado de un splitter grande se est\u00e1 volviendo desordenado, a veces cambiar los splitters pueden mantener las cosas m\u00e1s limpias y localizables. Por ejemplo, en lugar de utilizar un splitter de 1 a 16, puede primero dividir en 4, y luego volver a dividir en 4.</p> <p>\u00a1Este ejercicio lo har\u00e1 pensar bastante!</p>"},{"location":"labs/lab06/#ejercicio-3-alu","title":"Ejercicio 3: ALU","text":"<p>En este ejercicio ustedes van a implementar un ALU de 32 bits. Van estar trabajando en el archivo llamado ALU.circ. Como un recordatorio, ALU significa Arithmetic Logic Unit (Unidad Arim\u00e9tica L\u00f3gica). Un ALU es una pieza fundamental de un CPU y realiza operaciones aritm\u00e9ticas y l\u00f3gicas (bitwise). La funci\u00f3n que el ALU realiza (ejemplo add, xor) es determinada por el control de nuestro datapath, que esta determinado por la instrucci\u00f3n que nuestro procesador est\u00e1 ejecutando. El ALU est\u00e1 resaltado en el siguiente diagrama de un datapath simplificado:</p> <p> </p> <p>Este ejercicio es una versi\u00f3n simplificada de lo que le tocar\u00e1 hacer en el proyecto 2. Esperamos que al realizar este ejercicio, el proyecto 2 se les haga un poco m\u00e1s f\u00e1cil y suave de llevar.</p> <p>Las 8 funciones que tienen que implementar son: shift left logical, shift right logical, shift right arithmetic, rotate left, rotate right, and, or y xor. El ALU va a realizar la funci\u00f3n deseada sobre 2 entradas de 32 bits y tendr\u00e1 una salida de 32 bits como resultado. Noten que Logisim tiene compuertas que hacen todas estas funciones, NO tienen que implementar ninguna por su cuenta, por favor no lo hagan.</p> <p>HINT 1: Busquen el folder en Logisim etiquetado como Arithmetic para poder encontrar shifter, que ser\u00e1 \u00fatil para varias de las operaciones.</p> <p>HINT 2: Utilizen t\u00faneles para mover todas las salidas del cuadro etiquetado \"Compute All Possible Operations\" al cuadro etiquetado como \"Select the Requested Result\".</p> <p>La funci\u00f3n seleccionada va a ser determinada por el valor de la se\u00f1al de control, la siguiente tabla resume todo:</p> Control Operation <code>000</code> Shift Left Logical <code>001</code> Shift Right Logical <code>010</code> Shift Right Arithmetic <code>011</code> Rotate Left <code>100</code> Rotate Right <code>101</code> And <code>110</code> Or <code>111</code> Xor"},{"location":"labs/lab06/#calificacion","title":"Calificaci\u00f3n","text":"<p>Cuando crean que tengan ejercicios completos, pueden utilizar el autograder escribiendo en la terminal:</p> <pre><code>./check\n</code></pre> <p>Si todo esta correcto les saldr\u00e1 algo como esto:</p> <pre><code>   ___       __                        __\n  / _ |__ __/ /____  ___  _______ ____/ /__ ____\n / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _  / -_) __/\n/_/ |_\\_,_/\\__/\\___/\\_, /_/  \\_,_/\\_,_/\\__/_/\n                   /___/\n\n             Machine Structures\n     Great Ideas in Computer Architecture\n              Advanced Logisim\n\n\nExercise           Grade   Message\n----------------  -------  ---------\n1. Splitters       33.333  passed\n2. Rotate Right    33.333  passed\n3. ALU             33.333  passed\n\n=&gt; Score: 100/100\n</code></pre> <p>Al finalizar, recuerde hacer <code>add</code>, <code>commit</code> y <code>push</code> hacia Github. Luego env\u00ede el link de su repositorio en el GES. Si no env\u00eda el link, no podremos ponerle nota!</p>"},{"location":"labs/lab07/","title":"Lab 6 - ALU Proyecto 2","text":""},{"location":"labs/lab07/#objetivo","title":"Objetivo","text":"<p>Este laboratorio es bastante corto y representa los primeros 25 puntos de su proyecto 2 (procesador de RISC-V en Logisim). El motivo principal es que tengan m\u00e1s tiempo para invertir en otras partes del proyecto. Si logran sacar 100 en el laboratorio tendr\u00e1n una de tres partes terminadas... \u00e9xitos.</p>"},{"location":"labs/lab07/#preparacion","title":"Preparaci\u00f3n","text":"<p>Para este laboratorio, nuevamente, es necesario que tengan la aplicaci\u00f3n de Logisim. Adicionalmente pueden utilizar la documentaci\u00f3n de Logisim para refrescar el conocimiento que adquirieron en los laboratorios anteriores.</p> <p>Tambi\u00e9n tienen que tener todos los archivos base, estos se encuentran aqu\u00ed. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal (Ctrl+Alt+T):</p> <pre><code>git clone &lt;link del repositorio&gt;\n</code></pre>"},{"location":"labs/lab07/#ejercicio-1-arithmetic-logic-unit-alu","title":"Ejercicio 1: Arithmetic Logic Unit (ALU)","text":"<p>Las instrucciones de este ejercicio son una copia literal de las instrucciones del proyecto 2, por favor lean cuidadosamente.</p> <p>Su tarea es crear un ALU que soporte todas las operaciones que necesitan las instrucciones de nuestro ISA. Van a estar trabajando en el archivo alu.circ. Este tiene tres entradas:</p> Nombre de Entrada Ancho en Bits Descripci\u00f3n A 32 Datos para usar por A en la operaci\u00f3n del ALU B 32 Datos para usar por B en la operaci\u00f3n del ALU ALU Op 4 Selecciona la operaci\u00f3n que el ALU deber\u00eda de efectuar <p>y cuatro salidas:</p> Nombre de Entrada Ancho en Bits Descripci\u00f3n Out 32 Resultado de la operaci\u00f3n efectuada por el ALU Equal 1 1 si A y B son iguales, 0 de lo contrario LT 1 1 si A es menor que B (signed), 0 de lo contrario LTU 1 1 si A es menor que B (unsigned), 0 de lo contrario <p>Esta es la lista de operaciones que necesitan implementar. Ustedes tienen que utilizar y les recomendamos utilizar los componentes de logisim que ya efectuan estas operaciones, por favor no las implementen desde 0, ser\u00eda muy tardado y no es el objetivo del proyecto ni del laboratorio.</p> Valor de ALU Op Instrucci\u00f3n 0 sll: Out = A &lt;&lt; B[4:0] 1 srl: Out = (unsigned) A &gt;&gt; B[4:0] 2 add: Out = A + B 3 and: Out = A &amp; B 4 or: Out = A | B 5 xor: Out = A ^ B 6 slt: Out = (A &lt; B) ? 1 : 0 Signed 7 mul: Out = (X * Y)[31:0] 8 mulh: Out = (A * B)[63:32] 9 div: Out =(unsigned) A / B 10 rem: Out = A % B 11 sub: Out = A - B <p>Algunas cosas adicionales que tienen que tener en mente:</p> <p>La salidas <code>Equal</code>, <code>LT</code>, <code>LTU</code> siempre tienen que sacar el valor correcto de comparaci\u00f3n sin importar el valor de <code>ALU Op</code>. Ustedes no pueden modificar (mover, reemplazar, cortar, pegar, eliminar, etc) los pines de entrada ni de salida que nosotros les damos de lo contrario el autograder no va a funcionar correctamente, tengan en cuenta esto para evitar problemas con el autograder a la hora de hacer submit.</p>"},{"location":"labs/lab07/#calificacion","title":"Calificaci\u00f3n","text":"<p>Al finalizar su circuito puede usar <code>./check</code> para probarlo de forma local. Debido a lo importante que sera el ALU para su proyecto, este lab se calificara con 0 o 100 unicamente.</p> <pre><code>./check\n</code></pre> <p>Si todo esta correcto les saldr\u00e1 algo como esto:</p> <pre><code>   ___       __                        __\n  / _ |__ __/ /____  ___  _______ ____/ /__ ____\n / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _  / -_) __/\n/_/ |_\\_,_/\\__/\\___/\\_, /_/  \\_,_/\\_,_/\\__/_/\n                   /___/\n\n             Machine Structures\n     Great Ideas in Computer Architecture\n               Lab 7: PJ2 ALU\n\n\nExercise      Grade  Message\n----------  -------  ---------\n1. ALU          100  passed\n\n=&gt; Score: 100/100\n</code></pre> <p>Al finalizar, recuerde hacer <code>add</code>, <code>commit</code> y <code>push</code> hacia Github. Luego env\u00ede el link de su repositorio en el GES. Si no env\u00eda el link, no podremos ponerle nota!</p>"},{"location":"labs/lab08/","title":"Lab 8 - Pipelining y preparaci\u00f3n para el CPU","text":""},{"location":"labs/lab08/#objetivo","title":"Objetivo","text":"<p>Este laboratorio es bastante corto. Consiste \u00fanicamente en un ejercicio de pipelining, con el objetivo de darles suficiente tiempo para el proyecto 2, empiecen pronto...</p>"},{"location":"labs/lab08/#preparacion","title":"Preparaci\u00f3n","text":"<p>Para este laboratorio, nuevamente, es necesario que tengan la aplicaci\u00f3n de Logisim. Adicionalmente, pueden utilizar la documentaci\u00f3n de Logisim para refrescar el conocimiento que adquirieron en los laboratorios anteriores.</p> <p>Tambi\u00e9n, tienen que tener todos los archivos base, estos se encuentran aqu\u00ed. Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal (CTRL+T):</p> <pre><code>git clone &lt;link del repositorio&gt;\n</code></pre>"},{"location":"labs/lab08/#ejercicio-1-pipeline","title":"Ejercicio 1: Pipeline","text":"<p>Asuman que, al encender, todos los registros tienen 0.</p> <p>Consideren el siguiente FSM de 2 entradas, su salida es calculada por medio de una multiplicaci\u00f3n de sus entradas y sumada a su estado actual.</p> <p></p> <p>Asuman que el tiempo de propagaci\u00f3n de un bloque de suma es de 50ns, el tiempo de propagaci\u00f3n de un bloque de multiplicaci\u00f3n es de 55ns, y el clk-to-q delay de un registro es de 5ns. Calculen la m\u00e1xima frecuencia del reloj en la que puede operar este circuito. Asuman que el tiempo de configuraci\u00f3n de un registro es despreciable y que las 2 entradas vienen de registros sincronizados que reciben informaci\u00f3n de fuentes externas.</p> <p>Ahora, deben mejorar el desempe\u00f1o de este circuito, de manera que pueda operar a una frecuencia de reloj m\u00e1s alta. Para ello, deben separar la multiplicaci\u00f3n y la suma en dos etapas de pipeline. En la primera etapa, se realiza la multiplicaci\u00f3n de las 2 entradas y, en la segunda etapa, se le suma el producto al estado actual.</p> <p>La forma en que se evaluar\u00e1 es muy simple: La secuencia de salidas de este circuito est\u00e1 bien, ssi corresponde a la secuencia de salidas del circuito sin pipeline, potencialmente, con algunos ceros en el principio. Por ejemplo, si el circuito da como salidas [3,5,1,2,4,...], su circuito correcto podr\u00eda devolver [0,3,5,1,2,4,...] para la misma secuencia de entradas.</p> <p>Para facilitar el proceso de calificaci\u00f3n, se les dar\u00e1 un punto de inicio est\u00e1ndar en los archivos del laboratorio. En <code>pipeline.circ</code>, el sub-circuito <code>Non- pipelined</code> est\u00e1 estructurado exactamente como la imagen de arriba. El <code>main</code> est\u00e1 programado para que la salida del subcircuito sin pipeline sea [3,5,1,2,4,-1,0,0,...]. Esto, tambi\u00e9n, los ayudar\u00e1 como ejemplo de c\u00f3mo usar una memoria con datos desde un archivo. El bloque ROM deber\u00eda tener los datos correctos, pero, si no, denle click derecho al bloque y elijan la opci\u00f3n \"Load image...\" y escogan <code>ROMdata</code>.</p> <p>Noten que necesitar\u00e1n un registro para guardar un valor intermedio entre etapas del pipeline, esto es bastante com\u00fan en pipelines.</p> <ol> <li>Completen el subcircuito <code>pipelined</code>. Tendr\u00e1n que agregar un registro entre los bloques de producto y suma para separar las dos etapas.</li> <li>Ahora, calculen la nueva frecuencia m\u00e1xima para la versi\u00f3n con pipeline del circuito.</li> <li>Cuando aprendieron de esto en clase, se les mencion\u00f3 que si un resultado depende de la salida de una instrucci\u00f3n previa, se suele agregar una \"burbuja\" en el pipeline para asegurar que el resultado de la primera instrucci\u00f3n est\u00e9 listo para ser usado en la segunda. Piensen por qu\u00e9 agregar burbujas en este ejemplo es innecesario.</li> </ol>"},{"location":"labs/lab08/#calificacion","title":"Calificaci\u00f3n","text":"<p>Cuando crean que tengan ejercicios completos, pueden utilizar el autograder, localmente, escribiendo en la terminal:</p> <pre><code>./check\n</code></pre> <p>Si todo esta correcto les saldr\u00e1 algo como esto:</p> <pre><code>   ___       __                        __\n  / _ |__ __/ /____  ___  _______ ____/ /__ ____\n / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _  / -_) __/\n/_/ |_\\_,_/\\__/\\___/\\_, /_/  \\_,_/\\_,_/\\__/_/\n                   /___/\n\n             Machine Structures\n     Great Ideas in Computer Architecture\n              Lab 8: Pipeline\n\n\nExercise           Grade   Message\n----------------  -------  ---------\n1. Pipeline           100  Passed\n\n=&gt; Score: 100/100\n</code></pre> <p>Pueden subir su laboratorio para calificaci\u00f3n utilizando:</p> <pre><code>./submit &lt;TOKEN&gt;\n</code></pre>"},{"location":"labs/lab08/#ejercicio-2-guia-del-proyecto-de-cpu","title":"Ejercicio 2: Gu\u00eda del proyecto de CPU","text":"<p>Queremos incluir esta gu\u00eda para guiarlos en la tercera parte del proyecto. Aprovechen esta gu\u00eda para comenzar la parte 3 (CPU).</p> <p>Empezar esta parte desde cero puede ser intimidante, as\u00ed que queremos guiarlos en la forma de pensar en este proyecto con un ejemplo de instrucciones tipo R: una suma (la instrucci\u00f3n <code>add</code>).</p> <p>Recuerden las 5 etapas de pipeline del CPU:</p> <ol> <li>Instruction fetch</li> <li>Instruction decode</li> <li>Execute</li> <li>Memory</li> <li>Writeback</li> </ol> <p>Esta gu\u00eda los ayudar\u00e1 a completar cada uno de estos pasos, de la instrucci\u00f3n <code>add</code>. Cada secci\u00f3n tendr\u00e1 preguntas para que analicen, detalles importantes y referencias al contenido del curso, pero no les dir\u00e1 c\u00f3mo implementarla exactamente. Tal vez necesiten leer y entender cada pregunta antes de pasar a la siguiente y podr\u00e1n ver las respuestas haciendo click a cada pregunta. Mientras implementen el proyecto, si\u00e9ntanse libres de poner cosas en subcircuitos conforme lo vean necesario.</p>"},{"location":"labs/lab08/#etapa-1-instruction-fetch","title":"Etapa 1: Instruction fetch","text":"<p>La parte principal de esta estapa es, \u00bfc\u00f3mo se obtiene la instrucci\u00f3n actual? De las clases, se sabe que las instrucciones son almacenadas en una memoria de instrucciones (texto) y cada instrucci\u00f3n se puede obtener con una direcci\u00f3n.</p> <ol> <li>  \u00bfQu\u00e9 archivo tiene la memoria de datos? \u00bfC\u00f3mo se conecta a su archivo <code>cpu.circ</code>?  Est\u00e1 en el archivo riscv.circ; le da una entrada al cpu llamada <code>Instruction</code> y recibe una salida llamada <code>fetch_addr</code>. </li> <li>  En el CPU, \u00bfc\u00f3mo afecta la direcci\u00f3n que tenemos en la salida <code>fetch_addr</code> a la entrada <code>Instruction</code>?   La instrucci\u00f3n que riscv.circ env\u00eda al CPU debe ser la instrucci\u00f3n en la posici\u00f3n <code>fetch_addr</code> de la memoria de texto. </li> <li>  \u00bfC\u00f3mo sabemos qu\u00e9 valor deber\u00eda tener <code>fetch_addr</code>? (pista: tambi\u00e9n se le llama PC) <code>fetch_address</code> es la direcci\u00f3n de la instrucci\u00f3n que actualmente est\u00e1 siendo ejecutada, as\u00ed que se guarda en el registro PC. Para este proyecto, est\u00e1 bien que PC empiece en 0, el valor por defecto de los registros.</li> <li>  En este proyecto, \u00bfqu\u00e9 cantidad de bits tiene el PC? 32 bits.</li> <li>  Para programas sencillos sin ning\u00fan jump o branch, \u00bfc\u00f3mo deber\u00eda cambiar el PC de l\u00ednea a l\u00ednea?  El PC se debe incrementar en 1 instrucci\u00f3n para poder recibir la siguiente instrucci\u00f3n, ya que la direcci\u00f3n almacenada en el PC representa la instrucci\u00f3n a ejecutar.</li> <li>En los archivos del proyecto, ya est\u00e1 el PC. implementen el comportamiento del PC para programas simples (sin jumps o branches). Tendr\u00e1n que agregar esto m\u00e1s adelante, pero por ahora s\u00f3lo piensen en ejecutar un programa con <code>add</code> . Piensen a d\u00f3nde debe estar conectada la salida del PC. \u00a1No se olviden de conectar el clock!</li> </ol>"},{"location":"labs/lab08/#etapa-2-instruction-decode","title":"Etapa 2: Instruction decode","text":"<p>Ya que tienen la instucci\u00f3n en el tunnel <code>Instruction</code>, deben separarla en el paso de decodificaci\u00f3n de acuerdo a lo que han aprendido en clase acerca de formatos de instrucciones de Risc-V.</p> <ol> <li>  \u00bfQu\u00e9 tipo de instrucci\u00f3n es <code>add</code>? \u00bfCu\u00e1les son sus diferentes campos y qu\u00e9 bits se necesitan para cada uno?  (Vean las instrucciones del proyecto :D)</li> <li>  En Logisim, \u00bfqu\u00e9 se utiliza para separar (split out) diferentes grupos de bits?   \u00a1Un splitter!       </li> <li>Implementen la etapa de decodificaci\u00f3n de los campos de la instrucci\u00f3n usando la entrada <code>instruction</code>. Deber\u00edan usar tunnels para etiquetar y agrupar los bits.</li> <li>  Ahora deben obtener datos de los registros correspondientes usando el register file. \u00bfQu\u00e9 campos de bits deben estar conectados al register file? \u00bfA qu\u00e9 entradas del register file deber\u00edan conectarse?  Los campos <code>rs1 y rs2</code> deben ir a <code> Read register </code> 1 y 2.</li> <li>Implementen la forma de leer del <code>register file</code>. Van a tener que usar su regfile.circ de la parte 1 (seguro ya la tienen hecha :), si no, ya van un poco tarde). \u00a1No se olviden de conectar el clock!</li> </ol>"},{"location":"labs/lab08/#etapa-3-execute","title":"Etapa 3: Execute","text":"<p>Esta etapa, tambi\u00e9n conocida como ALU stage, es la etapa en la cual se computan la mayor\u00eda de instrucciones. Aqu\u00ed se introducir\u00e1 la idea de implementar un <code>m\u00f3dulo de control</code>.</p> <ol> <li>  Para la instrucci\u00f3n <code>add</code>, \u00bfcu\u00e1les deber\u00edan ser las entradas del ALU?   Read Data 1 y 2 deben ir a los puertos A y B del ALU</li> <li>  En el ALU, \u00bfcu\u00e1l es el prop\u00f3sito del switch llamado <code>ALU_ctr</code>?  Elige la operaci\u00f3n que el ALU debe realizar.</li> <li>  Aunque para un add es posible poner un valor constante en el control del ALU, \u00bfpor qu\u00e9 ser\u00eda malo hacer esto conforme siguen implementando m\u00e1s instrucciones del proyecto?  En otras instrucciones, las entradas del ALU pueden cambiar, por lo que es necesario alg\u00fan tipo de (sub)circuito que cambie los valores de entrada y/o salida, dependiendo de la instrucci\u00f3n siendo ejecutada.</li> <li>Ahora implementen un subcircuito para el m\u00f3dulo de control. Este m\u00f3dulo debe recibir como entradas el opcode y funct y, como salidas, los valores adecuados para el manejo correcto del ALU para cada instrucci\u00f3n. Hay varias formar de lograr esto (pueden ver el instructivo del proyecto para m\u00e1s ayuda). Al implementar m\u00e1s instrucciones, este m\u00f3dulo puede hacerce m\u00e1s complejo.</li> <li>Utilicen el ALU de la parte anterior y con\u00e9ctenlo correctamente. \u00bfEs necesario conectar el clock? \u00bfPor qu\u00e9, o por qu\u00e9 no?</li> </ol>"},{"location":"labs/lab08/#etapa-4-memory","title":"Etapa 4: Memory","text":"<p>En esta etapa se pueden almacenar datos a una memoria con instrucciones \"store\", y recuperar datos con instrucciones de \"load\". Como <code>add</code> no utiliza la memoria, la gu\u00eda no se enfocar\u00e1 mucho en esta etapa. Vean el m\u00f3dulo de memoria en el proyecto. En este punto no se explicar\u00e1 lo que debe tener en cada una de sus entradas, pero si\u00e9ntanse libres de implementarlo por su cuenta cuando aprendan qu\u00e9 hacer. Pueden conectarle el clock mientras tanto.</p>"},{"location":"labs/lab08/#etapa-5-write-back","title":"Etapa 5: Write back","text":"<p>La estapa de escritura es donde el resultado de la operaci\u00f3n se guarda de regreso a los registros. Aunque no todas las instrucciones escriben de regreso a los registros (piensen en cuales), <code>add</code> si lo hace.</p> <ol> <li>  Viendo el ISA, \u00bfqu\u00e9 instrucciones s\u00ed usan esta etapa?   add recibe un dato del ALU y lo guarda en un registro. lw recibe un dato de la memoria y lo escribe en un registro. Hay muchas instrucciones m\u00e1s que hacen esto. </li> <li>Implementen la etapa de escritura de modo que sea capaz de obtener datos, tanto del ALU como de la memoria, y escribirlos al Register File. Luego, cuando implementen saltos/branches, tal vez tengan que agregar m\u00e1s cosas a este MUX. Sin embargo, por el momento, deben poder escoger entre el ALU y la memoria, ya que s\u00f3lo una salida puede llegar al m\u00f3dulo de registros. Conecten un cable de las salidas del ALU y MEM hacia un multiplexor.</li> <li>  \u00bfQu\u00e9 deber\u00eda tener el selector del mux? \u00bfDe qu\u00e9 depende esta entrada?   El selector escoge qu\u00e9 salida (ALU o MEM) llega al Reg. File y la salida correcta depende de qu\u00e9 instrucci\u00f3n est\u00e1 ejecut\u00e1ndose. Esto sugiere que la entrada del selector deber\u00eda venir del m\u00f3dulo de control, porque el control se encarga de descifrar qu\u00e9 instrucci\u00f3n se ejecuta (con el opcode y las funct). </li> <li>Ahora viene el segundo (y posiblemente m\u00e1s importante) rol de los m\u00f3dulos de control: determinar qu\u00e9 valores salen del m\u00f3dulo al CPU, para poder controlar el flujo de ejecuci\u00f3n. A esto se le llaman Se\u00f1ales de Control.</li> </ol> <p>Un ejemplo de estas es la se\u00f1al que controla el MUX mencionado anteriormente, com\u00fanmente llamado WBsel. WBsel determina el valor que se escribe de regreso a los registros.</p> <p>Hay m\u00e1s se\u00f1ales de control que pueden encontrar en el material de la clase y van a tener que definir algunas m\u00e1s. Si notan que van a necesitar un mux en alguna parte del proyecto, muy posiblemente van a tener que definir una se\u00f1al de control para el mux.</p> <ol> <li>Hay varias formas de implementar el control para que traduzca los opcodes/functs a la instrucci\u00f3n correspondiente y luego configurar las se\u00f1ales de control correctamente. Una forma (vista en clase) es con una ROM. Los otros m\u00e9todos usan l\u00f3gica de <code>and</code>s y <code>or</code>s para alcanzar el objetivo. Prueben implementar las se\u00f1ales de control pertinentes a la instrucci\u00f3n <code>add</code>.</li> <li>  Ya que tienen las entradas del mux, necesitan conectar la salida. \u00bfA d\u00f3nde va la salida?   Como el output son los datos que quieren escribir al register file, deber\u00eda conectarse a la entrada <code>Write Data</code> del Register File </li> <li>Hay dos entradas m\u00e1s al Register File que son importantes para escribir datos: RegWEn y Write Register. Uno de estos viene de la etapa de decodificaci\u00f3n y, para el otro, deber\u00e1n hacer una nueva se\u00f1al de control. Terminen la etapa de Write Back conectando del m\u00f3dulo de control, y de la etapa de decodificaci\u00f3n, las entradas correspondientes al register file.</li> </ol> <p>Si han hecho todos estos pasos correctamente, deber\u00edan tener un procesador que funciona para sumar. Para el resto del proyecto, van a estar implementando m\u00e1s instrucciones de la misma forma; conectando salidas a entradas, agregando muxes y otros componentes de Logisim y definiendo se\u00f1ales de control nuevas. Deber\u00eda ser m\u00e1s f\u00e1cil ahora que tienen un esqueleto b\u00e1sico para trabajar. Recuerden el contenido del curso ya tienen bastante informaci\u00f3n y los ayudar\u00e1 a seguir construyendo los circuitos que tienen ahora. \u00a1\u00c9xitos!</p>"},{"location":"labs/lab09/","title":"Lab 9 - Localidad de Datos y Caches","text":""},{"location":"labs/lab09/#objetivos","title":"Objetivos","text":"<ul> <li>Entender c\u00f3mo los patrones de acceso a memoria determinan las tasas de cache hits.</li> <li>Pensar qu\u00e9 patrones de acceso a memoria producen BUENAS tasas de acierto.</li> <li>Aprender sobre una t\u00e9cnica para mejorar los accesos a memoria.</li> </ul>"},{"location":"labs/lab09/#preparacion","title":"Preparaci\u00f3n","text":"<p>Aqu\u00ed pueden descargar los archivos que utilizar\u00e1n para esta pr\u00e1ctica.</p>"},{"location":"labs/lab09/#notas","title":"Notas","text":"<ul> <li>Para esta pr\u00e1ctica de laboratorio se utilizar\u00e1 Venus, un simulador de c\u00f3digo de ensamblador en l\u00ednea. Este programa permite visualizar los accesos al cache.</li> <li>Este laboratorio es complicado, largo y dif\u00edcil. Aseg\u00farense de saber lo requerido sobre el tema antes de subir los resultados al autograder y \u00a1PREGUNTEN si no entienden!</li> <li>No se olviden que el tema de caches viene en el examen parcial, por lo que la visualizaci\u00f3n de acceso a caches es una manera pr\u00e1ctica para aprender sobre los cache hits y cache misses.</li> </ul> <p>En este punto, lean cache.s para tener una idea de qu\u00e9 es lo que hace. Aseg\u00farense de revisar qu\u00e9 contienen los registros de argumentos antes de proceder a analizar la configuraci\u00f3n del cache.</p> <ul> <li>Lo m\u00e1s importante de entender de este archivo es que se pondr\u00e1n en cero algunos elementos de un arreglo (opci\u00f3n 0) o se incrementar\u00e1n (opci\u00f3n 1).</li> <li>Los elementos a editar est\u00e1n determinados por el step size y la cantidad de veces que se realiza este procedimiento lo indica repcount. Estos dos par\u00e1metros son los que m\u00e1s afectar\u00e1n la cantidad de cache hits y misses que ocurrir\u00e1n. El valor de option tambi\u00e9n alterar\u00e1 algunas, as\u00ed como los par\u00e1metros del cache mismo, por supuesto.</li> </ul>"},{"location":"labs/lab09/#ejercicio-1-algunos-escenarios-de-acceso-a-memoria","title":"Ejercicio 1: Algunos Escenarios de Acceso a Memoria","text":"<p>Para este ejercicio deben de contestar las preguntas adjuntas, con el formato indicado, en el archivo <code>ex1.txt</code>. Intenten razonar cu\u00e1l va a ser la tasa de aciertos ANTES de correr la simulaci\u00f3n. Luego de ejecutar el c\u00f3digo, aseg\u00farense de entender POR QU\u00c9 ocurre lo que ocurre.</p> <p>No duden en preguntar si se sienten confundidos. Eso es totalmente normal y los auxiliares est\u00e1n ah\u00ed para ayudarlos.</p> <p>Estas son buenas preguntas para hacerse mientras realizan los ejercicios:</p> <ul> <li>\u00bfQu\u00e9 tan grande es su cache block?</li> <li>\u00bfCu\u00e1ntos accesos consecutivos (tomando en cuenta el step size) caben en un \u00fanico block?</li> <li>\u00bfCu\u00e1nta data cabe en el cache COMPLETO?</li> <li>\u00bfQu\u00e9 tan lejos, en memoria, est\u00e1n los bloques que mapean al mismo set (y que pudieran causar conflictos)?</li> <li>\u00bfCu\u00e1l es la asociatividad de su cache?</li> <li>\u00bfEn qu\u00e9 parte del cache mapea alg\u00fan bloque particular?</li> <li>Al considerar por qu\u00e9 un acceso espec\u00edfico es un hit o un miss: \u00bfya se accedi\u00f3 a esta data antes? Si s\u00ed, \u00bfsigue en el cache o no?</li> </ul>"},{"location":"labs/lab09/#escenario-1","title":"Escenario #1","text":"<p>Cache Parameters: (editados en la pesta\u00f1a de \"Cache\" en el simulador)</p> <ul> <li>Pol\u00edtica de colocaci\u00f3n: Direct Mapping</li> <li>Pol\u00edtica de reemplazo de bloques: LRU</li> <li>Tama\u00f1o del set (bloques) (setSize): 1</li> <li>Cantidad de bloques: 4</li> <li>Tama\u00f1o de los bloques del cache (en words) (blockSize): 2</li> </ul> <p>Par\u00e1metros del Programa: (inicializando los valores de los argumentos en el c\u00f3digo)</p> <ul> <li>Tama\u00f1o del arreglo (arraySize): 128 bytes</li> <li>Tama\u00f1o del salto (stepSize): 8</li> <li>N\u00famero de repeticiones (repCount): 4</li> <li>Opci\u00f3n: 0</li> </ul> <p>Tip: Si les es dif\u00edcil visualizar qu\u00e9 est\u00e1 entrando en el cache en cada acceso a memoria simplemente viendo el c\u00f3digo, prueben utilizando l\u00e1piz y papel: escriban cu\u00e1l ser\u00eda el tag:index:offset de las direcciones y averig\u00fcen cu\u00e1les direcciones de memoria mapean a los distintos sets en cache con los bits del index.</p> <p>Preguntas:</p> <ol> <li>\u00bfQu\u00e9 combinaci\u00f3n de par\u00e1metros produce el hit rate que se puede observar? (Pista: Su respuesta debe de ser de la forma: \"Porque [par\u00e1metro 1], en bytes, es exactamente igual a [par\u00e1metro 2], en bytes.\")</li> <li>\u00bfEn cu\u00e1nto aumenta el hit rate al incrementar la cantidad de repeticiones de manera arbitraria (en %)?</li> <li>\u00bfC\u00f3mo se puede modificar alg\u00fan par\u00e1metro del programa para mejorar el hit rate? Nota: No importa que accedan a los mismos elementos en el arreglo, s\u00f3lo provean una modificaci\u00f3n de un par\u00e1metro del programa que aumente el hit rate.</li> </ol> <ol> <li> <ol> <li>Aumentar el tama\u00f1o del arreglo.</li> <li>Disminuir el tama\u00f1o del arreglo.</li> <li>Aumentar el tama\u00f1o del salto.</li> <li>Disminuir el tama\u00f1o del salto.</li> <li>Aumentar el n\u00famero de repeticiones.</li> <li>Disminuir el n\u00famero de repeticiones.</li> <li>Cambiar a la opci\u00f3n 1.</li> </ol> </li> </ol>"},{"location":"labs/lab09/#escenario-2","title":"Escenario #2","text":"<p>Cache Parameters:</p> <ul> <li>Pol\u00edtica de colocaci\u00f3n: N-Way Set Associative</li> <li>Pol\u00edtica de reemplazo de bloques: LRU</li> <li>Tama\u00f1o del set (bloques) (setSize): 4</li> <li>Cantidad de bloques: 16</li> <li>Tama\u00f1o de los bloques del cache (en words) (blockSize): 4</li> </ul> <p>Par\u00e1metros del Programa: (inicializando los valores de los argumentos en el c\u00f3digo)</p> <ul> <li>Tama\u00f1o del arreglo (arraySize): 256 bytes</li> <li>Tama\u00f1o del salto (stepSize): 2</li> <li>N\u00famero de repeticiones: 1</li> <li>Opci\u00f3n (repCount): 1</li> </ul> <p>Preguntas:</p> <ol> <li> <p>\u00bfCu\u00e1ntos accesos a memoria hay por cada iteraci\u00f3n en el ciclo interno? (Pista: No es uno.)</p> </li> <li> <p>\u00bfCu\u00e1l es el patr\u00f3n que se repite de aciertos y fallos?</p> </li> </ol> <ol> <li> <ol> <li>miss/hit</li> <li>miss/hit/hit</li> <li>miss/hit/hit/hit</li> <li>hit/miss/miss/miss</li> <li>hit/miss</li> </ol> </li> </ol> <ol> <li>\u00bfC\u00f3mo se relaciona el hit rate con el patr\u00f3n de la pregunta anterior?</li> </ol> <ol> <li> <ol> <li>Aplicando una media geom\u00e9trica a los valores del patr\u00f3n se puede obtener el hit rate.</li> <li>El hit rate es el resultado de una media aritm\u00e9tica del patr\u00f3n.</li> <li>Se debe de calcular la media ponderada con los resultados del patr\u00f3n.</li> <li>Al patr\u00f3n se le debe aplicar la media arm\u00f3nica para calcular el hit rate.</li> <li>Ninguna de las anteriores.</li> </ol> </li> </ol> <ol> <li>\u00bfQu\u00e9 ocurre si se altera la cantidad de iteraciones de manera arbitraria?</li> </ol> <ol> <li> <ol> <li>La cantidad de cache misses aumenta.</li> <li>La cantidad de cache hits aumenta.</li> <li>La cantidad de cache misses se queda igual.</li> <li>La cantidad de cache hits se queda igual.</li> <li>El hit rate aumenta.</li> <li>El hit rate disminuye.</li> <li>El hit rate se mantiene constante.</li> </ol> </li> </ol> <ol> <li>\u00bfPor qu\u00e9 le ocurre, lo indicado en la pregunta anterior, al hit rate?</li> </ol> <ol> <li> <ol> <li>Porque se aprovecha la localidad espacial.</li> <li>Porque se aprovecha la localidad temporal.</li> <li>Porque no se aprovecha la localidad espacial.</li> <li>Porque no se aprovecha la localidad temporal.</li> <li>Porque la cantidad de repeticiones no tiene impacto en el hit rate.</li> </ol> </li> </ol> <p>Nota importante para el archivo <code>ex1.txt</code>: Solo se debe escribir las inc\u00f3gnitas en cada fila, estas deben estar separadas por una coma, sin espacios (si la pregunta posee m\u00e1s de una respuesta). Por ejemplo: 1.blockSize,stepSize,arraySize.</p>"},{"location":"labs/lab09/#ejercicio-2-ordenamiento-de-ciclos-y-multiplicacion-de-matrices","title":"Ejercicio 2: Ordenamiento de Ciclos y Multiplicaci\u00f3n de Matrices","text":"<p>Si recuerdan, las matrices son estructuras de datos bidimensionales en donde cada elemento es accedido por medio de dos \u00edndices. Para poder multiplicar dos matrices, se puede utilizar tres ciclos anidados. Asumiendo que las matrices A, B y C son de nxn y guardadas en un arreglo de una dimensi\u00f3n, en donde sus elementos est\u00e1n ubicados de manera contigua en memoria:</p> <pre><code>for (int i = 0; i &lt; n; i++)\n    for (int j = 0; j &lt; n; j++)\n        for (int k = 0; k &lt; n; k++)\n            C[i+j*n] += A[i+k*n] * B[k+j*n];\n</code></pre> <p>Hecho: La multiplicaci\u00f3n de matrices se encuentran detr\u00e1s de numerosos algoritmos de \u00e1lgebra lineal y la operaci\u00f3n eficaz de ello es cr\u00edtico para muchas aplicaciones dentro de las ciencias aplicadas.</p> <p>N\u00f3tese que en el c\u00f3digo superior los ciclos est\u00e1n ordenados como i, j, k. Si se examina el bucle m\u00e1s \u00edntimo, se puede ver que este...:</p> <ul> <li>recorre B en pasos unitarios.</li> <li>recorre A en progresos de tama\u00f1o n.</li> <li>no recorre C.</li> </ul> <p>RECORDAR: Para calcular la multiplicaci\u00f3n de matrices de manera correcta, no importa el orden de los ciclos.</p> <p>PERO, el orden elegido para acceder a los elementos de las matrices pueden tener un impacto muy grande en el rendimiento. Los caches se benefician m\u00e1s (m\u00e1s cache hits; menos misses) cuando el acceso a memoria se aprovecha de la temporalidad espacial y de la espacial, utilizando bloques ya dentro del cache. Optimizando los accesos de memoria de un programa es esencial para aprovecharse de la jerarqu\u00eda de memoria.</p> <p>Gu\u00eden su atenci\u00f3n a matrixMultiply.c, en este archivo se realizan varias implementaciones de la multiplicaci\u00f3n de matrices con tres ciclos anidados. Compilar y ejecutar el c\u00f3digo con el siguiente comando:</p> <p><code>make ex2</code></p> <p>Esto realizar\u00e1 las operaciones de matrices e indicar\u00e1 la velocidad con la que cada iteraci\u00f3n complete las multiplicaciones. La unidad \"Gflops/s\" se lee como \"Giga-floating-point-operations per second\".</p> <p>Preguntas:</p> <ol> <li>\u00bfQu\u00e9 ordenamiento(s) rinde(n) mejor?</li> </ol> <ol> <li> <ol> <li>multMat1</li> <li>multMat2</li> <li>multMat3</li> <li>multMat4</li> <li>multMat5</li> <li>multMat6</li> </ol> </li> </ol> <ol> <li>\u00bfPor qu\u00e9?</li> </ol> <ol> <li> <ol> <li>Porque se aprovecha la localidad espacial.</li> <li>Porque se aprovecha la localidad temporal.</li> <li>Porque utiliza loop unrolling.</li> <li>Porque se realiza cache blocking.</li> </ol> </li> </ol> <ol> <li>\u00bfQu\u00e9 versi\u00f3n (o versiones) muestra(n) ser la(s) m\u00e1s lenta(s)?</li> </ol> <ol> <li> <ol> <li>multMat1</li> <li>multMat2</li> <li>multMat3</li> <li>multMat4</li> <li>multMat5</li> <li>multMat6</li> </ol> </li> </ol> <ol> <li>\u00bfPor qu\u00e9?</li> </ol> <ol> <li> <ol> <li>Porque no se aprovecha la localidad espacial.</li> <li>Porque no se aprovecha la localidad temporal.</li> <li>Porque no utiliza loop unrolling.</li> <li>Porque no se realiza cache blocking.</li> </ol> </li> </ol> <ol> <li>\u00bfC\u00f3mo afecta la manera de recorrer las matrices, respecto del \u00edndice que se encuentra en el ciclo m\u00e1s \u00edntimo, al rendimiento?</li> </ol> <ol> <li> <ol> <li>Es el que mayor impacto tiene en el rendimiento.</li> <li>Su impacto en el rendimiento es irrelevante.</li> <li>De este depende si se aprovecha la localidad temporal o no.</li> <li>Este influye directamente el aprovechamiento de la localidad espacial.</li> <li>Es igual de importante que el resto de \u00edndices.</li> </ol> </li> </ol> <p>Nota importante para el archivo <code>ex2.txt</code>: Similar al archivo de texto del ejercicio anterior, si se requiere de m\u00e1s de una respuesta a una pregunta, estas deben de estar separadas por comas, sin espacios. Por ejemplo: 3.ii,iv.</p>"},{"location":"labs/lab09/#ejercicio-3-cache-blocking-y-transposicion-de-matrices","title":"Ejercicio 3: Cache Blocking y Transposici\u00f3n de Matrices","text":""},{"location":"labs/lab09/#transposicion-de-matrices","title":"Transposici\u00f3n de Matrices","text":"<p>En algunas ocasiones, se requiere intercambiar las filas con las columnas de una matriz, esta operaci\u00f3n se llama una transposici\u00f3n. Una implementaci\u00f3n eficiente pude ser de gran utilidad al implementar operaciones algebraicas m\u00e1s complejas. La matriz transpuesta de A suele denotarse como AT.</p> <p></p>"},{"location":"labs/lab09/#cache-blocking","title":"Cache Blocking","text":"<p>En el c\u00f3digo ejemplo de multiplicaci\u00f3n de matrices del ejercicio anterior se puede notar que se recorren las matrices A y B en su totalidad para calcular un \u00fanico valor para C. Por lo mismo, \u00a1constantemente se debe de acceder a valores nuevos de memoria, reusando muy poca data en con el cache! Se puede mejorar el reuso de data en los caches implementando un t\u00e9cnica llamada cache blocking. Formalmente, cache blocking es una t\u00e9cnica que busca reducir la tasa de cache misses a\u00fan m\u00e1s al explotar la temporalidad espacial y/o temporal. En el caso de la transposici\u00f3n de matrices, se considera realizarla un bloque a la vez.</p> <p></p> <p>Notar: En la imagen superior, se transpone cada submatriz Aij de la matriz A en su posici\u00f3n final de la matriz de salida, una submatriz a la vez. Es importante entender que la transposici\u00f3n de por secciones es equivalente a hacerlo para toda la matriz.</p> <p>Como se opera y se termina de transponer cada submatriz una a la vez, se consodila el acceso a memoria a un espacio de memoria menor al transponer esa submatriz, aprovechando las localidades temporales (y espaciales), mejorando el rendimiento del cache, acortando el tiempo de ejecuci\u00f3n del programa.</p> <p>Para este laboratorio, se implementar\u00e1 una estructura de cache blocking para la transposici\u00f3n de matrices y se analizar\u00e1 su rendimiento. Su tarea es implementar esta t\u00e9cnica en la funci\u00f3n transpose_blocking() en transpose.c. NO pueden asumir que el ancho de la matriz (n) es un m\u00faltiplo del tama\u00f1o del bloque. Luego de implementar la funci\u00f3n, pueden probar el c\u00f3digo corriendo los siguientes comandos:</p> <p><code>make ex3 ./transpose &lt;n&gt; &lt;blocksize&gt;</code></p> <p>Donde n y blocksize son par\u00e1metros que ser\u00e1n especificados por el usuario. Se puede verificar el funcionamiento del c\u00f3digo eligiendo n=10000 y blocksize=33. La versi\u00f3n con blocking deber\u00eda terminar significantemente m\u00e1s r\u00e1pido.</p> <p>A continuaci\u00f3n, se muestra una gu\u00eda por si no saben c\u00f3mo comenzar. De lo contrario, pueden saltarse esta parte y comenzar.</p> <p>Algunos consejos:</p> <p>Pueden empezar viendo la funci\u00f3n transpose_naive. Notar que el \u00edndice y recorre TODA la matriz src de manera vertical en una iteraci\u00f3n del ciclo externo antes de ser reiniciada a cero. Es decir, x se actualiza hasta que y termine su recorrido. Este es el comportamiento que se debe corregir. Lo que se quiere es moverse a la siguiente fila de dst despu\u00e9s de recorrer el ancho (eje horizontal) de un solo bloque.</p>  \u00bfQu\u00e9 tan grande es cada bloque?  El n\u00famero de enteros especificados por _blocksize_.  <p>Adem\u00e1s, solo se desea mover en el eje vertical (la altura) de un bloque antes de proseguir al siguiente. No se busca que x imite el comportamiento que se quiere evitar con el par\u00e1metro y.</p> <p>Ayuda: Una soluci\u00f3n est\u00e1ndar requiere de cuatro ciclos for.</p> <p>Finalmente, como no se puede asumir que n es un m\u00faltiplo de blocksize, la \u00faltima columna del bloque de cada fila ser\u00e1 m\u00e1s corta (no ser\u00e1 un cuadrado de block_size por block_size). Adem\u00e1s, la \u00faltima fila del bloque estar\u00e1 truncada. Para arreglar este problema, se puede realizar la situaci\u00f3n general que n s\u00ed es m\u00faltiplo de block_size y agregar, como caso especial, una alternativa para lidiar con la excepci\u00f3n de que se est\u00e1 recorriendo una parte del arreglo inexistente.</p> <p>Cuando ya funcione el c\u00f3digo, se deben completar los siguientes ejercicios:</p>"},{"location":"labs/lab09/#alternado-los-tamanos-de-los-arreglos","title":"Alternado los Tama\u00f1os de los Arreglos","text":"<p>Fijar el tama\u00f1o del bloque a 20 y ejecutar el c\u00f3digo con las siguientes variantes de n: 50, 100, 500, 1000, 5000.</p> <ol> <li>\u00bfA partir de qu\u00e9 punto se puede notar una mejora en rendimiento al comparar la versi\u00f3n con cache blocking y la versi\u00f3n com\u00fan?</li> </ol> <ol> <li> <ol> <li>50</li> <li>100</li> <li>500</li> <li>1000</li> <li>5000</li> </ol> </li> </ol> <ol> <li>\u00bfPor qu\u00e9 el m\u00e9todo de cache blocking requiere que la matriz sea de cierto tama\u00f1o para que su mejora sea percibida?</li> </ol> <ol> <li> <ol> <li>Porque necesita aprovechar la localidad espacial.</li> <li>Porque as\u00ed puede explotar la localidad temporal.</li> <li>Porque el tama\u00f1o de la matriz debe ser un m\u00faltiplo del tama\u00f1o del bloque.</li> <li>Por la Ley de Amdahl.</li> <li>Ninguna de las anteriores.</li> </ol> </li> </ol>"},{"location":"labs/lab09/#cambiando-el-tamano-del-bloque","title":"Cambiando el Tama\u00f1o del Bloque","text":"<p>Fijar el ancho de las matrices a 10000 y correr el c\u00f3digo con los siguientes valores para blocksize: 100, 1000, 2000, 5000, 10000.</p> <ol> <li>\u00bfC\u00f3mo se ve afectada la velocidad de ejecuci\u00f3n de transpose_blocking() al cambiar el tama\u00f1o del bloque?</li> </ol> <ol> <li> <ol> <li>Aumenta de manera lineal.</li> <li>Disminuye de manera lineal.</li> <li>Aumenta de manera logar\u00edtmica.</li> <li>Disminuye de manera logar\u00edtmica.</li> <li>Se mantiene constante.</li> </ol> </li> </ol> <ol> <li>\u00bfPor qu\u00e9 ocurre lo indicado en la respuesta anterior?</li> </ol> <ol> <li> <ol> <li>Porque se aprovecha m\u00e1s el uso de los bloques si son m\u00e1s grandes.</li> <li>Porque se desaprovecha el uso de los bloques si su tama\u00f1o aumenta.</li> <li>Porque se aprovecha de la localidad espacial.</li> <li>Porque se aprovecha de la localidad temporal.</li> <li>Porque es una caracter\u00edstica intr\u00ednseca de la operaci\u00f3n realizada.</li> </ol> </li> </ol> <p>Escribir las respuestas en el archivo <code>ex3.txt</code>. Siguiendo las directrices indicadas para los ejercicios anteriores.</p> <p>Es relevante notar que en los \u00faltimos dos ejercicios no fue necesario conocer los par\u00e1metros del cache de sus computadoras. Solo se exhibi\u00f3 un nivel m\u00e1s alto de localidad y se aceler\u00f3 la ejecuci\u00f3n del programa. Esto implica que todos los caches, sin importar sus par\u00e1metros espec\u00edficos, se benefician al ejecutar c\u00f3digo que se aprovecha de altos niveles de localidad.</p>"},{"location":"labs/lab09/#calificacion","title":"Calificaci\u00f3n","text":"<p>Recuerden que pueden evaluar, de manera local, sus respuestas ejecutando:</p> <pre><code>    ./check\n</code></pre> <p>Al terminar, deben de subir su laboratorio al calificador en l\u00ednea con:</p> <pre><code>    ./submit &lt;TOKEN&gt;\n</code></pre>"},{"location":"labs/lab10/","title":"Lab 7 - SIMD Intrinsics y Loop Unrolling","text":""},{"location":"labs/lab10/#objetivos","title":"Objetivos","text":"<ul> <li>Aprender acerca de las instrucciones SIMD y hacer data level parallelism.</li> <li>Escribir c\u00f3digo con funciones SIMD para hacer ciertas optimizaciones.</li> <li>Aprender acerca de loop unrolling y por qu\u00e9 este funciona.</li> </ul>"},{"location":"labs/lab10/#preparacion","title":"Preparaci\u00f3n","text":"<p>Tienen que tener todos los archivos base, estos se encuentran aqu\u00ed. Recuerden que tienen que aprovechar el uso de Git y subir el link de su repositorio al GES, as\u00ed como al autograder, de lo contrario su nota ser\u00e1 de 0.</p>"},{"location":"labs/lab10/#ejercicio-1-familiarizandose-con-las-funciones-simd","title":"Ejercicio 1: Familiariz\u00e1ndose con las funciones SIMD.","text":"<p>Dado el gran n\u00famero disponible de instrucciones SIMD, queremos que ustedes aprendan c\u00f3mo encontrar aquellas que necesitar\u00e1n para determinadas aplicaciones. Intel proporciona una variedad de herramientas relacionadas a intrinsics, las cuales pueden encontrar aqu\u00ed (estas no son necesarias para este laboratorio). Nosotros estamos, particularmente, interesados en la Gu\u00eda Intel Intrinsics. Abran esta p\u00e1gina y, una vez est\u00e9n dentro, hagan click en todos los checkboxes que empiecen con SSE (desde SSE hasta SSE4.2). Hagan su mejor esfuerzo para interpretar esta nueva sintaxis y terminolog\u00eda.</p> <p>Encuentren la instrucci\u00f3n de 128 bits para las siguientes operaciones SIMD:</p> <ol> <li>Cuatro divisiones de punto flotante con precisi\u00f3n simple (float):</li> <li>a) <code>__m128 _mm_div_ss(__m128 a, __m128 b)</code></li> <li>b) <code>__m128 _mm_cvtsi64_ss(__m128 a, __int64 b)</code></li> <li>c) <code>float _mm_cvtss_f32(__m128 a)</code></li> <li>d) <code>__m128_mm_div_ps(__mm128 a, __mm128 b)</code></li> <li>e) <code>__m128 _mm_load_ps(float const* mem_addr)</code></li> <li>f) <code>__m128 _mm_loadu_ps(float const* mem_addr)</code></li> <li>Diecis\u00e9is operaciones de m\u00e1ximo sobre enteros de 8 bits con signo (char):</li> <li>a) <code>__m128i _mm_max_epi16 (__m128i a, __m128i b)</code></li> <li>b) <code>__m128i _mm_max_epi32 (__m128i a, __m128i b)</code></li> <li>c) <code>__m128i _mm_max_epi8 (__m128i a, __m128i b)</code></li> <li>d) <code>__m128i _mm_max_epu16 (__m128i a, __m128i b)</code></li> <li>e) <code>__m128i _mm_max_epu32 (__m128i a, __m128i b)</code></li> <li>f) <code>__m128i _mm_max_epu8 (__m128i a, __m128i b)</code></li> <li>g) <code>__m128d _mm_max_pd (__m128d a, __m128d b)</code></li> <li>h) <code>__m64 _mm_max_pi16 (__m64 a, __m64 b)</code></li> <li>i) <code>__m128 _mm_max_ps (__m128 a, __m128 b)</code></li> <li>j) <code>__m64 _mm_max_pu8 (__m64 a, __m64 b)</code></li> <li>k) <code>__m128d _mm_max_sd (__m128d a, __m128d b)</code></li> <li>l) <code>__m128 _mm_max_ss (__m128 a, __m128 b)</code></li> <li>Shift right aritm\u00e9tico sobre ocho enteros de 16 bits con signo (short):</li> <li>a) <code>__m128i _mm_add_epi16(__m128i a, __m128i b)</code></li> <li>b) <code>__m128i _mm_maskz_abs_epi8(__mmask16 k, __m128i a)</code></li> <li>c) <code>__m128i _mm_srai_epi16(__m128i a, __m128i count)</code></li> <li>d) <code>__m128i _mm_slli_epi64(__m128i a, int count)</code></li> <li>e) <code>__m128i _mm_srai_epi32(__m128i a, __m128i count)</code></li> <li>f) <code>__m128i _mm_sra_epi16(__m128i a, __m128i count)</code></li> </ol> <p>Escriban sus respuestas en el archivo ex1.txt. Ustedes tienen que colocar \u00fanicamente la letra de la opci\u00f3n que consideren correcta; ejemplo de un archivo correcto:</p> <pre><code>1: a\n2: a\n3: a\n</code></pre>"},{"location":"labs/lab10/#ejercicio-2-escribiendo-codigo-simd","title":"Ejercicio 2: Escribiendo C\u00f3digo SIMD","text":"<p>Para el ejercicio 2, ustedes deben vectorizar el siguiente c\u00f3digo para lograr obtener, aproximadamente, cuatro veces la velocidad en comparaci\u00f3n a la implementaci\u00f3n que se muestra a continuaci\u00f3n:</p> <pre><code>static int sum_naive(int n, int *a) {\nint sum = 0;\nfor (int i = 0; i &lt; n; i++) {\nsum += a[i];\n}\nreturn sum;\n}\n</code></pre> <p>Pueden encontrar \u00fatiles las siguientes intrinsics :</p> SIMD Descripci\u00f3n <code>__m128i _mm_setzero_si128( )</code> devuelve un vector de 128 bits de ceros <code>__m128i _mm_loadu_si128(__m128i *p)</code> devuelve el vector de 128 bits guardado en el puntero <code>p</code> <code>__m128i _mm_add_epi32(__m128i a, __m128i b)</code> devuelve el vector (\\(a_0 + b_0\\), \\(a_1 + b_1\\), \\(a_2 + b_2\\), \\(a3 + b3\\)) <code>void _mm_storeu_si128(__m128i *p,__m128i a)</code> guarda el vector de 128 bits representado por el puntero <code>p</code> <p>El archivo que deben modificar es sum.c. Usen las intrinsics SSE para implementar la funci\u00f3n <code>sum_vectorized()</code>. Para compilar su c\u00f3digo, ejecuten el siguiente comando:</p> <pre><code>make sum\n</code></pre> <p>Para ejecutar su c\u00f3digo, corran el siguiente comando:</p> <pre><code>./sum\n</code></pre>"},{"location":"labs/lab10/#ejercicio-3-loop-unrolling","title":"Ejercicio 3: Loop Unrolling","text":"<p>Afortunadamente, a\u00fan pueden obtener m\u00e1s mejoras en el rendimiento. Cuidadosamente, tomen el c\u00f3digo que crearon en el ejercicio previo y hagan un \"unroll\" del vector SIMD. Esto deber\u00eda mejorar el rendimiento en , aproximadamente, un factor de dos. Como un ejemplo de un \"loop unroll\", consideren la funci\u00f3n <code>sum_unrolled()</code> que se les proporciona:</p> <pre><code>static int sum_unrolled(int n, int *a) {\nint sum = 0;\n\n// unrolled loop\nfor (int i = 0; i &lt; n / 4 * 4; i += 4) {\nsum += a[i+0];\nsum += a[i+1];\nsum += a[i+2];\nsum += a[i+3];\n}\n\n// tail case\nfor (int i = n / 4 * 4; i &lt; n; i++) {\nsum += a[i];\n}\n\nreturn sum;\n}\n</code></pre> <p>Adem\u00e1s, si\u00e9ntanse libres de darle un vistazo al art\u00edculo de Wikipedia: Loop Unrolling, para m\u00e1s informaci\u00f3n. Dentro de sum.c, copien su c\u00f3digo de <code>sum_vectorized()</code> hacia <code>sum_vectorized_unrolled()</code> y hagan un unroll de cuatro. Para compilar su c\u00f3digo, corran el siguiente comando:</p> <pre><code>make sum\n</code></pre> <p>Para ejecutar su c\u00f3digo, corran el siguiente comando:</p> <pre><code>./sum\n</code></pre>"},{"location":"labs/lab10/#calificacion","title":"Calificaci\u00f3n","text":"<p>Al terminar, deben de subir su laboratorio al autograder con:</p> <pre><code>./submit &lt;TOKEN&gt;\n</code></pre> <p>No olviden subir el link de su repositorio en Github al GES.</p>"},{"location":"labs/lab11/","title":"Lab 8 - Thread Level parallelism con OpenMP","text":""},{"location":"labs/lab11/#objetivo","title":"Objetivo","text":"<ul> <li>Aprender acerca de OpenMP y thread level parallelism</li> </ul>"},{"location":"labs/lab11/#referencias-adicional","title":"Referencias Adicional","text":"<ul> <li>OpenMP Hands On</li> <li>OpenMP Tutorials</li> </ul>"},{"location":"labs/lab11/#preparacion","title":"Preparaci\u00f3n","text":"<p>Tienen que tener todos los archivos base, estos se encuentran aqu\u00ed. Recuerden que tienen que aprovechar el uso de Git y subir el link de su repositorio al GES, as\u00ed como al autograder, de lo contrario su nota ser\u00e1 de 0.</p> <p>Por favor revisen la secci\u00f3n de calificaci\u00f3n para conocer el l\u00edmite de submits que tienen.</p>"},{"location":"labs/lab11/#introduccion-a-openmp","title":"Introducci\u00f3n a OpenMP","text":"<p>OpenMP es un framework de programaci\u00f3n paralela para C/C++ y Fortran. Ha ganado bastante popularidad en los \u00faltimos a\u00f1os, principalmente por su simplicidad y buen performance. En este laboratorio vamos a darle un vistazo a una peque\u00f1a fracci\u00f3n de sus caracter\u00edsticas, pero en la secci\u00f3n Referencia Adicional hay links con m\u00e1s informaci\u00f3n y tutoriales (para los interesados).</p> <p>Hay muchos tipos de paralelismo y patrones para aprovechar ese paralelismo. OpenMP utiliza un modelo de fork y join anidado. Por defecto, un programa de OpenMP es un programa sequencial normal, exceptuando las regiones que el programador explicitamente declara para que se ejecuten en paralelo. En la regi\u00f3n paralela, el framework crea (hace un fork) un n\u00famero de threads. Tipicamente estos threads ejecutan las mismas instrucciones, solo que en diferentes porciones de los datos. Al final de la regi\u00f3n paralela, el framework espera por todos los threads a que terminen (hace join) antes de dejar la regi\u00f3n y continuar secuencialmente.</p> <p> </p> <p>OpenMP utiliza memoria compartida, esto significa que todos los threads pueden acceder al mismo espacio de direcciones. La alternativa a esto ser\u00eda memoria distribuida, que es lo principal en clusters donde los datos deber\u00edan de ser movidos explicitamente entre espacios de direcciones. Muchos programadores encuentran la memoria compartida m\u00e1s f\u00e1cil de programar, dado que no tienen que preocuparse de mover los datos, pero es usualmente m\u00e1s dif\u00edcil de implementar en hardware de una manera escalable. M\u00e1s adelante en este laboratorio vamos a declarar memoria que va a ser local al thread (solo el thread que la declara puede acceder a esta memoria) por motivos de performance, pero OpenMP provee la flexibilidad para que los threads puedan compartir memoria sin que el programador lo haga.</p>"},{"location":"labs/lab11/#ejemplo-hola-mundo","title":"Ejemplo Hola Mundo","text":"<p>Para este laboratorio, vamos a utilizar C. OpenMP es un framework con una interfaz de C, esto quiere decir que no es una parte del lenguaje como tal. La mayor\u00eda de caracter\u00edsticas son realmente directivas al compilador. Consideren la siguiente implementaci\u00f3n del Hola Mundo (hello.c)</p> <pre><code>int main() {\n#pragma omp parallel\n{\nint thread_ID = omp_get_thread_num();\nprintf(\" hello world %d\\n\", thread_ID);\n}\n}\n</code></pre> <p>Este programa va a crear (fork) el n\u00famero por defecto de threads y cada thread creado va a imprimir \"hello world\" as\u00ed como tambi\u00e9n el n\u00famero que le corresponde. El <code>#pragma</code> le dice al compilador que el resto de la linea es una directiva, y en este caso es <code>omp parallel</code>. <code>omp</code> declara que es para OpenMP y <code>parallel</code> le dice que el siguiente bloque de c\u00f3digo (lo que est\u00e1 contenido en <code>{}</code>) puede ser ejecutado en paralelo. Pueden probarlo con lo siguiente:</p> <pre><code>make hello\n./hello\n</code></pre> <p>Corran el comando <code>./hello</code> unas cuantas veces. Noten como los n\u00fameros de los threads no necesariamente se imprimen en orden num\u00e9rico y tampoco en el mismo orden si corren <code>./hello</code> multiples veces, esto es porque en una regi\u00f3n <code>omp parallel</code>, el programador se garantiza que las operaciones se pueden hacer en paralelo, y que no hay un orden entre los threads. Tambi\u00e9n vale la pena notar que la variable <code>thread_ID</code> es local a cada thread. En general en OpenMP, las variables que se declaran a fuera de un bloque <code>omp parallel</code> tienen una sola copia y son compartidas a traves de todos los threads, mientras que las variables que se declaran adentro de ese bloque tienen una copia privada para cada thread.</p>"},{"location":"labs/lab11/#ejercicio-1-suma-de-vectores","title":"Ejercicio 1: Suma de Vectores","text":"<p>La suma de vectores es un c\u00e1lculo inherentemente paralelo, as\u00ed que es bueno para que sea el primer ejercicio. La funci\u00f3n <code>v_add</code> adentro de v_add.c va a retornar un arreglo que es la suma de los vectores de entrada <code>x</code> y <code>y</code> componente por componente. Un primer intento de resolverlo se podr\u00eda ver as\u00ed:</p> <pre><code>void v_add(double* x, double* y, double* z) {\n#pragma omp parallel\n{\nfor(int i=0; i&lt;ARRAY_SIZE; i++)\nz[i] = x[i] + y[i];\n}\n}\n</code></pre> <p>Pueden correr esto haciendo lo siguiente:</p> <pre><code>make v_add\n./v_add\n</code></pre> <p>Y las pruebas que se ejecutar\u00e1n van a tomar el tiempo autom\u00e1ticamente y variar el n\u00famero de threads. Ustedes van a ver que a medida de que se incrementa el n\u00famero de threads cada vez se va haciendo m\u00e1s lento. Este problema se debe a que cada thread est\u00e1 ejecutando todo el c\u00f3digo dentro del bloque <code>omp parallel</code>, esto significa que si tienen 8 threads, van a estar sumando los vectores 8 veces. \u00a1\u00a1NO HAGAN ESTE TIPO DE COSAS!!. Para obtener una aceleraci\u00f3n al incrementar el n\u00famero de threads, necesitamos que cada thread haga menos trabajo, no la misma cantidad como antes.</p> <p> </p> <p>Su tarea es modificar v_add de tal manera que se note la aceleraci\u00f3n (la aceleraci\u00f3n se puede estancar a medida de que el n\u00famero de threads se incrementa). La mejor manera para hacer esto es decrementar la cantidad de trabajo que un thread hace. Para ayudarlos en el proceso, hay dos funciones \u00fatiles de OpenMP:</p> <ul> <li><code>int omp_get_num_threads()</code></li> <li><code>int omp_get_thread_num()</code></li> </ul> <p>La funci\u00f3n <code>omp_get_num_threads()</code> va a retornar cuantos threads hay dentro de un bloque <code>omp parallel</code>, y <code>omp_get_thread_num()</code> va a retornar el ID o n\u00famero de thread.</p> <p>Hay dos formas para dividir el trabajo en cada thread, la primera (que no deber\u00edan utilizar) es la t\u00e9cnica de slicing: cada thread maneja sumas adyacentes, es decir, el thread 0 va a sumar todos los elementos que est\u00e1n en los indices <code>i</code> tal que <code>i % omp_get_num_threads()</code> es 0, el thread 1 va a sumar todos los elementos tal que <code>i % omp_get_num_threads()</code> es 1 y as\u00ed... noten que este m\u00e9todo no va a ser eficiente porque va a sufrir de un problema llamado false sharing. La segunda manera de hacerlo (y como lo tienen que hacer ustedes) es la t\u00e9cnica de chunking: si hay N threads, hay que partir los vectores en N chunks continuos, y hacer que cada thread sume cada chunk (como la figura de arriba).</p> <p>PISTA: Puede ser que necesiten un caso especial para prevenir salirse del arreglo. No teman escribir un caso especial.</p> <p>Para este ejercicio, nosotros les estamos pidiendo que manualmente dividan el trabajo a traves de los threads. Dado que es un patr\u00f3n comun, los dise\u00f1adores de OpenMP hicieron una directiva que hace esto por ustedes autom\u00e1ticamente. Aqu\u00ed est\u00e1 la funci\u00f3n utilizando la directiva: (Ustedes NO pueden utilizar esta directiva en su soluci\u00f3n del ejercicio.)</p> <pre><code>void v_add(double* x, double* y, double* z) {\n#pragma omp parallel\n{\n#pragma omp for\nfor(int i=0; i&lt;ARRAY_SIZE; i++)\nz[i] = x[i] + y[i];\n}\n}\n</code></pre>"},{"location":"labs/lab11/#ejercicio-2-producto-punto","title":"Ejercicio 2: Producto Punto","text":"<p>El siguiente calculo interesante que queremos ver es el producto punto entre dos vectores. A primera vista, implementar esto puede ser no muy diferente a <code>v_add</code>, pero el reto es como sumar todos los productos en una misma variable (reducci\u00f3n/reduction). Manejar de forma no inteligente la reducci\u00f3n va a resultar en las famosas condiciones de carrera: todos los threads est\u00e1n tratando de leer y escribir a la misma direcci\u00f3n simult\u00e1neamente. Una soluci\u00f3n es utilizar una secci\u00f3n cr\u00edtica. El c\u00f3digo en la secci\u00f3n cr\u00edtica puede ser \u00fanicamente ejecutado por un solo thread. Tener una secci\u00f3n cr\u00edtica naturalmente previene que multiples threads lean y escriban a los mismos datos, un problema que podr\u00eda llevar a condiciones de carrera. Una soluci\u00f3n no muy buena proteger\u00eda la suma con una secci\u00f3n cr\u00edtica (dotp.c):</p> <pre><code>double dotp(double* x, double* y) {\ndouble global_sum = 0.0;\n#pragma omp parallel\n{\n#pragma omp for\nfor(int i=0; i&lt;ARRAY_SIZE; i++)\n#pragma omp critical\nglobal_sum += x[i] * y[i];\n}\nreturn global_sum;\n}\n</code></pre> <p>Pruben el c\u00f3digo haciendo:</p> <pre><code>make dotp\n./dotp\n</code></pre> <p>Noten como el performance es peor a medida que el n\u00famero de threads se incrementa. Dado que se est\u00e1 poniendo todo el trabajo de la reducci\u00f3n en la secci\u00f3n cr\u00edtica, hemos desperdiciado el paralelismo y hecho que solo un thread pueda hacer el trabajo cada tiempo (que no es exactamente la idea detr\u00e1s del paralelismo a nivel de threads). Esto es algo problem\u00e1tico, cada thread est\u00e1 constantemente luchando por la secci\u00f3n cr\u00edtica y solo uno est\u00e1 haciendo progreso en cualquier momento. A medida que el n\u00famero de threads incrementa, la cantidad de threads en espera tambi\u00e9n, y el performance paga el precio. \u00bfPueden arreglar ustedes este cuello de botella?</p> <p>PISTA: Reduzcan el n\u00famero de veces que cada thread necesita utilizar la secci\u00f3n cr\u00edtica.</p> <p>Pueden hacer esto de dos maneras diferentes tambi\u00e9n</p> <ol> <li>Pueden arreglarlo sin utilizar la palabra clave de OpenMP <code>reduction</code>, y tratar de reducir la cantidad de veces que un thread debe de sumar a la variable compartida <code>global_sum</code>.</li> <li>Pueden arreglarlo utilizando la palabra clave de OpenMP <code>reduction</code> (abran Google para buscar informaci\u00f3n). Si utilizan esta opci\u00f3n, ya no deber\u00edan de tener una secci\u00f3n cr\u00edtica. Adem\u00e1s van a necesitar escribir un <code>+</code> en alguna parte utilizando esto.</li> </ol> <p>La sint\u00e1xis exacta para utilizar estas directivas puede ser un poco confusa. Aqu\u00ed va un poco de informaci\u00f3n adicional:</p> <ul> <li>Una secci\u00f3n <code>#pragma omp parallel</code> puede ser especificada utilizando llaves <code>{}</code> que rodeen el c\u00f3digo a paralelizar.</li> <li>Una secci\u00f3n <code>#pragma omp for</code> no deber\u00eda de estar acompa\u00f1ada con llaves <code>{}</code>. Solo pongan la directiva arriba del for.</li> </ul>"},{"location":"labs/lab11/#calificacion","title":"Calificaci\u00f3n","text":"<p>Al terminar, deben de subir su laboratorio al autograder con:</p> <pre><code>./submit &lt;TOKEN&gt;\n</code></pre> <p>Para este laboratorio su soluci\u00f3n ser\u00e1 evaluada en un servidor de AWS EC2 por lo que \u00fanicamente tienen permitido hacer 3 submits. Les aconsejamos probar bien su c\u00f3digo antes de enviarlo al autograder. No olviden tambi\u00e9n subir el link de su repositorio en Github al GES.</p>"},{"location":"labs/lab12/","title":"Lab 12 - MapReduce y Spark","text":""},{"location":"labs/lab12/#objetivos","title":"Objetivos","text":"<ul> <li>Obtener experiencia ejecutando MapReduce y conseguir un conocimiento m\u00e1s profundo del paradigma MapReduce.</li> <li>Familiarizarse con Apache Spark y conseguir experiencia con Spark en una instalaci\u00f3n local.</li> <li>Aprender a aplicar el paradigma MapReduce a Spark implementando ciertos algoritmos en Spark.</li> </ul>"},{"location":"labs/lab12/#preparacion","title":"Preparaci\u00f3n","text":"<p>Tienen que tener todos los archivos base, estos se encuentran aqu\u00ed. Recuerden que tienen que aprovechar el uso de Git y subir el link de su repositorio al GES, as\u00ed como al autograder, de lo contrario su nota ser\u00e1 de 0.</p> <p>Por favor revisen la secci\u00f3n de calificaci\u00f3n para conocer el l\u00edmite de submits que tienen.</p> <p>Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal (CTRL+T):</p> <pre><code>git clone &lt;link del repositorio&gt;\n</code></pre> <p>Tambi\u00e9n, tienen que instalar el entorno de Python para este laboratorio. Para hacer esto, ejecuten lo siguiente:</p> <pre><code>conda env create -f environment.yml\n</code></pre> <p>Respondan al mensaje de instalar paquetes con \"y\" (sin comillas). Despu\u00e9s de la instalaci\u00f3n, corran el siguiente comando para activar el entorno virtual:</p> <pre><code>conda activate lab12\n</code></pre> <p>Cuando hayan terminado con el laboratorio pueden desactivar el entorno con:</p> <pre><code>conda deactivate\n</code></pre>"},{"location":"labs/lab12/#introduccion","title":"Introducci\u00f3n","text":"<p>En clase los hemos expuesto a cluster computing (en particular, al framework MapReduce), como funciona y se ejecuta, pero ahora es tiempo de que ganen experiencia corriendo programas utilizando estos frameworks. En este laboratorio los vamos a introducir a Spark para que practiquen escribiendo rutinas de Map y Reduce. Este framework tiene su propia p\u00e1gina en linea, as\u00ed que son libres de probar instalarlo localmente en sus computadoras personales, de todas formas es m\u00e1s f\u00e1cil utilizar la m\u00e1quina virtual que les proporcionamos para completar este laboratorio. Aseg\u00farense de entender bien el framework de Spark, ya que lo vamos a estar utilizando en el \u00faltimo proyecto del curso.</p>"},{"location":"labs/lab12/#variables-globales","title":"Variables Globales","text":"<p>Cuando est\u00e9n utilizando Spark o un framework de cluster computing, no utilicen variables globales. Esto mata el prop\u00f3sito de tener m\u00faltiples tareas corriendo en paralelo y crea cuellos de botella cuando m\u00faltiples tareas tratan de acceder a la misma variable global. Como resultado, muchos algoritmos son implementados sin el uso de variables globales. En Spark pueden hacer uso de variables broadcast, sin embargo, no las vamos a necesitar en este laboratorio.</p>"},{"location":"labs/lab12/#como-correr-spark","title":"Como correr Spark","text":"<p>Para este laboratorio y en el proyecto les vamos a dar un archivo que les va a ayudar a correr los archivos de Spark, pero cuando ustedes utilicen Spark afuera de la clase (que deber\u00edan), van a necesitar saber como correr Spark en la l\u00ednea de comandos. Para poder correr un archivo de Spark <code>foo.py</code> (similar a como ustedes corren un programa de Python <code>foo.py</code>) solo utilicen el siguiente comando:</p> <pre><code>spark-submit foo.py # corre el archivo de spark foo.py\n</code></pre> <p>Si su archivo de Spark necesita argumentos (as\u00ed como los archivos del laboratorio), el comando va a ser similar, pero ustedes van a pasar tantos argumentos como necesiten, as\u00ed:</p> <pre><code>spark-submit foo.py arg1 arg2 # pasa los argumentos arg1 y arg2 a foo.py\n</code></pre> <p>Spark tambi\u00e9n incluye un int\u00e9rprete que corre con la versi\u00f3n de Python que tengan instalada, y los va a dejar probar cualquier comando de Spark en el int\u00e9rprete. El int\u00e9rprete tambi\u00e9n puede recibir archivos (pasen los archivos con la bandera --py-files). Si est\u00e1n buscando solo correr el int\u00e9rprete, el comando es el siguiente:</p> <pre><code>pyspark\n</code></pre> <p>Si quieren pre-cargar unos archivos (digamos a.py, b.py y c.py) pueden correr el siguiente comando:</p> <pre><code>pyspark --py-files a.py, b.py, c.py\n</code></pre>"},{"location":"labs/lab12/#tips-rapidos-de-depuracion","title":"Tips r\u00e1pidos de Depuraci\u00f3n","text":"<p>Si alguna vez se encuentran pregunt\u00e1ndose porqu\u00e9 su salida es extra\u00f1a o algo est\u00e1 mal cuando corren sus archivos de Spark, recuerden los siguientes tips:</p> <ul> <li>Aseg\u00farense de utilizar la funci\u00f3n de acci\u00f3n take. La funci\u00f3n take puede ser utilizada sobre cualquier objeto RDD (as\u00ed que pr\u00e1cticamente cualquier objeto que ustedes quieran paralelizar). Esta funci\u00f3n toma un argumento <code>N</code>, que es un entero y va a retornar los primeros <code>N</code> elementos dentro de su objeto RDD.</li> <li>Tambi\u00e9n pueden probar sus funciones (map, reduce, etc) adentro del int\u00e9rprete de Spark (pyspark, mencionado arriba). Simplemente importen la funci\u00f3n que quieren probar en pyspark (explicado arriba) y van a ser capaces de correr la funci\u00f3n y verificar que la salida es la que ustedes esperan. Aqu\u00ed hay un peque\u00f1o ejemplo de <code>wordcount.py</code>:</li> </ul> <pre><code>pyspark --py-files wordcount.py # corre el interprete de spark con el archivo wordcount.py\n&gt;&gt;&gt; from wordcount import flat_map # importa la funcion que quieren probar, flat_map, en este caso\n&gt;&gt;&gt; file = sc.sequenceFile(\"data/billOfRights.txt.seq\") # carga el archivo sequencial billOfRights.txt.seq\n&gt;&gt;&gt; file.take(5) # retorna los primeros 5 elementos del RDD file\n[(&lt;doc_name_1&gt;, &lt;text 1&gt;), (&lt;doc_name_2&gt;, &lt;text 2&gt;), ..., (&lt;doc_name_5&gt;, &lt;text 5&gt;)]\n&gt;&gt;&gt; flat_map_output = file.flatMap(flat_map) # corre la funcion importada flat_map sobre file\n&gt;&gt;&gt; flat_map_output.take(5) # retorna las primeras 5 palabras en el documento.\n['Amendment', 'I', 'Congress', 'shall', 'make']\n</code></pre>"},{"location":"labs/lab12/#documentacion-y-otros-recursos","title":"Documentaci\u00f3n y Otros Recursos","text":"<ul> <li>Una gu\u00eda r\u00e1pida de programaci\u00f3n en Spark (hagan click en la pesta\u00f1a de Python para ver el c\u00f3digo de Python) est\u00e1 disponile aqu\u00ed.</li> <li>Aqu\u00ed hay un link a la documentaci\u00f3n de la API. Para este laboratorio, no necesitan navegar mucho en ella, pero tomen un tiempo para verla cuando est\u00e9n haciendo el proyecto.</li> </ul>"},{"location":"labs/lab12/#python","title":"Python","text":"<p>Talvez algunos ya est\u00e9n familiarizados con Python ya que ha ganado popularidad en los \u00faltimos a\u00f1os (es el lenguaje m\u00e1s utilizado en universidades para cursos introductorios de programaci\u00f3n), adem\u00e1s siempre est\u00e1 en las primeras posiciones de los lenguajes de programaci\u00f3n m\u00e1s usados donde reposan los grandes como C y no hay que olvidar que es el scripting language por excelencia que utilizan compa\u00f1ias como Google, Facebook, etc. Se preguntar\u00e1n \u00bfpor qu\u00e9 aprender Python? adem\u00e1s de ser una nueva herramienta en su toolbox de conocimientos, es un lenguaje flexible, r\u00e1pido a pesar de ser interpretado y con dynamic typing (obvio no se compara con uno compilado y con static typing).</p> <p>Antes de empezar este laboratorio, asumimos que ya leyeron el tutorial de Python que se les proporciona en el siguiente link, es imperativo que lean el tutorial, en otros a\u00f1os han tratado de saltarse este paso y el resultado no es muy bueno, LEAN EL TUTORIAL.</p>"},{"location":"labs/lab12/#ejercicio-1-grafos-dirigidos-warm-up","title":"Ejercicio 1: Grafos Dirigidos (Warm-Up)","text":"<p>Este ejercicio no tiene nada que ver con MapReduce, pero les servir\u00e1 para practicar sus habilidades de Python. Tienen que implementar el m\u00e9todo <code>path</code> de la clase <code>DirectedGraph</code>, el constructor de esta clase recibe de par\u00e1metro una matriz de booleans, la cual representar\u00e1 la matriz de adyacencias de un grafo dirigido. Los estados iran del 0, hasta length - 1 de la matriz. El m\u00e9todo <code>path(self, start, end)</code> devuelve una lista de Python con el camino m\u00e1s corto desde el estado <code>start</code> al estado <code>end</code>, el resultado (los elementos de la lista) debe contener los estados por los que se deben de pasar incluyendo el estado <code>start</code> (el inicio) y <code>end</code> (el final).</p> <p>Si nuestro grafo <code>G</code> fuera el siguiente:</p> <p> </p> <p>y quisieramos el camino m\u00e1s corto del estado 2 a los dem\u00e1s estados, obtendriamos el siguiente resultado:</p> <pre><code>from state: 2\n  to state: 0 = shortest path: 2 -&gt; 0, distance: 1\n  to state: 1 = shortest path: 2 -&gt; 0 -&gt; 1, distance: 2\n  to state: 3 = shortest path: 2 -&gt; 3, distance: 1\n  to state: 4 = shortest path: 2 -&gt; 3 -&gt; 4, distance: 2\n  to state: 5 = shortest path: 2 -&gt; 3 -&gt; 5, distance: 2\n  to state: 6 = shortest path: 2 -&gt; 3 -&gt; 4 -&gt; 6, distance: 3\n  to state: 7 = shortest path: 2 -&gt; 3 -&gt; 5 -&gt; 7, distance: 3\n</code></pre> <p>Para este ejercicio les recomendamos utilizar Breadth-first search (BFS), para los que no se recuerdan aqu\u00ed hay una variante que solo toma en cuenta el arreglo de predecesores \\(\\pi\\) (\u00bfPor qu\u00e9 solo predecesores?):</p> <pre><code>BFS(G, s) {\nfor each vertex u \u2208 V[G] \u2013 {s} {\nvisited[u] = false\n\u03c0[u] = null\n}\nvisited[s] = true\n\u03c0[s] = null\nQ = [s]\nwhile (Q != \u2205 ) {\nu = Q.dequeue()\nfor each v \u2208 Adj[u] {\nif not visited[v] {\nvisited[v] = true\n\u03c0[v] = u\nQ.enqueue(v)\n}\n}\n}\nreturn \u03c0\n}\n</code></pre> <p>Pueden probar su implementaci\u00f3n utilizando el siguiente comando:</p> <pre><code>make graph\n</code></pre> <p>Esto probar\u00e1 su implementaci\u00f3n con el grafo que se muestra en la figura de arriba, de esta manera pueden saber si el resultado que obtienen es el correcto.</p>"},{"location":"labs/lab12/#ejemplo-ejecutando-un-contador-de-palabras","title":"Ejemplo: Ejecutando un contador de palabras","text":"<p>En este ejemplo vamos a ejecutar el hola mundo de MapReduce que es un contador de palabras. Pueden probarlo con:</p> <pre><code>make sparkwc-small\n</code></pre> <p>Esto ejecutar\u00e1 <code>wordcount.py</code> con <code>billOfRights.txt.seq</code>. El resultado deber\u00eda estar en <code>wc-out-wordcount-small/part-00000</code>. Una caracter\u00edstica interesante de Spark es que es un motor de c\u00f3mputo distribuido en memoria, asi que no tiene un almacenamiento de archivos predeterminado. Por ello, utilizamos el Hadoop Distributed File System (HDFS) para poder guardar el resultado. Los exhortamos a leer acerca de Hadoop por su cuenta. en general, Hadoop requiere que el directorio de salida no exista al ejecutar un programa de MapReduce, pero el <code>makefile</code> se encarga de esto, removiendo el directorio de salida anterior. Traten con el archivo m\u00e1s grande, <code>complete-works-mark-twain.txt.seq</code>:</p> <pre><code>make sparkwc-medium\n</code></pre> <p>Su salida para este comando estar en el directorio <code>spark-wc-out-wordcount-medium</code>. Busquen en el archivo alguna palabra como \"the\" para entender mejor la salida. Tomen un tiempo para ver y analizar <code>wordcount.py</code>, traten de entender lo que est\u00e1 haciendo el c\u00f3digo les va a servir para el siguiente ejercicio del laboratorio.</p>"},{"location":"labs/lab12/#ejercicio-2-document-word-count","title":"Ejercicio 2: Document Word Count","text":"<p>Abran <code>docwordcount.py</code>. Noten que tiene casi el mismo c\u00f3digo que <code>wordcount.py</code>, que acaban de probar. Modif\u00edquenlo para contar la cantidad de documentos que contienen cada palabra en lugar de la cantidad de veces que aparece una palabra en la entrada.</p> <p>Para ayudarlos a entender el c\u00f3digo, hemos agregado varios comentarios, pero si\u00e9ntanse libres de revisar las transformaciones y acciones en la p\u00e1gina de Spark para una explicaci\u00f3n m\u00e1s detallada de algunos m\u00e9todos que pueden usarse en Spark.</p> <p>En esta parte, les ser\u00e1 \u00fatil revisar los links de transformaciones y acciones de arriba, ya que hay m\u00e9todos que pueden usar para ayudarlos a ordenar una salida o remover items duplicados. Para ayudarlos a distinguir cu\u00e1ndo aparece una palabra en un documento, tal vez quieran hacer uso del <code>document_id</code> tambi\u00e9n -- esto se menciona en los comentarios de <code>flat_map()</code>.</p> <p>Finalmente, aseg\u00farense de ordenar en orden alfab\u00e9tico el resultado final. (pista: \u00bfHabr\u00e1 alguna otra transformaci\u00f3n que puedan usar?)</p> <p>Pueden probar <code>docwordcount.py</code> usando cualquiera de estos dos comandos (para los 2 datasets):</p> <pre><code>make sparkdwc-small  # Output in spark-wc-out-docwordcount-small/\n</code></pre> <p>O</p> <pre><code>make sparkdwc-medium # Output in spark-wc-out-docwordcount-medium/\n</code></pre>"},{"location":"labs/lab12/#ejercicio-3-full-text-index-creation","title":"Ejercicio 3: Full Text Index Creation","text":"<p>Abran <code>index.py</code>. Noten que el c\u00f3digo es similar a <code>docwordcount.py</code>. Modif\u00edquenlo para desplegar cada palabra y una lista de ocurrencias (identificador de documento, seguido del \u00edndice de CADA vez que la palabra est\u00e9 en ese documento). Aseg\u00farense de que los \u00edndices empiecen con cero. La salida tendr\u00eda que tener lineas que se vean como lo siguiente:</p> <pre><code>(word1  document1-id, word# word# ...)\n(word1  document2-id, word# word# ...)\n. . .\n(word2  document1-id, word# word# ...)\n(word2  document3-id, word# word# ...)\n. . .\n</code></pre> <p>Noten que hay una linea para CADA documento en el que la palabra aparezca y CADA par de palabra y documento debe tener solo UNA lista de \u00edndices. Recuerden que tambi\u00e9n necesitan desplegar el <code>document ID</code>.</p> <p>Para este ejercicio, tal vez no necesiten todas las funciones definidas. Si una funci\u00f3n no se utiliza, si\u00e9ntanse libres de remover el m\u00e9todo que la llama. Aseg\u00farense de que su resultado est\u00e9 ordenado, al igual que los otros ejercicios.</p> <p>Pueden probar su <code>index.py</code> usando cualquiera de los dos comandos (para cada dataset):</p> <pre><code>$ make index-small # Output in spark-wc-out-index-small/\n</code></pre> <p>O</p> <pre><code>$ make index-medium # Output in spark-wc-out-index-medium/\n</code></pre> <p>La salida de <code>make-index-medium</code> ser\u00e1 un archivo muy grande. Para poder ver el contenido de manera m\u00e1s sencilla, pueden usar los comandos <code>cat</code>, <code>head</code>, <code>more</code>, y <code>grep</code>:</p> <pre><code>$ head -25 OUTPUTFILE       # view the first 25 lines of output\n$ cat OUTPUTFILE | more     # scroll through output one screen at a time (use Space)\n$ cat OUTPUTFILE | grep the # output only lines containing 'the' (case-sensitive)\n</code></pre> <p>Verifiquen su salida. Abran <code>complete-works-mark-twain.txt</code> y eligan algunas palabras. Cuenten manualmente algunos \u00edndices de la palabra y aseg\u00farense de que todos aparezcan en su archivo de salida.</p>"},{"location":"labs/lab12/#calificacion","title":"Calificaci\u00f3n","text":"<p>Al terminar, deben de subir su laboratorio al autograder con:</p> <pre><code>./submit &lt;TOKEN&gt;\n</code></pre> <p>Para este laboratorio su soluci\u00f3n ser\u00e1 evaluada en un servidor de AWS EC2 por lo que \u00fanicamente tienen permitido hacer 3 submits. Les aconsejamos probar bien su c\u00f3digo antes de enviarlo al autograder. No olviden tambi\u00e9n subir el link de su repositorio en Github al GES.</p>"},{"location":"projects/pj01/","title":"Proyecto 1: C y RISC-V","text":""},{"location":"projects/pj01/#objetivos","title":"Objetivos","text":"<ul> <li>Mejorar sus habilidades de programaci\u00f3n en C.</li> <li>Conocer algunos de los detalles de RISC-V.</li> <li>Prepararse para lo que viene m\u00e1s adelante en el curso.</li> </ul>"},{"location":"projects/pj01/#requisitos-de-conocimiento","title":"Requisitos de Conocimiento","text":"<p>Para realizar este proyecto ustedes tienen que tener claros algunos conceptos, de lo contrario ser\u00e1 bastante dif\u00edcil e inc\u00f3modo empezar a trabajar. Les recomendamos que antes de empezar est\u00e9n totalmente seguros que dominan al 100% los siguientes puntos:</p> <ul> <li>Operaciones binarias en C (<code>xor</code>, <code>or</code>, <code>and</code>, etc).</li> <li>Operaciones aritm\u00e9ticas con signo y sin signo en C.</li> <li>Type casting en C.</li> <li>Control de flujo en C (<code>switch</code>, <code>if</code>, etc).</li> <li>Funciones en C.</li> <li>Entender qu\u00e9 son las estructuras (<code>struct</code>) en C.</li> <li>Entender c\u00f3mo funcionan las uniones (<code>union</code>) en C.</li> <li>Uso correcto de <code>printf</code>.</li> <li>Entender la estructura del set de instrucciones de RISC-V.</li> <li>Programar en lenguaje ensamblador RISC-V.</li> </ul> <p>Si creen que no tienen claro alguno de estos temas al 100%, por favor no duden en ir a consultar los libros y material correspondiente del curso, por ejemplo K&amp;R, es indispensable. En Lecturas Recomendadas pueden encontrar algunas lecturas que tocan los puntos antes mencionados y otras cosas que tambi\u00e9n les pueden servir, nunca est\u00e1 dem\u00e1s tener un poco m\u00e1s de informaci\u00f3n.</p>"},{"location":"projects/pj01/#lecturas-recomendadas","title":"Lecturas Recomendadas","text":"<ul> <li>Gu\u00eda Pr\u00e1ctica de RISC-V: 2</li> <li>K&amp;R: 6</li> <li>P&amp;H: B-43</li> </ul>"},{"location":"projects/pj01/#introduccion","title":"Introducci\u00f3n","text":"<p>En este proyecto ustedes deben de crear un emulador que pueda ejecutar un subconjunto de instrucciones de RISC-V. Ustedes se van a encargar de hacer un programa que decodifique y ejecute varias instrucciones de RISC-V. Consid\u00e9renlo como una versi\u00f3n miniatura de Jupiter.</p>"},{"location":"projects/pj01/#risc-v-green-card","title":"RISC-V Green Card","text":"<p>Aqu\u00ed hay dos RISC-V Green Cards que pueden consultar y as\u00ed tener m\u00e1s herramientras que les pueden ayudar a completar el proyecto. La primera tiene informaci\u00f3n acerca de los opcodes y otros campos de cada uno de los diferentes formatos de instrucci\u00f3n, por lo que esta ser\u00eda su mejor opci\u00f3n.</p> <p> </p>"},{"location":"projects/pj01/#preparacion","title":"Preparaci\u00f3n","text":"<p>Antes de comenzar aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin. Si tienen alguna pregunta pueden consultar la secci\u00f3n de preguntas frecuentes para ver si ya ha sido resuelta, de lo contrario por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes.</p> <p>Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed. Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que represente al grupo y que no est\u00e9 ya en los grupos existentes.</p> <p></p> <p>Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join</p> <p></p> <p>Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que al hacer esto pueden tener acceso al repositorio del otro miembro del grupo.</p> <p>Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal (CTRL + T):</p> <pre><code>git clone &lt;link del repositorio&gt;\n</code></pre> <p>NOTA: Tienen que reemplazar &lt;link del repositorio&gt; con el link del repositorio que se cre\u00f3.</p>"},{"location":"projects/pj01/#estructura-del-proyecto","title":"Estructura del Proyecto","text":"<p>Cuando hayan clonado el repositorio, se van a encontrar con los siguientes archivos:</p> <pre><code>Makefile\npart1.c\npart2.c\nREADME.md\nriscv.c\nriscvcode/\nriscv.h\nautograder.json\ntypes.h\nutils.c\nutils.h\n</code></pre> <p>Los \u00fanicos archivos que pueden modificar son:</p> <ul> <li><code>part1.c</code>: Este es el archivo que van a modificar en la parte 1 del proyecto.</li> <li><code>utils.c</code>: Archivo auxiliar que contendr\u00e1 varias funciones de ayuda para la parte 1 y 2 del proyecto.</li> <li><code>part2.c</code>: Este es el archivo que van a modificar en la parte 2 del proyecto.</li> </ul> <p>Ustedes NO pueden crear otros archivos ni crear archivos de cabecera <code>.h</code>. Si necesitan agregar funciones de ayuda, por favor col\u00f3quenlas en los archivos C correspondientes (<code>utils.c</code>, <code>part1.c</code>, <code>part2.c</code>). Si ustedes no siguen estas instrucciones, obtendr\u00e1n 0 como nota aunque su proyecto corra perfectamente.</p> <p>Otros archivos que necesitan consultar detenidamente para entender el proyecto:</p> <ul> <li><code>type.h</code>: Archivo de cabecera que tiene los tipos de datos que ustedes van a utilizar.</li> <li><code>Makefile</code>: Para compilar y probar su c\u00f3digo.</li> <li><code>riscvcode/*</code>: Archivos para hacer algunas pruebas.</li> <li><code>utils.h</code>: Archivo que contiene el formato de las instrucciones a ser utilizadas en la parte 1 del proyecto.</li> </ul> <p>Archivos que no es necesario que los revisen, pero si son curiosos:</p> <ul> <li><code>riscv.h</code>: tiene declaraciones de funciones que se utilizan en la parte 1 y 2 del proyecto.</li> <li><code>riscv.c</code>: programa encargado de probar la parte 1 y 2 del proyecto, el simulador como tal.</li> </ul>"},{"location":"projects/pj01/#el-emulador-de-risc-v","title":"El emulador de RISC-V","text":"<p>Los archivos proporcionados en el repositorio que crearon con GitHub Classroom son la base para un emulador de RISC-V. Primero, ustedes deber\u00e1n agregar c\u00f3digo en part1.c y utils.c para imprimir las instrucciones en ensamblador correspondientes al c\u00f3digo de m\u00e1quina (binario). Una vez realizaron esto, ustedes completar\u00e1n el programa agregando c\u00f3digo en el archivo parte2.c para ejecutar cada instrucci\u00f3n (incluyendo los accesos a memoria). Su simulador debe de ser capaz de entender cada una de las instrucciones siguientes ya codificadas en c\u00f3digo de m\u00e1quina (binario), nosotros ya les damos una tabla de los tipos de instrucciones que debe de ser capaz de manejar su emulador.</p> <p>Es muy IMPORTANTE que ustedes lean y entiendan las definiciones encontradas en types.h antes de empezar su proyecto. Si tiene alguna duda, o encuentran algo que no entiendan respecto a las mismas consulten el cap\u00edtulo 6 de K&amp;R, que habla sobre estructuras, bitfields y uniones.</p>"},{"location":"projects/pj01/#set-de-instrucciones","title":"Set de Instrucciones","text":"<p>El set de instrucciones que su emulador debe soportar esta listado a continuaci\u00f3n. Toda la informaci\u00f3n ac\u00e1 es copiada desde RISC-V green card, como ayuda adicional pueden utilizar la hoja proporcionada anteriormente.</p>"},{"location":"projects/pj01/#tipo-r","title":"Tipo R","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO R  R-TYPE funct7 rs2 rs1 funct3 rd opcode Bits 7 5 5 3 5 7  INTRUCCIONES TIPO R (OPCODE 0x33)  INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N  add rd,  rs1,  rs2 0x0 0x00 R[rd]&lt;-R[rs1] + R[rs2]  mul rd,  rs1,  rs2 0x0 0x01 R[rd]&lt;-(R[rs1] * R[rs2]) [31:0]  sub rd,  rs1,  rs2 0x0 0x20 R[rd]&lt;-R[rs1] - R[rs2]  sll rd,  rs1,  rs2 0x1 0x00 R[rd]&lt;-R[rs1] &lt;&lt; R[rs2]  mulh rd,  rs1,  rs2 0x1 0x01 R[rd]&lt;-(R[rs1] * R[rs2]) [63:32]  slt rd,  rs1,  rs2 0x2 0x00 R[rd]&lt;-(R[rs1] &lt; R[rs2]) ? 1 : 0  xor rd,  rs1,  rs2 0x4 0x00 R[rd]&lt;-R[rs1] ^ R[rs2]  div rd,  rs1,  rs2 0x4 0x01 R[rd]&lt;-R[rs1] / R[rs2]  srl rd,  rs1,  rs2 0x5 0x00 R[rd]&lt;-R[rs1] &gt;&gt; R[rs2]  sra rd,  rs1,  rs2 0x5 0x20 R[rd]&lt;-R[rs1] &gt;&gt; R[rs2]  or rd,  rs1,  rs2 0x6 0x00 R[rd]&lt;-R[rs1] | R[rs2]  rem rd,  rs1,  rs2 0x6 0x01 R[rd]&lt;-R[rs1] % R[rs2]  and rd,  rs1,  rs2 0x7 0x00 R[rd]&lt;-R[rs1] &amp; R[rs2]"},{"location":"projects/pj01/#tipo-i","title":"Tipo I","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO I  I-TYPE imm[11:0] rs1 funct3 rd opcode Bits 12 5 3 5 7  INTRUCCIONES TIPO I (OPCODE 0x03)  INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N  lb rd, offset(rs1) 0x0 R[rd]&lt;- SignExt(Mem(R[rs1] +  offset, byte))   lh rd, offset(rs1) 0x1 R[rd]&lt;- SignExt(Mem(R[rs1] +  offset, half))   lw rd, offset(rs1) 0x2 R[rd]&lt;- Mem(R[rs1] +  offset, word)   INTRUCCIONES TIPO I (OPCODE 0x13)  INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N  addi rd, rs1, imm 0x0 R[rd]&lt;- R[rs1] +  imm  slli rd, rs1, imm 0x1 0x00 R[rd]&lt;- R[rs1] &lt;&lt;  imm  slti rd, rs1, imm 0x2 R[rd]&lt;- (R[rs1] &lt;  imm) ? 1 : 0  xori rd, rs1, imm 0x4 R[rd]&lt;- R[rs1] ^  imm  srli rd, rs1, imm 0x5 0x00 R[rd]&lt;- R[rs1] &gt;&gt;  imm  srai rd, rs1, imm 0x5 0x20 R[rd]&lt;- R[rs1] &gt;&gt;  imm  ori rd, rs1, imm 0x6 R[rd]&lt;- R[rs1] |  imm  andi rd, rs1, imm 0x7 R[rd]&lt;- R[rs1] &amp;  imm  INTRUCCIONES TIPO I (OPCODE 0x67)  INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N  jalr 0x0 R[rd]&lt;- PC + 4 PC&lt;- R[rs1] + imm  INTRUCCIONES TIPO I (OPCODE 0x73)  INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N  ecall 0x0 0x000 (Transfiere el control al Sistema Operativo) a0 = 1 imprime el valor contenido en a1 como entero. a0 =  10  es exit o un indicador de final de c\u00f3digo."},{"location":"projects/pj01/#tipo-s","title":"Tipo S","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO S  S-TYPE imm[11:5] rs2 rs1 funct3 imm[4:0] opcode Bits 7 5 5 3 5 7  INTRUCCIONES TIPO S (OPCODE 0x23)  INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N sb rs2, offset(rs1) 0x0 Mem(R[rs1] + offset)&lt;- R[rs2][7:0] sh rs2, offset(rs1) 0x1 Mem(R[rs1] + offset)&lt;- R[rs2][15:0] sw rs2, offset(rs1) 0x2 Mem(R[rs1] + offset)&lt;- R[rs2]"},{"location":"projects/pj01/#tipo-sb","title":"Tipo SB","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO SB  SB-TYPE imm[12] imm[10:5] rs2 rs1 funct3 imm[4:1] imm[11] opcode Bits 1 6 5 5 3 4 1 7  INTRUCCIONES TIPO SB (OPCODE 0x63)  INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N beq rs1, rs2, offset 0x0 if(R[rs1] == R[rs2])  PC&lt;- PC + {offset, 1b'0} bne rs1, rs2, offset 0x1 if(R[rs1] != R[rs2])  PC&lt;- PC + {offset, 1b'0}"},{"location":"projects/pj01/#tipo-u","title":"Tipo U","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO U  U-TYPE imm[31:12] rd opcode Bits 20 5 7  INTRUCCIONES TIPO U (OPCODE 0x17)  INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N auipc rd, offset R[rd]&lt;- PC + {offset, 12b'0}     INTRUCCIONES TIPO U (OPCODE 0x37)  INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lui rd, offset R[rd]&lt;- {offset, 12b'0}"},{"location":"projects/pj01/#tipo-uj","title":"Tipo UJ","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO UJ  UJ-TYPE imm[20] imm[10:1] imm[11] imm[19:12] rd opcode Bits 1 10 1 8 5 7  INTRUCCIONES TIPO UJ (OPCODE 0x6F)  INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jal rd, imm R[rd]&lt;- PC + 4 PC&lt;- PC + {imm, 1b'0} <p>Al igual que la arquitectura RISC-V normal, el sistema RISC-V que est\u00e1n implementando es little-endian. Esto significa que cuando se le da un valor compuesto de m\u00faltiples bytes, el byte menos significativo se almacena en la direcci\u00f3n m\u00e1s baja. Consulten la p\u00e1gina B-43 de P&amp;H (4\u00aa edici\u00f3n) para obtener informaci\u00f3n sobre endianness.</p>"},{"location":"projects/pj01/#estructura-del-codigo","title":"Estructura del C\u00f3digo","text":"<p>El c\u00f3digo base que les fue proporcionado funciona de la siguiente manera:</p> <ol> <li>Lee los programas en c\u00f3digo de m\u00e1quina que se encuentran en la memoria (Empezando en la direcci\u00f3n <code>0x01000</code>). Para \"ejecutar\" el programa este es pasado como un par\u00e1metro en la l\u00ednea de comandos. Cada programa tiene 1 MiB de memoria y la unidad m\u00ednima de direccionamiento son los bytes.</li> <li>Todos los registros de RISC-V son inicializados en 0 y el program counter (<code>pc</code>) hacia la direcci\u00f3n <code>0x01000</code>. Las \u00fanicas excepciones a las inicializaciones antes mencionadas son el stack pointer (<code>sp</code>) que tiene un valor inicial de <code>0xEFFFF</code> y el global pointer (<code>gp</code>) que tiene un valor inicial de <code>0x03000</code>. En el contexto de su emulador, el global pointer hace referencia a la secci\u00f3n est\u00e1tica de su memoria. Los registros y el program counter est\u00e1n definidos en el Processor struct definido en types.h.</li> <li>Se definieron banderas con las cuales puede manejar la interacci\u00f3n con el usuario. Dependiendo de la opci\u00f3n especificada en la l\u00ednea de comandos, el simulador mostrar\u00e1 un dissassembly dump (<code>-d</code>) o se ejecutar\u00e1 el programa. Habr\u00e1 m\u00e1s informaci\u00f3n sobre las opciones de l\u00ednea de comandos m\u00e1s adelante.</li> </ol> <p>Lo que prosigue es qu\u00e9 entra al flujo de simulaci\u00f3n principal, el cual ejecuta una \u00fanica instrucci\u00f3n repetitivamente hasta que la simulaci\u00f3n se completa. La ejecuci\u00f3n de una instrucci\u00f3n realiza las siguientes tareas:</p> <ol> <li>Trae una instrucci\u00f3n desde la memoria, usando el <code>pc</code> como direcci\u00f3n (fetch).</li> <li>Examina el opcode/funct3 para determinar que instrucci\u00f3n es (decode).</li> <li>Ejecuta la instrucci\u00f3n y actualiza el <code>pc</code> (execute).</li> </ol>"},{"location":"projects/pj01/#opciones-en-la-linea-de-comandos","title":"Opciones en la l\u00ednea de comandos","text":"<ul> <li><code>-i</code>: Corre el simulador en modo interactivo (interactive), es decir que se ejecutar\u00e1 una instrucci\u00f3n a la vez al presionar enter. Cada instrucci\u00f3n es mostrada en su forma desensamblada.</li> <li><code>-t</code>: Corre el simulador en modo rastreo (trace), en donde cada instrucci\u00f3n es ejecutada y es mostrada al usuario.</li> <li><code>-r</code>: Indica al simulador que imprima el contenido de los 32 registros despu\u00e9s de que es ejecutada cada instrucci\u00f3n. Esta opci\u00f3n es m\u00e1s \u00fatil cuando se combina con la opci\u00f3n <code>-i</code>.</li> <li><code>-d</code>: Indica al simulador que desensamble el programa completo y que termine sin ejecutarlo.</li> </ul> <p>En la parte 2, ustedes deber\u00e1n implementar los siguientes m\u00e9todos:</p> <ul> <li>El execute_instruction().</li> <li>Los diferentes executes.</li> <li>El store().</li> <li>El load().</li> </ul> <p>Para cuando ustedes hayan terminado la implementaci\u00f3n de todos los m\u00e9todos, el simulador ser\u00e1 capaz de manejar todas las instrucciones de la tabla anterior.</p>"},{"location":"projects/pj01/#parte-1","title":"Parte 1","text":"<p>Su primera tarea es implementar un desensamblador al completar el m\u00e9todo decode_instruction() en el archivo part1.c junto a otras funciones.</p> <p>El objetivo de esta parte, es que, dada una instrucci\u00f3n en c\u00f3digo de m\u00e1quina, ustedes deber\u00e1n traducirla a su instrucci\u00f3n en lenguaje ensamblador RISC-V (e.g. <code>add x1, x2, x3</code> ). Para esta parte, ustedes no har\u00e1n referencia a los registros por nombre sino por su n\u00famero (como est\u00e1 definido en RISC-V Green Card). Cuando impriman las instrucciones revisen las constantes definidas en utils.h, ya que estas le pueden ser de ayuda. M\u00e1s detalles sobre los requisitos a continuaci\u00f3n.</p>"},{"location":"projects/pj01/#requisitos-parte-1","title":"Requisitos Parte 1","text":"<ol> <li>Imprimir el nombre de la instrucci\u00f3n. Si la instrucci\u00f3n tiene argumentos, impriman un tab (<code>\\t</code>).</li> <li>Imprimir todos los argumentos, siguiendo el orden y formato dado en la columna de INSTRUCCI\u00d3N de las tablas mostradas anteriormente.</li> <li>Los argumentos son generalmente separados por coma (<code>lw</code>/<code>sw</code>, usan tambi\u00e9n par\u00e9ntesis), pero no est\u00e1n separados por espacios.</li> <li>Ustedes encontrar\u00e1n de ayuda revisar el archivo utils.h.</li> <li>Los registros que son argumentos de la instrucci\u00f3n son impresos con una <code>x</code> seguido del n\u00famero de registro, en decimal. (e.g. <code>x0</code> o <code>x31</code>)</li> <li>Todos los inmediatos deben mostrarse como un n\u00famero decimal con signo.</li> <li>Los corrimientos (e.g. para <code>slli</code>) se imprimen como n\u00fameros decimales sin signo (e.g. 0 a 31).</li> <li>Imprimir un salto de l\u00ednea (<code>\\n</code>) al final de cada instrucci\u00f3n.</li> <li>Se estar\u00e1 utilizando un autograder para calificar esta tarea. Si su output difiere del nuestro debido a errores de formato, no obtendr\u00e1n nota.</li> <li>Nosotros les proveemos ciertas pruebas. Sin embargo, dado que estas pruebas s\u00f3lo cubren un subconjunto de todos los escenarios posibles, pasar estas pruebas no significa que su c\u00f3digo est\u00e9 libre de errores. Ustedes deber\u00e1n identificar todos los casos y probarlos.</li> </ol> <p>Para completar la funcionalidad de la parte 1, deben de completar lo siguiente:</p> <ul> <li>La funci\u00f3n decode_instrucction() en part1.c.</li> <li>Los diferentes writes en part1.c.</li> <li>Los diferentes prints en part1.c.</li> <li>Los diferentes gets en utils.c.</li> <li>La funci\u00f3n bitSigner en utils.c.</li> </ul> <p>Ustedes deben de correr el test brindado para su proyecto escribiendo el siguiente comando. Si ustedes pasan el test, ver\u00e1n en su consola el siguiente output.</p> <pre><code>make part1\ngcc -g -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c\nsimple_disasm TEST PASSED!\nmultiply_disasm TEST PASSED!\nrandom_disasm TEST PASSED!\n---------Disassembly Tests Complete---------\n</code></pre>"},{"location":"projects/pj01/#probando-la-parte-1","title":"Probando la Parte 1","text":"<p>Los tests que se les dieron no eval\u00faan todas las posibilidades, por eso mismo ustedes pueden (deben) crear sus propios archivos de prueba para comprobar su funcionamiento. Si ustedes desean correr un test en espec\u00edfico, pueden usar el siguiente comando para ello:</p> <pre><code>make [test_name]_disasm\n</code></pre> <p>Para crear sus propios archivos de prueba, primero necesitar\u00e1n crear c\u00f3digo de m\u00e1quina. Para ello pueden ayudarse de V-Sim o hacerlo a mano. Si utilizan V-Sim tienen que crear un archivo <code>.s</code> y hacer un <code>dump</code> del c\u00f3digo de m\u00e1quina utilizando la bandera <code>-code</code> en la terminal:</p> <pre><code>jupiter &lt;archivo&gt;.s --dump-code &lt;test_name&gt;.input\n</code></pre> <p>Recuerde que Jupiter requiere el .global start y la etiqueta start: para poder ensamblar. Luego que hizo el --dump-code entre al archivo generado y elimine las primeras dos l\u00edneas, estas corresponden al __start y su proyecto no necesita preocuparse de esto.</p> <p>Ustedes deben de poner las instrucciones en c\u00f3digo de m\u00e1quina en un archivo llamado <code>[test_name].input</code> y colocar el archivo dentro de la carpeta <code>riscvcode/code</code>. Despu\u00e9s, deben crear el archivo <code>[test_name].solution</code> el cual contendr\u00e1 las instrucciones que se espera obtener; y colocar el archivo en la carpeta <code>riscvcode/ref</code>. Vean las pruebas proporcionadas como ejemplos de este tipo de archivos. Para integrar sus pruebas en el comando <code>make</code>, ustedes deben de modificar el archivo <code>Makefile</code>. En la l\u00ednea 4 del archivo <code>Makefile</code>, donde dice <code>ASM_TESTS</code>, agregar <code>[test_name]</code> a la lista con espacios entre cada nombre de archivo:</p> <pre><code>SOURCES := utils.c part1.c part2.c riscv.c\nHEADERS := types.h utils.h riscv.h\n\nASM_TESTS := simple multiply random test_name\n</code></pre> <p>Si su instrucci\u00f3n desensamblada no es igual a la esperada, ustedes obtendr\u00e1n la diferencia entre el output esperado y el output que devolvieron. Aseg\u00farense de al menos pasar esta prueba antes de seguir avanzando.</p> <pre><code># Output Esperado\n&lt; 00001014: lui x8, 1048575\n---\n# Output Devuelto\n&gt; 00001014: Invalid Instruction: 0xfffff437\n</code></pre>"},{"location":"projects/pj01/#calificacion-parte-1","title":"Calificaci\u00f3n Parte 1","text":"<p>Recuerden que para la primera parte, s\u00f3lo deben modificar los archivos part1.c y utils.c, esto representa el 50% de su nota. Pueden enviar subir sus archivos a GitHub haciendo <code>commit</code> y luego <code>push</code>.</p>"},{"location":"projects/pj01/#parte-2","title":"Parte 2","text":"<p>Su segunda tarea es completar el emulador implementando los m\u00e9todos execute_instruction(). execute()'s, store() y load() del archivo part2.c.</p>"},{"location":"projects/pj01/#requisitos","title":"Requisitos","text":"<p>Esta parte consistir\u00e1 en implementar la funcionalidad de cada instrucci\u00f3n. Por favor implementen las funciones descritas a continuaci\u00f3n (todas en part2.c):</p> <ul> <li> <p>execute_instruction(): Ejecuta la instrucci\u00f3n proporcionada como par\u00e1metro. Esta deber\u00eda modificar los registros apropiados, realizar las llamadas a memoria necesarias y actualizar el program counter para apuntar a la siguiente instrucci\u00f3n a ejecutar.</p> </li> <li> <p>execute()'s: Varias funciones de ayuda para ser llamadas en ciertas condiciones para ciertas instrucciones. Es su decisi\u00f3n usar estas funciones, pero estas les ayudar\u00e1n de gran manera a organizar el c\u00f3digo.</p> </li> <li> <p>store(): Toma una direcci\u00f3n, un tama\u00f1o, un valor y almacena los primeros (tama\u00f1o) bytes del valor dado en la direcci\u00f3n dada. Cuando el par\u00e1metro <code>check_align</code> sea <code>1</code> se validar\u00e1n las restricciones de alineaci\u00f3n. Se incluy\u00f3 este par\u00e1metro para obligar a las instrucciones a estar alineadas por palabras de memoria (word-aligned). Cuando implementen el <code>store</code> y <code>load</code>, este par\u00e1metro debe ser <code>0</code> dado que RISC-V no hace cumplir las restricciones de alineaci\u00f3n.</p> </li> <li> <p>load(): Toma una direcci\u00f3n y un tama\u00f1o, y retorna los siguientes (tama\u00f1o) bytes empezando en la direcci\u00f3n dada. El <code>check_align</code> funciona de la misma forma que en <code>store()</code>.</p> </li> </ul>"},{"location":"projects/pj01/#probando-la-parte-2","title":"Probando la Parte 2","text":"<p>Les hemos adjuntado un self-checking assembly test que prueba varias de las instruciones, sin embargo este test no es exhaustivo y no prueba todas las instrucciones. A continuaci\u00f3n, se ejemplifica c\u00f3mo ejecutar los test (el output es de una soluci\u00f3n correcta).</p> <pre><code>make part2\ngcc -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c\nsimple_execute TEST PASSED!\nmultiply_execute TEST PASSED!\nrandom_execute TEST PASSED!\n-----------Execute Tests Complete-----------\n</code></pre> <p>Lo m\u00e1s probable es que ustedes tenga errores al empezar a realizar la parte 2, entonces prueben el modo de rastreo (trace) descrito en Opciones en la l\u00ednea de Comandos.</p> <p>Les hemos dado unos cuantos tests m\u00e1s, adem\u00e1s de la posibilidad de escribir test propios. Como en la parte 1, ustedes tendr\u00e1n que crear archivos <code>.input</code>. Sin embargo, para la parte 2, ustedes deber\u00e1n nombrar su archivo soluci\u00f3n con una extensi\u00f3n <code>.trace</code>.</p> <p>Creen el nuevo archivo de ensamblador en el directorio <code>riscvcode</code> (utilicen <code>riscvcode/simple.input</code> como plantilla). Agreguen el nombre base del test a la lista de <code>ASM_TESTS</code> en el <code>Makefile</code>. Para realizar esto s\u00f3lo agreguen <code>[test_name]</code> al final de la l\u00ednea 4. Ahora compilen su test de ensamblador y ejec\u00fatenlo escribiendo el siguiente comando:</p> <pre><code>make [test_name]_execute\n</code></pre> <p>Ustedes pueden, y en efecto deben, escribir sus propios test para probar instrucciones espec\u00edficas y todos los posibles casos. Adem\u00e1s, ustedes deben compilar y probar su c\u00f3digo despu\u00e9s de cada grupo de instrucciones implementadas. De lo contrario ser\u00e1 muy dif\u00edcil probar su proyecto si esperan hasta el final.</p>"},{"location":"projects/pj01/#calificacion-parte-2","title":"Calificaci\u00f3n Parte 2","text":"<p>Al completar esta parte ustedes s\u00f3lo deber\u00edan haber modificado los archivos <code>part1.c</code>, <code>part2.c</code> y <code>utils.c</code>, deben realizar <code>commit</code> de todos los cambios realizados, luego <code>push</code> para que quede almacenado en GitHub y enviar el link de su repositorio por medio del GES para obtener su nota completa</p> <p>Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tiene que enviar el link del repositorio al GES.</p>"},{"location":"projects/pj01/#preguntas-frecuentes","title":"Preguntas Frecuentes","text":""},{"location":"projects/pj01/#1-como-puedo-empezar","title":"1. \u00bfC\u00f3mo puedo empezar?","text":"<p>Lo mejor es revisar <code>types.h</code> y analizar la estructura <code>Instruction</code> para empezar a trabajar en la <code>parte1.c</code>, por ejemplo como acceder a cada campo de cada diferente tipo de instrucci\u00f3n y al opcode tambi\u00e9n. Por ejemplo, para acceder al <code>opcode</code> pueden utilizar:</p> <pre><code>instruction.opcode\n</code></pre> <p>siendo <code>instruction</code> una variable que representa una \"instancia\" de la estructura <code>Instruction</code>. Luego de esto, pueden ver c\u00f3mo accediendo a estos campos pueden decodificar la instrucci\u00f3n y as\u00ed lograr imprimirla.</p>"},{"location":"projects/pj01/#2-en-mi-maquina-local-saco-100-y-en-el-autograder-0-por-que","title":"2. En mi m\u00e1quina local saco 100% y en el autograder 0, \u00bfpor qu\u00e9?","text":"<p>Al trabajar con uniones y estructuras de C y al utilizar la bandera <code>-O2</code> pueden pasar cosas muy raras, una de ellas es el strict aliasing, por eso les recomendamos probar su c\u00f3digo en la m\u00e1quina virtual que les proporcionamos, as\u00ed est\u00e1n totalmente seguros de que c\u00f3digo funciona correctamente.</p>"},{"location":"projects/pj01/#3-me-da-floating-point-exception-core-dumped-al-hacer-algunas-operaciones-aritmeticas-por-que","title":"3. Me da Floating-point Exception (core dumped) al hacer algunas operaciones aritm\u00e9ticas, \u00bfpor qu\u00e9?","text":"<p>Generalmente esto se da porque se divide por <code>0</code> o hay <code>overflow</code> utilizando variables enteras con signo. Por ejemplo:</p> <p>Division por 0</p> <pre><code>int x = 10;\nint y = 0;\nint z = x / y;\n</code></pre> <p>Overflow</p> <pre><code>int32_t x = 0x80000000;\nint32_t y = 0xffffffff;\nint32_t z = x / y;\n</code></pre> <p>La soluci\u00f3n para la divisi\u00f3n por <code>0</code> es simplemente tienen que devolver <code>-1</code> como dice la especificaci\u00f3n de RISC-V y para el residuo devolver el primer argumento de la operaci\u00f3n, en el caso de <code>overflow</code> la soluci\u00f3n es castear las variables a un tipo con m\u00e1s bytes:</p> <pre><code>int32_t z = (int32_t)((int64_t)x / (int64_t)y);\n</code></pre>"},{"location":"projects/pj01/#4-en-la-parte-1-el-formato-nunca-es-el-esperado-por-las-pruebas-por-que","title":"4. En la parte 1 el formato nunca es el esperado por las pruebas, \u00bfpor qu\u00e9?","text":"<p>Seguramente no est\u00e1n utilizando el formato correcto, les recomendamos que utilicen las siguientes <code>macros</code> para imprimir las instrucciones que se encuentran en el archivo <code>utils.h</code>:</p> <pre><code>#define RTYPE_FORMAT \"%s\\tx%d, x%d, x%d\\n\"\n#define ITYPE_FORMAT \"%s\\tx%d, x%d, %d\\n\"\n#define JALR_FORMAT \"jalr\\tx%d, x%d, %d\\n\"\n#define MEM_FORMAT \"%s\\tx%d, %d(x%d)\\n\"\n#define AUIPC_FORMAT \"auipc\\tx%d, %d\\n\"\n#define LUI_FORMAT \"lui\\tx%d, %d\\n\"\n#define JAL_FORMAT \"jal\\tx%d, %d\\n\"\n#define BRANCH_FORMAT \"%s\\tx%d, x%d, %d\\n\"\n#define ECALL_FORMAT \"ecall\\n\"\n</code></pre>"},{"location":"projects/pj01/#5-puedo-crear-mis-propias-funciones","title":"5. \u00bfPuedo crear mis propias funciones?","text":"<p>S\u00ed, siempre y cuando estas est\u00e9n declaradas, ya sea en <code>part1.c</code>, <code>part2.c</code> o <code>utils.c</code>, ya que son los \u00fanicos archivos que se env\u00edan al autograder. Sin embargo, NO est\u00e1 permitido renombrar o eliminar las siguientes funciones:</p> <pre><code>/* archivo part1.c */\nvoid decode_instruction(Instruction i);\n\n/* archivo part2.c */\nvoid execute_instruction(Instruction instruction, Processor* processor, Byte *memory);\nvoid store(Byte *memory, Address address, Alignment alignment, Word value, int);\nWord load(Byte *memory, Address address, Alignment alignment, int);\n</code></pre> <p>Ya que el simulador <code>riscv.c</code> espera que estas est\u00e9n definidas.</p>"},{"location":"projects/pj02/","title":"Proyecto 2: CPU","text":""},{"location":"projects/pj02/#introduccion","title":"Introducci\u00f3n","text":"<p>En este proyecto utilizaremos Logisim para implementar un procesador de 32-bits, cuyo ISA es un subset de las instrucciones de RISC-V. Algunos componentes del proyecto ser\u00e1n m\u00e1s sencillos que los componentes de hardware verdaderos para evitar realizar trabajo repetitivo. Nuestro ISA utiliza 32 registros de 32 bits cada uno y una memoria, cuyas direcciones son de 32 bits.</p> <p></p> <p>A continuaci\u00f3n, algunos detalles importantes que debemos leer antes de iniciar.</p> <ul> <li>Pueden utilizar cualquier bloque ya existente en Logisim para el proyecto.</li> <li>Guarden constantemente. Realicen commits y hagan push al menos una vez por cada d\u00eda que trabajen.</li> <li>Logisim es un excelente simulador pero ocasionalmente tiene errores, entonces hagamos caso a la indicaci\u00f3n anterior. Guarden constantemente...</li> <li>Trabajemos de la misma forma que en un proyecto de software: Construyamos el proyecto pieza por pieza y realicemos pruebas antes de unir un bloque con otros. Podemos construir todos los subcircuitos adicionales que necesitemos, siempre y cuando sigamos las reglas espec\u00edficas que cada parte impone (m\u00e1s de esto a continuaci\u00f3n).</li> <li>Se incluyen algunos tests. S\u00f3lo se debe correr el script ./check (esto seguramente tendr\u00e1n que hacerlo en Linux, se requiere Python 3.X instalado).</li> <li>\u00a1Necesitaremos m\u00e1s tests! Cada equipo deber\u00eda hacer sus propios tests adicionales. En la secci\u00f3n de Testing hay algunas indicaciones de c\u00f3mo hacer pruebas adicionales.</li> </ul> <p>Finalmente, las dos indicaciones m\u00e1s importantes:</p> <ul> <li>Se les dar\u00e1n algunos armazones (harnesses) a los cuales sus circuitos se conectar\u00e1n. ASEGURENSE QUE S\u00cd SE ADAPTAN DE FORMA CORRECTA, TODOS LOS TESTS FALLAR\u00c1N SI NO LO HACEN.</li> <li>En el camino nos hemos encontrado con algunos problemas de git merge si ambos miembros del equipo estaban trabajando en el mismo archivo; a veces git los resolv\u00eda autom\u00e1ticamente y a veces no. En Logisim es garantizado que git NO RESOLVER\u00c1 ESTO DE FORMA CORRECTA, entonces si trabajamos en equipo NO DEBEMOS MODIFICAR EL MISMO ARCHIVO AL MISMO TIEMPO</li> </ul>"},{"location":"projects/pj02/#preparacion","title":"Preparaci\u00f3n","text":"<p>Antes de comenzar, aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin. Si tienen alguna pregunta, por favor dir\u00edjanse a Telergam y pregunten.</p> <p>Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed. Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que represente lo represente y que no haya sido tomado por otro.</p> <p></p> <p>Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join</p> <p></p> <p>Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s, lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que, al hacer esto, pueden tener acceso al repositorio del otro miembro del grupo.</p> <p>Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal (CTRL + T):</p> <pre><code>git clone &lt;link del repositorio&gt;\n</code></pre>"},{"location":"projects/pj02/#parte-1-register-file","title":"Parte 1: Register File","text":"<p>Como aprendimos en clase, RISC-V tiene 32 registros. En el proyecto s\u00f3lo implementaremos 9 (abajo se indica cuales) para evitar realizar trabajo repetitivo. Todas nuestras se\u00f1ales (rs1, rs2, rd) siguen siendo de 5-bits, pero s\u00f3lo se estar\u00e1n usando los registros indicados.</p> <p>El register file debe poder leer y escribir a los registros que se especifiquen seg\u00fan la instrucci\u00f3n, sin afectar o modificar a cualquier otro registro. Existe una excepci\u00f3n: El registro cero est\u00e1 alambrado a tierra y su valor no puede ser cambiado por ning\u00fan motivo.</p> <p>Los registros que utilizaremos son los siguientes:</p> Registro por n\u00famero Registro por nombre x0 zero x1 ra x2 sp x5 t0 x6 t1 x8 s0 x9 s1 x10 a0 x11 a1 <p>En el archivo regfile.circ se encuentra el esqueleto de un register file.</p> <p></p> <p>Este tiene seis entradas:</p> Nombre Ancho en bits Descripci\u00f3n Clock 1 Se\u00f1al de reloj. Aqu\u00ed se recibir\u00e1 una se\u00f1al de reloj \"non gated\", es decir, se recibe la se\u00f1al directa sin ser afectada por ANDs, NOTs o cualquier compuerta. Write Enable 1 Indica si se deber\u00eda escribir a un registro en el siguiente flanco de subida del reloj. Read Register 1 5 Registro a leer y cuyo valor ser\u00e1 enviado a Read Data 1. Read Register 2 5 Registro a leer y cuyo valor ser\u00e1 enviado a Read Data 2. Write Register 5 Determina cu\u00e1l registro ser\u00e1 modificado en el siguiente flanco de subida (asumiendo que Write Enable = 1). Write Data 32 Los 32 bits de datos a guardarse en el registro, en el siguiente flanco de subida (asumiendo que Write Enable = 1). <p>El register file tiene las siguientes salidas:</p> Nombre Ancho en bits Descripci\u00f3n Read Data 1 32 Datos que se est\u00e1n leyendo, seg\u00fan el registro que Read Register 1 pidi\u00f3. Read Data 2 32 Datos que se est\u00e1n leyendo, seg\u00fan el registro que Read Register 2 pidi\u00f3. s0 Value 32 Valor de s0 (salida para DEBUG/TEST). s1 Value 32 Valor de s1 (salida para DEBUG/TEST). t0 Value 32 Valor de t0 (salida para DEBUG/TEST). t1 Value 32 Valor de t1 (salida para DEBUG/TEST). a0 Value 32 Valor de a0 (salida para DEBUG/TEST). ra Value 32 Valor de ra (salida para DEBUG/TEST). sp Value 32 Valor de sp (salida para DEBUG/TEST). <p>Las salidas para DEBUG/TEST est\u00e1n presentes porque son registros de uso frecuente (por ejemplo, tienen un trabajo importante en las llamadas a funciones). Se utilizar\u00e1n s\u00f3lo para pruebas del autograder. En un register file de verdad estas salidas no existir\u00edan. Para el proyecto deben estar presentes y funcionar bien para facilitar la calificaci\u00f3n.</p> <p>Pueden modificar regfile.circ como deseen, pero las salidas deben cumplir con el comportamiento que se indica. Deben ser cuidadosos de no modificar (mover, reemplazar, cortar, pegar, eliminar, etc) los pines de entrada o salida. Si necesitan m\u00e1s espacio, pueden moverlos mientras sean cuidadosos de mantener el posicionamiento relativo que estos tienen. Para verificar que nuestros cambios no \"rompan\" nada, podemos abrir regfile-harness.circ y revisar que no existan errores all\u00ed y que todo funcione bien.</p> <p>HINTS: (1) Cuidado con los muxes. Si estos tienen un enable ese deber\u00eda estar activo (o mejor a\u00fan, buscamos en la ayuda de Logisim c\u00f3mo quitar esa funcionalidad). (2) \u00bfTri-estado? Three-state? En CC3 no debemos pensar en estados de alta impedancia (qu'est-ce que c'est?) entonces lo mejor es deshabilitar el uso de three-state.</p>"},{"location":"projects/pj02/#parte-2-alu","title":"Parte 2: ALU","text":"<p>Su segunda tarea es crear un ALU que soporte todas las operaciones que necesitan las instrucciones de nuestro ISA (se detallan m\u00e1s adelante). Van a estar trabajando en el archivo alu.circ.</p> <p></p> <p>Este tiene tres entradas:</p> Nombre de Entrada Ancho en Bits Descripci\u00f3n A 32 Datos para usar por A en la operaci\u00f3n del ALU B 32 Datos para usar por B en la operaci\u00f3n del ALU ALU Op 4 Selecciona la operaci\u00f3n que el ALU debe de efectuar <p>...y cuatro salidas:</p> Nombre de Entrada Ancho en Bits Descripci\u00f3n Out 32 Resultado de la operaci\u00f3n efectuada por el ALU Equal 1 1 si A y B son iguales; 0 de lo contrario LT 1 1 si A es menor que B (signed); 0 de lo contrario LTU 1 1 si A es menor que B (unsigned); 0 de lo contrario <p>Esta es la lista de operaciones que necesitan implementar. Ustedes tienen que utilizar los componentes de logisim que ya efect\u00faan estas operaciones, por favor no las implementen desde cero, ser\u00eda muy tardado y no es el objetivo del proyecto.</p> Valor de ALU Op Instrucci\u00f3n 0 sll: Out = A &lt;&lt; B[4:0] 1 srl: Out = (unsigned) A &gt;&gt; B[4:0] 2 add: Out = A + B 3 and: Out = A &amp; B 4 or: Out = A | B 5 xor: Out = A ^ B 6 slt: Out = (A &lt; B) ? 1 : 0 Signed 7 mul: Out = (X * Y)[31:0] 8 mulh: Out = (A * B)[63:32] 9 div: Out =(unsigned) A / B 10 rem: Out = A % B 11 sub: Out = A - B <p>Algunas cosas adicionales que tienen que tener en mente:</p> <p>La salidas <code>Equal</code>, <code>LT</code>, <code>LTU</code> siempre tienen que sacar el valor correcto de comparaci\u00f3n sin importar el valor de <code>ALU Op</code>. Nuevamente, tienen que tener cuidado con los inputs y output pins, no los modifiquen por ning\u00fan motivo.</p> <p>Su ALU deber\u00eda de encajar con el harness alu_harness.circ. Sigan las mismas instrucciones que en el register file. En particular, ustedes deber\u00edan de asegurar que su ALU es cargado correctamente por el harness antes de que hagan submit.</p>"},{"location":"projects/pj02/#parte-3-cpu","title":"Parte 3: CPU","text":"<p>Se les provee un esqueleto del procesador en cpu.circ. Su procesador tendr\u00e1 una instancia de su ALU y Register File, as\u00ed como una unidad de memoria que ya se les provee. Ustedes son los responsables de construir el datapath y control completos, desde cero. Su procesador debe implementar el ISA que se detalla m\u00e1s abajo.</p> <p></p> <p>Su procesador obtendr\u00e1 su programa del armaz\u00f3n (harness) riscv.circ. Su procesador tendr\u00e1 un output llamado FETCH_ADDRESS que indica cu\u00e1l instrucci\u00f3n queremos, esta direcci\u00f3n ser\u00e1 entregada al harness y este nos dar\u00e1 una instrucci\u00f3n. La instrucci\u00f3n ser\u00e1 recibida por el procesador y ser\u00e1 ejecutada. Revisen riscv.circ para ver exactamente qu\u00e9 sucede.</p> <p>El procesador tiene dos inputs que vienen del harness:</p> Input Name Bit Width Descripci\u00f3n INSTRUCTION 32 Aqu\u00ed se recibe la instrucci\u00f3n que se obtuvo en la direcci\u00f3n identificada por FETCH_ADDRESS. CLOCK 1 Input del reloj. Puede ser necesario estar enviando esta se\u00f1al a varios subcircuitos. Esta se\u00f1al no debe pasar por ninguna compuerta (NOT, AND, etc). <p>El procesador debe tener los siguientes outputs, que entregar\u00e1 al harness:</p> Output Name Bit Width Descripci\u00f3n s0 32 Contenido de s0, s\u00f3lo para pruebas. s1 32 Contenido de s1, s\u00f3lo para pruebas. t0 32 Contenido de t0, s\u00f3lo para pruebas. t1 32 Contenido de t1, s\u00f3lo para pruebas. a0 32 Contenido de a0, s\u00f3lo para pruebas. ra 32 Contenido de ra, s\u00f3lo para pruebas. sp 32 Contenido de sp, s\u00f3lo para pruebas. FETCH_ADDRESS 32 Direcci\u00f3n que indica qu\u00e9 instrucci\u00f3n queremos obtener del harness. En respuesta a esto, el harness enviar\u00e1 alguna instrucci\u00f3n a trav\u00e9s de INSTRUCTION. <p>Como en la parte 1, tengan cuidado al mover componentes y aseg\u00farense que los pines de input y output coincidan con el harness.</p>"},{"location":"projects/pj02/#memoria","title":"Memoria","text":"<p>Se les provee una memoria ya implementada. :D</p> <p>Un resumen de sus inputs y outputs.</p> Nombre Tipo Bit Width Descripci\u00f3n ADDRESS input 32 Direcci\u00f3n a leer o escribir en la memoria. WRITE DATA input 32 Valor a escribirse en la memoria. WRITE ENABLE input 1 En = 1 en las instrucciones que escriben; En = 0 en las dem\u00e1s. Clk input 1 Se\u00f1al de reloj que viene desde cpu.circ. READ DATA output 32 Datos le\u00eddos en la direcci\u00f3n especificada."},{"location":"projects/pj02/#control","title":"Control","text":"<p>Las se\u00f1ales de control tienen un papel muy importante en el proyecto. Se sugiere volver a leer el cap\u00edtulo 4 del libro para darse cuenta d\u00f3nde podemos necesitar un MUX y, por lo tanto, alguna se\u00f1al de control.</p> <p>Existen varias formas de implementar las se\u00f1ales de control. Por ejemplo, pueden construir una palabra de control y guardarla en una memoria ROM (micro-codigo) o pueden construir un circuito que elija qu\u00e9 acci\u00f3n tomar bas\u00e1ndose en algunos bits del opcode, func3 y func7.</p> <p>Es obligatorio que sus componentes est\u00e9n unidos y las se\u00f1ales de control necesarias est\u00e9n implementadas. Si en la calificaci\u00f3n del proyecto s\u00f3lo tiene componentes sueltos (como el ALU y Reg File de la primera fase) y estos no se comunican entre s\u00ed, su nota ser\u00e1 cero.</p> <p>Consejo final: \u00a1Modularicen! Creen los subcircuitos que sean necesarios y dis\u00e9\u00f1enlos bien antes de empezar a construirlos.</p>"},{"location":"projects/pj02/#isa","title":"ISA","text":"<p>Las instrucciones a implementar son las siguientes:</p> Instruction Type Opcode Funct3 Funct7/IMM Operation add rd, rs1, rs2 R 0x33 0x0 0x00 R[rd] \u2190 R[rs1] + R[rs2] mul rd, rs1, rs2 R 0x33 0x0 0x01 R[rd] \u2190 (R[rs1] * R[rs2])[31:0] sub rd, rs1, rs2 R 0x33 0x0 0x20 R[rd] \u2190 R[rs1] - R[rs2] sll rd, rs1, rs2 R 0x33 0x1 0x00 R[rd] \u2190 R[rs1] &lt;&lt; R[rs2 mulh rd, rs1, rs2 R 0x33 0x1 0x01 R[rd] \u2190 (R[rs1] * R[rs2])[63:32] slt rd, rs1, rs2 R 0x33 0x2 0x00 R[rd] \u2190 (R[rs1] &lt; R[rs2]) ? 1 : 0 (signed) xor rd, rs1, rs2 R 0x33 0x4 0x00 R[rd] \u2190 R[rs1] ^ R[rs2] div rd, rs1, rs2 R 0x33 0x4 0x01 R[rd] \u2190 R[rs1] / R[rs2] srl rd, rs1, rs2 R 0x33 0x5 0x00 R[rd] \u2190 R[rs1] &gt;&gt; R[rs2] or rd, rs1, rs2 R 0x33 0x6 0x00 R[rd] \u2190 R[rs1] | R[rs2] rem rd, rs1, rs2 R 0x33 0x6 0x01 R[rd] \u2190 (R[rs1] % R[rs2] and rd, rs1, rs2 R 0x33 0x7 0x00 R[rd] \u2190 R[rs1] &amp; R[rs2] lb rd, offset(rs1) I 0x03 0x0 R[rd] \u2190 SignExt(Mem(R[rs1] + offset, byte)) lh rd, offset(rs1) I 0x03 0x1 R[rd] \u2190 SignExt(Mem(R[rs1] + offset, half)) lw rd, offset(rs1) I 0x03 0x2 R[rd] \u2190 Mem(R[rs1] + offset, word) addi rd, rs1, imm I 0x13 0x0 R[rd] \u2190 R[rs1] + imm slli rd, rs1, imm I 0x13 0x1 0x00 R[rd] \u2190 R[rs1] &lt;&lt; imm slti rd, rs1, imm I 0x13 0x2 R[rd] \u2190 (R[rs1] &lt; imm) ? 1 : 0 xori rd, rs1, imm I 0x13 0x4 R[rd] \u2190 R[rs1] ^ imm srli rd, rs1, imm I 0x13 0x5 0x00 R[rd] \u2190 R[rs1] &gt;&gt; imm ori rd, rs1, imm I 0x13 0x6 R[rd] \u2190 R[rs1] | imm andi rd, rs1, imm I 0x13 0x7 R[rd] \u2190 R[rs1] &amp; imm sw rs2, offset(rs1) S 0x23 0x2 Mem(R[rs1] + offset) \u2190 R[rs2] beq rs1, rs2, offset SB 0x63 0x0 if(R[rs1] == R[rs2]) then {PC \u2190 PC + {offset, 1b'0}} blt rs1, rs2, offset SB 0x63 0x4 if(R[rs1] less than R[rs2] (signed)) then {PC \u2190 PC + {offset, 1b'0}} bltu rs1, rs2, offset SB 0x63 0x6 if(R[rs1] less than R[rs2] (unsigned)) then {PC \u2190 PC + {offset, 1b'0}} lui rd, offset U 0x37 R[rd] \u2190 jal rd, imm UJ 0x6f R[rd] \u2190 PC + 4, PC \u2190 PC + jalr rd,rs, imm I 0x67 0x0 R[rd] \u2190 PC + 4, PC \u2190 R[rs] +"},{"location":"projects/pj02/#testing","title":"Testing","text":"<p>Para la parte 1 y 2, con el check local es suficiente y si lo pasan significa que esas partes ya las tienen funcionando al 100%. Para la parte 2, el check local tambi\u00e9n es bastante completo, pero ustedes pueden hacer m\u00e1s pruebas si lo desean. Como no podemos probar cada componente que ustedes vayan implementando, la mejor opci\u00f3n es escribir programas de RISC-V peque\u00f1os e ir revisando su datapath de diferentes maneras.</p> <p>Una vez que hayan escrito su programa de RISC-V, lo van a tener que cargar en la ROM que est\u00e1 en riscv.circ y empezar la ejecuci\u00f3n. Para eso, primero, abran riscv.circ y localicen la memoria ROM.</p> <p></p> <p>Hagan click a la memoria y, despu\u00e9s, en la barra de herramientas de la izquierda, hagan click en \"(click here to edit)\", esto va a abrir un di\u00e1logo en donde ustedes pueden cargar su archivo con el c\u00f3digo de RISC-V y este ensamblar\u00e1 y generar\u00e1 c\u00f3digo de m\u00e1quina por ustedes que va a ser la salida de la memoria ROM.</p> <p></p>"},{"location":"projects/pj02/#notas-sobre-logisim","title":"Notas sobre Logisim","text":"<p>Si Logisim les da alg\u00fan problema extra\u00f1o, REINICIEN LOGISIM Y VUELVAN A CARGAR SU CIRCUITO. No pierdan tiempo buscando errores si no han hecho esto. Si reiniciar no ha resuelto el problema, all\u00ed s\u00ed ya les corresponde revisar su circuito.</p> <p>Logisim tiene un \"Reference\", en la pesta\u00f1a \"Help\", y les dice las especificaciones de cada componente.</p> <p>Do NOT gate the clock! (esto no tiene una traducci\u00f3n directa). Los clocks tienen que llegar directo a los circuitos, ni en CC3 ni en un curso donde usen hardware deber\u00edan colocar compuertas antes que la se\u00f1al de reloj entre al componente.</p> <p>Si est\u00e1n usando varias ventanas de Logisim tengan mucho cuidado cuando hagan copy-paste de una ventana a otra. Aseg\u00farense que s\u00ed se copi\u00f3 el circuito completo que quer\u00edan y que funcione bien despu\u00e9s de pegarlo.</p> <p>Cuando importen otro archivo (Project -&gt; Load Library -&gt; Logisim Library...), este aparecer\u00e1 como un folder en el panel de la izquierda. Los archivos esqueleto deber\u00edan de tener importado todo lo necesario.</p> <p>Cambiar los atributos antes de colocar un componente cambia el default. Si quieren colocar varios pines de 32 bits (por ejemplo), habr\u00eda que cambiarlo antes de colocar el primero. Si s\u00f3lo quieren cambiar alg\u00fan valor para un componente, primero lo colocan y, luego, lo cambian.</p> <p>Cuando cambian los inputs y outputs de un subcircuito que ya colocaron en main, Logisim autom\u00e1ticamente a\u00f1ade o remueve puertos seg\u00fan los cambios que hagan. Esto, muchas veces, afecta el tama\u00f1o o posici\u00f3n del subcircuito. Si ya hab\u00edan cables conectados, Logisim intentar\u00e1 moverlos, pero no siempre lo hace bien. Se recomienda que si van a cambiar los inputs y outputs de un circuito, primero desconecten todos los cables que este pueda tener en main o lo eliminen del main y lo vuelvan a colocar despu\u00e9s de cambiarlo. Recuerden que s\u00f3lo pueden hacer esto para los subcircuitos que USTEDES agregan.</p> <p>Los cables rojos significan que algo est\u00e1 mal conectado. Algunos casos pueden no ser tan obvios, revisen bien todas las conexiones cercanas.</p> <p></p> <p>Logisim tiene algunas herramientas de an\u00e1lisis combinacional (nos puede construir mapas de Karnaugh o circuitos completos con s\u00f3lo darle una tabla :D). Esta herramienta les puede ser \u00fatil en alg\u00fan momento de sus vidas, pero la recomendaci\u00f3n es no usarla en CC3. Recuerden que durante los ex\u00e1menes tendr\u00e1n que hacer mapas o circuitos a mano, sin acceso a su computadora.</p>"},{"location":"projects/pj02/#calificacion","title":"Calificaci\u00f3n","text":"<p>Pueden utilizar <code>./check</code> para obtener una calificaci\u00f3n.</p> <pre><code>./check\n</code></pre> <p>Si todo esta correcto les saldr\u00e1 algo como esto:</p> <pre><code>   ___       __                        __       / _ |__ __/ /____  ___  _______ ____/ /__ ____\n / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _  / -_) __/\n/_/ |_\\_,_/\\__/\\___/\\_, /_/  \\_,_/\\_,_/\\__/_/\n                   /___/\n\n             Machine Structures\n     Great Ideas in Computer Architecture\n               Project 2: CPU\n\n\nExercise            Grade  Message\n----------------  -------  -----------------\n1. ALU                25  passed\n2. Register File      25  passed\n3. CPU                50  passed\n\n=&gt; Score: 0/100\n</code></pre> <p>Al finalizar, recuerde hacer <code>add</code>, <code>commit</code> y <code>push</code> hacia Github. Luego env\u00ede el link de su repositorio en el GES. Si no env\u00eda el link, no podremos ponerle nota!</p>"},{"location":"tutorials/autograder/","title":"Autograder","text":""},{"location":"tutorials/autograder/#objetivos","title":"Objetivos","text":"<ul> <li>Crear una cuenta en autograders.</li> <li>Aprender a utilizar el autograder.</li> </ul>"},{"location":"tutorials/autograder/#instalando-el-autograder","title":"Instalando el autograder","text":"<p>Para el curso de CC3 AN vamos a estar utilizando un autograder, este autograder nos va a permitir correr los tests de sus laboratorios y proyectos de forma autom\u00e1tica. Esto nos va a permitir a nosotros, como staff, corregir sus tareas y proyectos de forma m\u00e1s r\u00e1pida y eficiente.</p> <p>Para poder utilizar el autograder, necesitan instalar el programa <code>autograder</code> en su computadora. Para esto, sigan los siguientes pasos:</p>"},{"location":"tutorials/autograder/#1-nodejs","title":"1. Node.js","text":"<p>El autograder est\u00e1 escrito en Node.js, por lo que necesitan instalar Node.js en su computadora. Para esto, vamos a utilizar NVM (Node Version Manager), un programa que nos va a permitir instalar m\u00faltiples versiones de Node.js en nuestra computadora.</p> <p>Para instalar NVM, sigan los siguientes pasos:</p> <p>Abran una terminal Ctrl+Alt+T. En la terminal, ejecuten el siguiente comando:</p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash\n</code></pre> <p>o utilizando wget:</p> <pre><code>wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash\n</code></pre> <p>Esto va a instalar NVM en su computadora. Ahora, necesitan hacer source de su archivo de configuraci\u00f3n de NVM para que los cambios que hizo NVM se apliquen. Para esto, ejecuten el siguiente comando:</p> <pre><code>source ~/.bashrc\n</code></pre> <p>Si est\u00e1n utilizando otro shell, pueden ejecutar el comando <code>echo $SHELL</code> para ver cual es su shell y reemplazar <code>~/.bashrc</code> por el archivo de configuraci\u00f3n de su shell.</p> <p>Ahora, vamos a instalar Node.js. Para esto, ejecuten el siguiente comando:</p> <pre><code>nvm install --lts\n</code></pre> <p>Esto va a instalar la \u00faltima versi\u00f3n LTS de Node.js en su computadora. Para verificar que Node.js se instal\u00f3 correctamente, ejecuten el siguiente comando:</p> <pre><code>node --version\n</code></pre> <p>Esto deber\u00eda mostrar la versi\u00f3n de Node.js que instal\u00f3.</p>"},{"location":"tutorials/autograder/#2-autograder","title":"2. Autograder","text":"<p>Ahora, vamos a instalar el autograder. Para esto, ejecuten el siguiente comando:</p> <pre><code>npm install -g npm@latest\nnpm install -g @autograder/cli@latest\n</code></pre> <p>Esto va a instalar el autograder en su computadora. Para verificar que el autograder se instal\u00f3 correctamente, ejecuten el siguiente comando:</p> <pre><code>autograder --version\n</code></pre> <p>Les deber\u00eda aparecer la versi\u00f3n del autograder que instal\u00f3. Por ejemplo:</p> <pre><code> _\n|-|  __\n|=| [Ll]        Autograder\n\"^\" ====`o\n\nv1.3.1\n</code></pre>"},{"location":"tutorials/autograder/#utilizando-el-autograder","title":"Utilizando el autograder","text":"<p>La manera m\u00e1s f\u00e1cil de empezar a utilizar el autograder, es analizando los comandos que el autograder tiene disponibles. Para ver los comandos disponibles, ejecuten el siguiente comando:</p> <pre><code>autograder --help\n</code></pre> <p>Esto les va a mostrar los comandos disponibles. Por ejemplo:</p> <pre><code> _\n|-|  __\n|=| [Ll]        Autograder\n\"^\" ====`o\n\nUsage: autograder [options] [command]\n\nOptions:\n  -V, --version   output the version number\n  -h, --help      display help for command\n\nCommands:\n  auth            autograder authentication\n  course          autograder course management\n  assignment      autograder assignment management\n  submit          autograder submission management\n  user            autograder user management\n  help [command]  display help for command\n</code></pre> <p>Estos son los comandos disponibles:</p> <ul> <li><code>auth</code>: Comandos para autenticarse en el autograder.</li> <li><code>course</code>: Comandos para administrar los cursos.</li> <li><code>assignment</code>: Comandos para administrar las tareas.</li> <li><code>submit</code>: Comandos para administrar las entregas.</li> <li><code>user</code>: Comandos para administrar el usuario.</li> </ul> <p>Para ver los comandos disponibles para cada comando, ejecuten el siguiente comando:</p> <pre><code>autograder help &lt;comando&gt;\n</code></pre> <p>Por ejemplo, para ver los comandos disponibles para el comando <code>auth</code>, ejecuten el siguiente comando:</p> <pre><code>autograder help auth\n</code></pre> <p>Esto les va a mostrar los comandos disponibles para el comando <code>auth</code>. Por ejemplo:</p> <pre><code> _\n|-|  __\n|=| [Ll]        Autograder\n\"^\" ====`o\n\nUsage: autograder auth [options] [command]\n\nautograder authentication\n\nOptions:\n  -h, --help         display help for command\n\nCommands:\n  signin [options]   sign in to autograders\n  signup [options]   sign up to autograders\n  signout [options]  sign out from autograders\n  verify [options]   verify autograders account email\n  forgot [options]   forgot autograders password\n  reset [options]    reset autograders password\n  help [command]     display help for command\n</code></pre>"},{"location":"tutorials/autograder/#creando-una-cuenta-en-el-autograder","title":"Creando una cuenta en el autograder","text":"<p>Para poder utilizar el autograder, necesitan crear una cuenta en el autograder. Para esto, sigan los siguientes pasos:</p> <pre><code>autograder auth signup\n</code></pre> <p>Esto les va a pedir que ingresen su nombre completo, correo electr\u00f3nico y su contrase\u00f1a. Luego, presionen enter para crear su cuenta. Por ejemplo:</p> <pre><code> _\n|-|  __\n|=| [Ll]        Autograder\n\"^\" ====`o\n\n=&gt;    Auth | Sign Up\n\nPlease enter your details:\n\n? Full Name:  Andr\u00e9s Castellanos\n? Email:  andres.cv@galileo.edu\n? Password:  \u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 Id    \u2502 5bac3a00-7b5c-4f47-abc1-c73a89e0c7fe \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Email \u2502 andres.cv@galileo.edu                \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Name  \u2502 Andr\u00e9s Castellanos                   \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\nPlease check your email and enter the token below.\n</code></pre> <p>Una vez que crearon su cuenta, el autograder les va a enviar un correo electr\u00f3nico con un token. Para verificar su cuenta, necesitan ingresar el token que recibieron en el correo electr\u00f3nico. Para esto, ejecuten el siguiente comando:</p> <pre><code>autograder auth verify\n</code></pre> <p>Esto les va a pedir que ingresen el token que recibieron en el correo electr\u00f3nico. Luego, presionen enter para verificar su cuenta. Por ejemplo:</p> <pre><code> _\n|-|  __\n|=| [Ll]        Autograder\n\"^\" ====`o\n\n=&gt;    Auth | Verify Email\n\nPlease enter the verification token:\n\n? Token:  \u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\n\u2714 Email verified successfully.\n</code></pre>"},{"location":"tutorials/autograder/#ingresando-a-su-cuenta-en-el-autograder","title":"Ingresando a su cuenta en el autograder","text":"<p>Ahora, vamos a ingresar a su cuenta en el autograder. Para esto, ejecuten el siguiente comando:</p> <pre><code>autograder auth signin\n</code></pre> <p>Esto les va a pedir que ingresen su correo electr\u00f3nico y su contrase\u00f1a. Luego, presionen enter para ingresar a su cuenta. Por ejemplo:</p> <pre><code> _\n|-|  __\n|=| [Ll]        Autograder\n\"^\" ====`o\n\n=&gt;    Auth | Sign In\n\nPlease enter your credentials:\n\n? Email:  me@andrescv.dev\n? Password:  \u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\n\u2714 Signed in successfully!\n</code></pre>"},{"location":"tutorials/autograder/#registrandose-al-curso-de-cc3-an","title":"Registrandose al curso de CC3 AN","text":"<p>Ahora, vamos a registrarse al curso de CC3 AN. Para esto, ejecuten el siguiente comando:</p> <pre><code>autograder course enroll\n</code></pre> <p>Esto les va a pedir que ingresen el c\u00f3digo del curso. El c\u00f3digo del curso es <code>cceaffc2-612c-47c4-9edc-27d9871b19ee</code>. Luego, presionen enter para registrarse al curso. Por ejemplo:</p> <pre><code> _\n|-|  __\n|=| [Ll]        Autograder\n\"^\" ====`o\n\n=&gt;    Course | Enroll\n\nPlease enter the course id:\n\n? Course id:  cceaffc2-612c-47c4-9edc-27d9871b19ee\n\n\u2714 Enrolled successfully!\n\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 Id          \u2502 cceaffc2-612c-47c4-9edc-27d9871b19ee \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Title       \u2502 CC3 AN 2023                          \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Description \u2502 Machine Structures                   \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre> <p>Para verificar que se registraron al curso, ejecuten el siguiente comando:</p> <pre><code>autograder course list\n</code></pre> <p>Esto les va a mostrar los cursos en los que se registraron. Por ejemplo:</p> <pre><code> _\n|-|  __\n|=| [Ll]        Autograder\n\"^\" ====`o\n\n=&gt;    Course | List\n\n\u2714 Got all courses successfully!\n\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 Id                                   \u2502 Title       \u2502 Description        \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 cceaffc2-612c-47c4-9edc-27d9871b19ee \u2502 CC3 AN 2023 \u2502 Machine Structures \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre> <p>Listo \ud83c\udf89. Ya se registraron al curso de CC3 AN. Para enviar sus laboratorios y proyectos, las instrucciones estar\u00e1n en el repositorio de cada laboratorio y proyecto.</p>"},{"location":"tutorials/autograder/#cerrando-sesion-en-el-autograder","title":"Cerrando sesi\u00f3n en el autograder","text":"<p>Siempre que terminen de utilizar el autograder y NO est\u00e9n utilizando una computadora que puedan confiar que nadie m\u00e1s la va a utilizar (labs de la U, computadora prestada, etc.), deben cerrar sesi\u00f3n en el autograder. Para esto, ejecuten el siguiente comando:</p> <pre><code>autograder auth signout\n</code></pre> <p>CUIDADO: si no cierran sesi\u00f3n en el autograder, cualquier persona que tenga acceso a su computadora, puede utilizar su cuenta en el autograder para enviar sus laboratorios y proyectos. Lo cual les puede perjudicar sus calificaciones.</p>"},{"location":"tutorials/git/","title":"Git y GitHub","text":""},{"location":"tutorials/git/#objetivos","title":"Objetivos","text":"<ul> <li>Aprender git.</li> <li>Crear una cuenta de GitHub.</li> </ul>"},{"location":"tutorials/git/#cuenta-de-github","title":"Cuenta de GitHub","text":"<p>Para este curso necesitaremos que utilicen git, un sistema de control de versiones distribuido. Los sistemas de control de versiones son las mejores herramientas para compartir y almacenar c\u00f3digo a comparaci\u00f3n de mandar correos con archivos adjuntos, utilizar memorias flash, o incluso compartir documentos mediante DropBox o Google Docs.</p> <p>Vamos a estar usando GitHub para tener repositorios privados en donde van a almacenar su c\u00f3digo remotamente. Si la oraci\u00f3n anterior no les dijo nada, no se preocupen, vamos a guiarlos en el proceso m\u00e1s adelante. Pero primero, necesitan crear una cuenta de GitHub.</p> <p>\u00bfPor qu\u00e9 GitHub? GitHub ahora permite a todas las cuentas gratuitas tener repositorios privados ilimitados con algunas limitaciones que no van a ser ning\u00fan problema para nosotros.</p>"},{"location":"tutorials/git/#github-onboarding","title":"GitHub Onboarding","text":"<p>Naveguen a la siguiente p\u00e1gina: github.com. Si no tienen una cuenta de GitHub todav\u00eda, creen una en el siguiente link.</p>"},{"location":"tutorials/git/#configurando-git","title":"Configurando git","text":"<p>Ahora que ya han creado su cuenta de GitHub, vamos a configurar git para que sepa qui\u00e9nes son. Abran una terminal Ctrl+Alt+T y ejecuten los siguientes comandos listados abajo, reemplazando NOMBRE con su nombre y apellido (entre comillas) y CORREO con la direcci\u00f3n de correo que utilizar\u00f3n para registrarse en GitHub.</p> <pre><code>git config --global user.name \"NOMBRE\"\n</code></pre> <pre><code>git config --global user.email \"CORREO\"\n</code></pre> <p>Ahora vamos a configurar git para que sepa que editor de texto vamos a utilizar. Para esto, ejecuten el siguiente comando:</p> <pre><code>git config --global core.editor \"nano\"\n</code></pre> <p>Si prefieren utilizar otro editor de texto, pueden cambiar \"nano\" por el nombre del editor que prefieran. Si no saben cual es el nombre del editor que prefieren, pueden ejecutar el comando <code>git config --global core.editor</code> para ver cual es el editor que git est\u00e1 utilizando.</p> <p>Ahora vamos a configurar git para que utilice el branch <code>main</code> por defecto. Para esto, ejecuten el siguiente comando:</p> <pre><code>git config --global init.defaultBranch main\n</code></pre> <p>Por \u00faltimo, vamos a configurar git para que sepa que vamos a utilizar el protocolo SSH para conectarnos a GitHub (m\u00e1s informaci\u00f3n en el siguiente link). Para esto, ejecuten el siguiente comando:</p> <pre><code>ssh-keygen -t ed25519 -C \"&lt;correo&gt;\"\n</code></pre> <p>Recuerden reemplazar <code>&lt;correo&gt;</code> con la direcci\u00f3n de correo que utilizar\u00f3n para registrarse en GitHub.</p> <p>Esto crear\u00e1 una llave SSH en su computadora. Ahora, ejecuten el siguiente comando:</p> <pre><code>ssh-add ~/.ssh/id_ed25519\n</code></pre> <p>Dirijanse a la siguiente p\u00e1gina: https://github.com/settings/ssh/new y vamos a copiar nuestra llave SSH. Para esto, ejecuten el siguiente comando:</p> <pre><code>cat ~/.ssh/id_ed25519.pub\n</code></pre> <p>deber\u00eda mostrar algo como lo siguiente:</p> <pre><code>ssh-ed25519 AAAAC3NzaC1lZDI1NTE5BBBBIHxwhpY/9j123ZcIX95H+ah1kNcMl3W7vtuDALylfqst me@andrescv.dev\n</code></pre> <p>Y peguenlo en la pagina de GitHub.</p> <p></p> <p>Ahora, vamos a probar que todo est\u00e1 funcionando correctamente. Para esto, ejecuten el siguiente comando:</p> <pre><code>ssh -T git@github.com\n</code></pre> <p>Puede que les salga un mensaje como el siguiente:</p> <pre><code>&gt; The authenticity of host 'github.com (IP ADDRESS)' can't be established.\n&gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\n&gt; Are you sure you want to continue connecting (yes/no)?\n</code></pre> <p>Si es as\u00ed, escriban <code>yes</code> y presionen enter. Al finalizar les deber\u00eda aparecer un mensaje como el siguiente:</p> <pre><code>Hi &lt;USUARIO&gt;! You've successfully authenticated, but GitHub does not provide shell access.\n</code></pre> <p><code>&lt;USUARIO&gt;</code> es su nombre de usuario de GitHub.</p>"},{"location":"tutorials/git/#git-y-github-remotes","title":"git y GitHub remotes","text":"<p>Primero, algunas definiciones r\u00e1pidas:</p> <ul> <li> <p>Un remote es la p\u00e1gina web host o servidor que va a almacenar su c\u00f3digo remotamente en vez de tener \u00fanicamente el c\u00f3digo de forma local en su propia computadora. Pueden pensar en esto de igual manera a como se almacena un archivo en DropBox o Google Drive pero con el poder que nos da git.</p> </li> <li> <p>Un branch es una secuencia (por aparte) de diferentes cambios a su c\u00f3digo. Pueden pensar en los branches como diferentes versiones de su c\u00f3digo, que en alg\u00fan punto fueron lo mismo. La siguiente figura muestra a que nos referimos como branches.</p> </li> </ul> <p></p> <p>A lo largo de este curso, estar\u00e1n trabajando en dos diferentes \"computadoras\" que generalmente tendran diferentes versiones de su c\u00f3digo en alg\u00fan tiempo. Estas dos son: su computadora personal y su remote de GitHub (sus repositorios privados de GitHub). Es esencial que entiendan la diferencia entre estas dos y como pueden compartir c\u00f3digo entre ellas.</p> <ol> <li>Su computadora personal es la que les servir\u00e1 para hacer todo el trabajo (laboratorios y proyectos) que necesiten hacer durante el curso, nada nuevo aqu\u00ed.</li> <li>Su cuenta de GitHub y los remotes les servir\u00e1n para muchos prop\u00f3sitos, pero la principal raz\u00f3n es para tener un backup o copia de respaldo, de tal manera que si algo malo le sucede a sus computadoras (esperamos no ), puedan recuperar su c\u00f3digo en vez de empezar de cero nuevamente. Conceptualmente, pueden pensar en los remotes de GitHub como otra computadora que \u00fanicamente almacena su c\u00f3digo y nada m\u00e1s. Siempre deben subir sus cambios a GitHub haciendo push al remote (es decir actualizando los archivos en GitHub) y tambi\u00e9n pueden descargar los cambios de GitHub haciendo pull (actualizando los archivos en su computadora personal).</li> </ol>"},{"location":"tutorials/git/#git-cheat-sheet","title":"git cheat sheet","text":"<p>A continuaci\u00f3n, les presentamos una lista de comandos que les ser\u00e1n \u00fatiles a lo largo del curso. Siempre pueden consultar esta lista cuando lo necesiten.</p> Comando Descripci\u00f3n <code>git init</code> Inicializa un repositorio git en la carpeta actual. <code>git add &lt;archivo&gt;</code> Agrega un archivo al repositorio. <code>git commit -m \"&lt;mensaje&gt;\"</code> Hace commit de los archivos agregados al repositorio. <code>git status</code> Muestra el estado actual del repositorio. <code>git log</code> Muestra el historial de commits del repositorio. <code>git branch &lt;nombre&gt;</code> Crea un nuevo branch con el nombre <code>&lt;nombre&gt;</code>. <code>git checkout &lt;nombre&gt;</code> Cambia al branch con el nombre <code>&lt;nombre&gt;</code>. <code>git merge &lt;nombre&gt;</code> Une el branch actual con el branch con el nombre <code>&lt;nombre&gt;</code>. <code>git push</code> Sube los cambios al remote. <code>git pull</code> Descarga los cambios del remote. <p>Para m\u00e1s informaci\u00f3n, pueden consultar la documentaci\u00f3n oficial. O tambi\u00e9n pueden consultar el siguiente cheat sheet.</p>"},{"location":"tutorials/install/","title":"Tutorial de Instalaci\u00f3n de Material","text":"<p>El objetivo de este tutorial es dejar preparado el material que necesitar\u00e1n para los laboratorios y proyectos.</p>"},{"location":"tutorials/install/#la-mejor-opcion-maquina-virtual","title":"La mejor opci\u00f3n: M\u00e1quina virtual","text":"<p>Descarguen la siguiente m\u00e1quina virtual y \u00e1branla con VMware. Recuerde que usando VMware Player (gratuito, sin necesidad de licencia) pueden abrir y utilizar m\u00e1quinas virtuales ya hechas.</p> <p>Descargar m\u00e1quina virtual desde Google Drive</p>"},{"location":"tutorials/install/#credenciales","title":"Credenciales","text":"<ul> <li>Usuario: student</li> <li>Password: student</li> </ul> <p>La m\u00e1quina virtual ya trae todo lo necesario para el semestre.</p>"},{"location":"tutorials/install/#instalacion-nativa","title":"Instalaci\u00f3n Nativa","text":"<p>Para trabajar nativo necesitar\u00e1n Ubuntu 18 o 20 en ingl\u00e9s, se recomienda 18.</p> <p>Si su Ubuntu no se encuentra en ingl\u00e9s, tendra problemas en el lab 2 (cgdb). Pueden cambiar su idioma, o buscar la soluci\u00f3n al problema en Google.</p> <p>Si todav\u00eda no tienen Ubuntu instalado aqu\u00ed hay un tutorial para dual boot. Pongan mucha atenci\u00f3n, sean muy cuidadosos y sobre todo hagan un backup de su informaci\u00f3n importante.</p> <p>Wow... parece que son bastantes instrucciones, \u00a1Ser\u00eda m\u00e1s f\u00e1cil usar la m\u00e1quina virtual! (?)</p>"},{"location":"tutorials/install/#instalar-git","title":"Instalar git","text":"<pre><code>sudo apt update\nsudo apt install git\n</code></pre>"},{"location":"tutorials/install/#instalar-java","title":"Instalar Java","text":"<pre><code>sudo apt update\nsudo apt install default-jdk\n</code></pre>"},{"location":"tutorials/install/#instalar-python-3","title":"Instalar Python 3","text":"<pre><code>sudo apt update\nsudo apt install software-properties-common\nsudo add-apt-repository ppa:deadsnakes/ppa\nsudo apt update\nsudo apt install python3.7\n</code></pre>"},{"location":"tutorials/install/#instalar-pip","title":"Instalar pip","text":"<pre><code>sudo apt update\nsudo apt install python3-pip\n</code></pre> <p>Las versiones recientes de Python suelen incluir todo lo que necesitamos (en la maquina virtual ya revisamos y esta todo lo que necesitan! en serio, usen la m\u00e1quina virtual!), verifiqu\u00e9moslo abriendo la terminal de Python con el comando <code>python3</code>, luego en la terminal escribiremos los siguientes comandos</p> <pre><code>import os\nimport sys\nimport requests\nimport zipfile\n</code></pre> <p>Si ninguno nos dio problema, Python esta listo; si alguno fallo, lo instalaremos con pip</p> <pre><code>pip3 install nombreDelPaqueteQueDioError\n</code></pre>"},{"location":"tutorials/install/#curl","title":"cURL","text":"<p>Finalmente instalamos curl</p> <pre><code>sudo apt update\nsudo apt install curl\n</code></pre>"},{"location":"tutorials/install/#cgdb","title":"CGDB","text":"<p>Y terminamos instalando cgdb</p> <pre><code>sudo apt update\nsudo apt install cgdb\n</code></pre> <p>Casi listo! Cuando lleguemos al lab 3 y al lab 5 alli le aparecer\u00e1n las instrucciones para instalar el software faltante.</p>"}]}